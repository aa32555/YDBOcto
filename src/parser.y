/****************************************************************
 *								*
 * Copyright (c) 2019 YottaDB LLC and/or its subsidiaries.	*
 * All rights reserved.						*
 *								*
 *	This source code contains the intellectual property	*
 *	of its copyright holder(s), and is made available	*
 *	under a license.  If you do not know the terms of	*
 *	the license, please stop and do not read further.	*
 *								*
 ****************************************************************/

%require "3.0"
%debug

%code requires {
#ifndef YY_TYPEDEF_YY_SCANNER_T
#define YY_TYPEDEF_YY_SCANNER_T
typedef void* yyscan_t;
#endif
}

%{
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <string.h>
#include <ctype.h>

#include "octo.h"
#include "octo_types.h"
#include "parser.h"

#define YYERROR_VERBOSE
#define YYDEBUG 1
#define YYSTYPE SqlStatement *
/* YYMAXDEPTH defines the number of symbols the parser can store in its stack
 * if this value is excceded then a "memory exhausted" error is issued
 * the default is 10000
 * behavoir is undefined if this relation is false: YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES(YYMAXDEPTH)
 * where YYSTACK_ALLOC_MAXIUM is 2^32-1 on 32 bit machines and 2^64-1 on 64bit machines
 * and YYSTACK_BYTES is a macro generated by bison found in parser.c
 * it is currently (YYMAXDEPTH * 26 + 30)
 */
#define YYMAXDEPTH 10000000

extern int yylex(YYSTYPE * yylval_param, YYLTYPE *llocp, yyscan_t yyscanner);
extern int yyparse(yyscan_t scan, SqlStatement **out, int *plan_id);
extern void yyerror(YYLTYPE *llocp, yyscan_t scan, SqlStatement **out, int *plan_id, char const *s);

%}

%define api.pure full
%locations
%lex-param   { yyscan_t scanner }
%parse-param { yyscan_t scanner } { SqlStatement **out } { int *plan_id }

%token ADVANCE
%token ALL
%token AND
%token AS
%token ASC
%token AVG
%token BEG
%token BETWEEN
%token BY
%token CASCADE
%token CASE
%token CHAR
%token CHARACTER
%token COLLATE
%token COMMAND
%token COMMIT
%token CORRESPONDING
%token COUNT
%token CREATE
%token CROSS
%token CURSOR
%token DEC
%token DECIMAL
%token DEFAULT
%token DELETE
%token DELIM
%token DESC
%token DISTINCT
%token DROP
%token ELSE
%token END
%token EXCEPT
%token EXISTS
%token EXTRACT
%token EXTRINSIC_FUNCTION
%token FROM
%token FULL
%token GLOBAL
%token GROUP
%token HAVING
%token IDENTIFIER_START
%token ILIKE
%token IN
%token INNER
%token INSERT
%token INT
%token INTEGER
%token INTERSECT
%token INTO
%token IS
%token JOIN
%token KEY
%token LEFT
%token LIKE
%token LIMIT
%token MAX
%token MIN
%token NATURAL
%token NOT
%token NUM
%token NUMERIC
%token ON
%token OR
%token ORDER
%token OUTER
%token OVER
%token PACK
%token PARTITION
%token PIECE
%token PRIMARY
%token RESTRICT
%token RIGHT
%token SELECT
%token SET
%token SHOW
%token SIMILAR
%token SMALLINT
%token START
%token SUM
%token TABLE
%token THEN
%token TO
%token UNION
%token UNIQUE
%token UNKNOWN
%token UNPACK
%token UPDATE
%token USING
%token VALUES
%token VARCHAR
%token VARYING
%token WHEN
%token WHERE

%token TRUE_TOKEN
%token FALSE_TOKEN
%token NULL_TOKEN
%token COMMA
%token LEFT_PAREN
%token RIGHT_PAREN
%token SEMICOLON
%token PLUS
%token MINUS
%token ASTERISK
%token SOLIDUS
%token PERCENT
%token PERIOD
%token EQUALS
%token NOT_EQUALS
%token LESS_THAN
%token GREATER_THAN
%token LESS_THAN_OR_EQUALS
%token GREATER_THAN_OR_EQUALS
%token PIPE
%token TILDE
%token EXCLAMATION
%token LEFT_BRACKET
%token RIGHT_BRACKET
%token COLON

%token LITERAL
%token FAKE_TOKEN
%token INVALID_TOKEN

%token ENDOFFILE
%token EXIT
%token QUIT

%%

sql_statement
  : sql_schema_statement semicolon_or_eof {
      if (!config->allow_schema_changes){
           ERROR(ERR_ROCTO_NO_SCHEMA, NULL);
           YYABORT;
      }
      *out = $sql_schema_statement;
      YYACCEPT;
    }
  | sql_data_statement semicolon_or_eof { *out = $sql_data_statement; YYACCEPT; }
  | query_expression semicolon_or_eof {
      if(qualify_query($query_expression, NULL)) {
          YYABORT;
      }
      SqlValueType type;
      if(populate_data_type($query_expression, &type)) {
          YYABORT;
      }
      *out = $query_expression; YYACCEPT;
    }
  | BEG semicolon_or_eof {
      // For now, we don't do transaction, so just say OK to this word
      SQL_STATEMENT(*out, begin_STATEMENT);
      YYACCEPT;
    }
  | COMMIT semicolon_or_eof {
      SQL_STATEMENT(*out, commit_STATEMENT);
      YYACCEPT;
    }
  | error semicolon_or_eof { *out = NULL; YYABORT; }
  | sql_set_statement semicolon_or_eof { *out = $sql_set_statement; YYACCEPT; }
  | semicolon_or_eof {
      SQL_STATEMENT(*out, no_data_STATEMENT);
      YYACCEPT;
    }
  | exit_command {
      SQL_STATEMENT(*out, no_data_STATEMENT);
      eof_hit = TRUE;
      YYACCEPT;
  }
  ;

semicolon_or_eof
  : SEMICOLON { if('\0' != input_buffer_combined[cur_input_index]) cur_input_index--; } // The lexer will read one past the SEMICOLON if there is a character there so back up one character
  | ENDOFFILE { assert(TRUE == eof_hit); } // The lexer should have set eof_hit at this point and this should always be true
  ;

exit_command
  : QUIT
  | EXIT
  ;

%include "parser/select.y"
%include "parser/insert.y"
%include "parser/update.y"
%include "parser/drop.y"
%include "parser/set.y"

sql_data_statement
  : sql_data_change_statement { $$ = $sql_data_change_statement; }
//  | open_statement
//  | fetch_statement
//  | close_statement
//  | select_statement_single_row
  ;

sql_data_change_statement

  : delete_statement_searched { $$ = $delete_statement_searched; }
//  | delete_statement_position
  | insert_statement { $$ = $insert_statement; }
//  | update_statement_positioned
  | update_statement_searched { $$ = $update_statement_searched; }
  ;

delete_statement_searched
  : DELETE FROM column_name delete_statement_searched_tail { WARNING(ERR_FEATURE_NOT_IMPLEMENTED, "DELETE FROM"); YYABORT; }
  ;

delete_statement_searched_tail
  : /* Empty */ { $$ = NULL; }
  | WHERE search_condition { WARNING(ERR_FEATURE_NOT_IMPLEMENTED, "WHERE search_condition"); YYABORT; }
  ;

search_condition
  : boolean_term {$$ = $boolean_term; }
  | search_condition OR boolean_term  {
      SQL_STATEMENT($$, binary_STATEMENT);
      MALLOC_STATEMENT($$, binary, SqlBinaryOperation);
      ($$)->v.binary->operation = BOOLEAN_OR;
      ($$)->v.binary->operands[0] = ($1);
      ($$)->v.binary->operands[1] = ($boolean_term);
    }
  | row_value_constructor OR boolean_term {
      // This is a special form where the column is assumed to be a boolean
      SqlStatement		*left;

      SQL_STATEMENT($$, binary_STATEMENT);
      MALLOC_STATEMENT($$, binary, SqlBinaryOperation);
      ($$)->v.binary->operation = BOOLEAN_OR;
      left = row_value_constructor_binary_statement($row_value_constructor);
      ($$)->v.binary->operands[0] = left;
      ($$)->v.binary->operands[1] = ($boolean_term);
    }
  | search_condition OR row_value_constructor {
      // This is a special form where the column is assumed to be a boolean
      SqlStatement		*right;

      SQL_STATEMENT($$, binary_STATEMENT);
      MALLOC_STATEMENT($$, binary, SqlBinaryOperation);
      ($$)->v.binary->operation = BOOLEAN_OR;
      right = row_value_constructor_binary_statement($row_value_constructor);
      ($$)->v.binary->operands[0] = $1;
      ($$)->v.binary->operands[1] = right;
    }
  | row_value_constructor OR row_value_constructor {
      // This is a special form where the column is assumed to be a boolean
      SqlStatement		*left, *right;

      SQL_STATEMENT($$, binary_STATEMENT);
      MALLOC_STATEMENT($$, binary, SqlBinaryOperation);
      ($$)->v.binary->operation = BOOLEAN_OR;
      left = row_value_constructor_binary_statement($1);
      right = row_value_constructor_binary_statement($3);
      ($$)->v.binary->operands[0] = left;
      ($$)->v.binary->operands[1] = right;
    }
  ;

boolean_term
  : boolean_factor { $$ = $boolean_factor; }
  | boolean_term AND boolean_factor {
      SQL_STATEMENT($$, binary_STATEMENT);
      MALLOC_STATEMENT($$, binary, SqlBinaryOperation);
      ($$)->v.binary->operation = BOOLEAN_AND;
      ($$)->v.binary->operands[0] = ($1);
      ($$)->v.binary->operands[1] = ($boolean_factor);
    }
  | row_value_constructor AND boolean_factor {
      // This is a special form where the column is assumed to be a boolean
      SqlStatement		*left;

      SQL_STATEMENT($$, binary_STATEMENT);
      MALLOC_STATEMENT($$, binary, SqlBinaryOperation);
      ($$)->v.binary->operation = BOOLEAN_AND;
      left = row_value_constructor_binary_statement($row_value_constructor);
      ($$)->v.binary->operands[0] = left;
      ($$)->v.binary->operands[1] = ($boolean_factor);
    }
  | boolean_term AND row_value_constructor {
      // This is a special form where the column is assumed to be a boolean
      SqlStatement		*right;

      SQL_STATEMENT($$, binary_STATEMENT);
      MALLOC_STATEMENT($$, binary, SqlBinaryOperation);
      ($$)->v.binary->operation = BOOLEAN_AND;
      right = row_value_constructor_binary_statement($row_value_constructor);
      ($$)->v.binary->operands[0] = $1;
      ($$)->v.binary->operands[1] = right;
    }
  | row_value_constructor AND row_value_constructor {
      // This is a special form where the column is assumed to be a boolean
      SqlStatement		*left, *right;

      SQL_STATEMENT($$, binary_STATEMENT);
      MALLOC_STATEMENT($$, binary, SqlBinaryOperation);
      ($$)->v.binary->operation = BOOLEAN_AND;
      left = row_value_constructor_binary_statement($1);
      right = row_value_constructor_binary_statement($3);
      ($$)->v.binary->operands[0] = left;
      ($$)->v.binary->operands[1] = right;
    }
  ;

boolean_factor
  : boolean_test { $$ = $boolean_test; }
  | NOT boolean_test {
      SQL_STATEMENT($$, unary_STATEMENT);
      MALLOC_STATEMENT($$, unary, SqlUnaryOperation);
      ($$)->v.unary->operation = BOOLEAN_NOT;
      ($$)->v.unary->operand = ($boolean_test);
    }
  | NOT row_value_constructor {
      // This is a special form where the column is assumed to be a boolean
      SqlStatement		*right;

      SQL_STATEMENT($$, unary_STATEMENT);
      MALLOC_STATEMENT($$, unary, SqlUnaryOperation);
      ($$)->v.unary->operation = BOOLEAN_NOT;
      right = row_value_constructor_binary_statement($row_value_constructor);
      ($$)->v.unary->operand = right;
    }
  ;

boolean_test
  : boolean_primary boolean_test_tail {
      if($boolean_test_tail != NULL) {
        SQL_STATEMENT($$, binary_STATEMENT);
        MALLOC_STATEMENT($$, binary, SqlBinaryOperation);
        ($$)->v.binary->operation = BOOLEAN_IS;
        ($$)->v.binary->operands[0] = ($boolean_primary);
        ($$)->v.binary->operands[1] = ($boolean_test_tail);
      } else {
        $$ = $boolean_primary;
      }
    }
  ;

boolean_test_tail
  : /* Empty */ { $$ = NULL; }
  | IS boolean_test_tail_tail { WARNING(ERR_FEATURE_NOT_IMPLEMENTED, "boolean_test_tail: IS boolean_test_tail_tail"); YYABORT; }
  ;

boolean_test_tail_tail
  : truth_value { $$ = $boolean_test_tail_tail; }
  | NOT truth_value { WARNING(ERR_FEATURE_NOT_IMPLEMENTED, "boolean_test_tail_tail: NOT truth_value"); YYABORT; }
  ;

truth_value
  : TRUE_TOKEN {
      SQL_STATEMENT($$, value_STATEMENT);
      MALLOC_STATEMENT($$, value, SqlValue);
      ($$)->v.value->type = BOOLEAN_VALUE;
      ($$)->v.value->v.string_literal = "1";
    }
  | FALSE_TOKEN {
      SQL_STATEMENT($$, value_STATEMENT);
      MALLOC_STATEMENT($$, value, SqlValue);
      ($$)->v.value->type = BOOLEAN_VALUE;
      ($$)->v.value->v.string_literal = "0";
    }
  | UNKNOWN { WARNING(ERR_FEATURE_NOT_IMPLEMENTED, "truth_value: UNKNOWN"); YYABORT; }
  ;

boolean_primary
  : predicate { $$ = $predicate; }
  | truth_value { $$ = $truth_value; }
  | LEFT_PAREN search_condition RIGHT_PAREN { $$ = $search_condition; }
  ;

predicate
  : comparison_predicate { $$ = $comparison_predicate; }
  | between_predicate
  | in_predicate { $$ = $in_predicate; }
//  | like_predicate
  | null_predicate { $$ = $null_predicate; }
//  | quantified_comparison_predicate
  | exists_predicate
//  | match_predicate
//  | overlaps_predicate
  ;

comparison_predicate
  : row_value_constructor EQUALS row_value_constructor {
      SQL_STATEMENT($$, binary_STATEMENT);
      MALLOC_STATEMENT($$, binary, SqlBinaryOperation);
      ($$)->v.binary->operation = BOOLEAN_EQUALS;
      ($$)->v.binary->operands[0] = ($1);
      ($$)->v.binary->operands[1] = ($3);
    }
  | row_value_constructor NOT_EQUALS row_value_constructor {
      SQL_STATEMENT($$, binary_STATEMENT);
      MALLOC_STATEMENT($$, binary, SqlBinaryOperation);
      ($$)->v.binary->operation = BOOLEAN_NOT_EQUALS;
      ($$)->v.binary->operands[0] = ($1);
      ($$)->v.binary->operands[1] = ($3);
    }
  | row_value_constructor LESS_THAN row_value_constructor {
      SQL_STATEMENT($$, binary_STATEMENT);
      MALLOC_STATEMENT($$, binary, SqlBinaryOperation);
      ($$)->v.binary->operation = BOOLEAN_LESS_THAN;
      ($$)->v.binary->operands[0] = ($1);
      ($$)->v.binary->operands[1] = ($3);
    }
  | row_value_constructor GREATER_THAN row_value_constructor {
      SQL_STATEMENT($$, binary_STATEMENT);
      MALLOC_STATEMENT($$, binary, SqlBinaryOperation);
      ($$)->v.binary->operation = BOOLEAN_GREATER_THAN;
      ($$)->v.binary->operands[0] = ($1);
      ($$)->v.binary->operands[1] = ($3);
    }
  | row_value_constructor LESS_THAN_OR_EQUALS row_value_constructor {
      SQL_STATEMENT($$, binary_STATEMENT);
      MALLOC_STATEMENT($$, binary, SqlBinaryOperation);
      ($$)->v.binary->operation = BOOLEAN_LESS_THAN_OR_EQUALS;
      ($$)->v.binary->operands[0] = ($1);
      ($$)->v.binary->operands[1] = ($3);
    }
  | row_value_constructor GREATER_THAN_OR_EQUALS row_value_constructor {
      SQL_STATEMENT($$, binary_STATEMENT);
      MALLOC_STATEMENT($$, binary, SqlBinaryOperation);
      ($$)->v.binary->operation = BOOLEAN_GREATER_THAN_OR_EQUALS;
      ($$)->v.binary->operands[0] = ($1);
      ($$)->v.binary->operands[1] = ($3);
    }
  | row_value_constructor TILDE row_value_constructor {
      /* generates a regex type statement
       * operand 1 - always &($$): is the actual SqlStatement that gets passed up
       * operand 2, and 3 - the left and right operands respectively
       * operand 4 - which operator to convert: 0 = regex; 1 = LIKE; 2 = SIMILAR
       * operand 5 - case sensitivity: FALSE = insensitive; TRUE = sensitive
       * operand 6 - not operator: FALSE = no NOT; TRUE = NOT
       */
      regex_specification(&($$), ($1), ($3), 0, TRUE, FALSE);
    }
  | row_value_constructor TILDE ASTERISK row_value_constructor {
      regex_specification(&($$), ($1), ($4), 0, FALSE, FALSE);
    }
  | row_value_constructor EXCLAMATION TILDE row_value_constructor {
      regex_specification(&($$), ($1), ($4), 0, TRUE, TRUE);
    }
  | row_value_constructor EXCLAMATION TILDE ASTERISK row_value_constructor {
      regex_specification(&($$), ($1), ($5), 0, FALSE, TRUE);
    }
  | row_value_constructor like_predicate row_value_constructor {
      regex_specification(&($$), ($1), ($3), 1, TRUE, FALSE);
    }
  | row_value_constructor not_like_predicate row_value_constructor {
      regex_specification(&($$), ($1), ($3), 1, TRUE, TRUE);
    }
  | row_value_constructor insensitive_like_predicate row_value_constructor {
      regex_specification(&($$), ($1), ($3), 1, FALSE, FALSE);
    }
  | row_value_constructor not_insensitive_like_predicate row_value_constructor {
      regex_specification(&($$), ($1), ($3), 1, FALSE, TRUE);
    }
  | row_value_constructor SIMILAR TO row_value_constructor {
      regex_specification(&($$), ($1), ($4), 2, TRUE, FALSE);
    }
  | row_value_constructor NOT SIMILAR TO row_value_constructor {
      regex_specification(&($$), ($1), ($5), 2, TRUE, TRUE);
    }
  ;

like_predicate
  : TILDE TILDE
  | LIKE
  ;

not_like_predicate
  : EXCLAMATION TILDE TILDE
  | NOT LIKE
  ;

insensitive_like_predicate
  : TILDE TILDE ASTERISK
  | ILIKE
  ;

not_insensitive_like_predicate
  : EXCLAMATION TILDE TILDE ASTERISK
  | NOT ILIKE
  ;


between_predicate
  : row_value_constructor BETWEEN value_expression AND value_expression {
      WARNING(ERR_FEATURE_NOT_IMPLEMENTED, "BETWEEN operator (grammar rule : between_predicate)"); YYABORT;
    }
  ;


in_predicate
  : row_value_constructor IN in_predicate_value {
      SQL_STATEMENT($$, binary_STATEMENT);
      MALLOC_STATEMENT($$, binary, SqlBinaryOperation);
      ($$)->v.binary->operation = BOOLEAN_IN;
      ($$)->v.binary->operands[0] = ($row_value_constructor);
      ($$)->v.binary->operands[1] = ($in_predicate_value);
    }
  | row_value_constructor NOT IN in_predicate_value {
      SQL_STATEMENT($$, binary_STATEMENT);
      MALLOC_STATEMENT($$, binary, SqlBinaryOperation);
      ($$)->v.binary->operation = BOOLEAN_NOT_IN;
      ($$)->v.binary->operands[0] = ($row_value_constructor);
      ($$)->v.binary->operands[1] = ($in_predicate_value);
    }
  ;

/// TODO: these require additional structures in octo_types.h
in_predicate_value
  : table_subquery { $$ = $table_subquery; }
  | LEFT_PAREN in_value_list RIGHT_PAREN { $$ = $in_value_list; }
  ;

table_subquery
  : subquery { $$ = $subquery; }
  ;

in_value_list
  : /* Empty */ {
      SQL_STATEMENT($$, column_list_STATEMENT);
      MALLOC_STATEMENT($$, column_list, SqlColumnList);
      SqlColumnList *column_list;
      UNPACK_SQL_STATEMENT(column_list, $$, column_list);
      dqinit(column_list);
    }
  | truth_value in_value_list_tail {
      SQL_STATEMENT($$, column_list_STATEMENT);
      MALLOC_STATEMENT($$, column_list, SqlColumnList);
      SqlColumnList *column_list, *cl_tail;
      UNPACK_SQL_STATEMENT(column_list, $$, column_list);
      column_list->value = $truth_value;
      dqinit(column_list);
      if($in_value_list_tail != NULL) {
        UNPACK_SQL_STATEMENT(cl_tail, $in_value_list_tail, column_list);
        dqappend(column_list, cl_tail);
      }
    }
  | value_expression in_value_list_tail {
      SQL_STATEMENT($$, column_list_STATEMENT);
      MALLOC_STATEMENT($$, column_list, SqlColumnList);
      SqlColumnList *column_list, *cl_tail;
      UNPACK_SQL_STATEMENT(column_list, $$, column_list);
      column_list->value = $value_expression;
      dqinit(column_list);
      if($in_value_list_tail != NULL) {
        UNPACK_SQL_STATEMENT(cl_tail, $in_value_list_tail, column_list);
        dqappend(column_list, cl_tail);
      }
    }
  ;

in_value_list_tail
  : /* Empty */ { $$ = NULL; }
  | COMMA in_value_list { $$ = $in_value_list; }
  ;

null_predicate
  : row_value_constructor IS NULL_TOKEN {
      SQL_STATEMENT($$, binary_STATEMENT);
      MALLOC_STATEMENT($$, binary, SqlBinaryOperation);
      ($$)->v.binary->operation = BOOLEAN_EQUALS;
      ($$)->v.binary->operands[0] = ($row_value_constructor);
      SQL_STATEMENT(($$)->v.binary->operands[1], value_STATEMENT);
      MALLOC_STATEMENT(($$)->v.binary->operands[1], value, SqlValue);
      ($$)->v.binary->operands[1]->v.value->type = NUL_VALUE;
      ($$)->v.binary->operands[1]->v.value->v.string_literal = "";
    }
  | row_value_constructor IS NOT NULL_TOKEN {
      SQL_STATEMENT($$, binary_STATEMENT);
      MALLOC_STATEMENT($$, binary, SqlBinaryOperation);
      ($$)->v.binary->operation = BOOLEAN_NOT_EQUALS;
      ($$)->v.binary->operands[0] = ($row_value_constructor);
      SQL_STATEMENT(($$)->v.binary->operands[1], value_STATEMENT);
      MALLOC_STATEMENT(($$)->v.binary->operands[1], value, SqlValue);
      ($$)->v.binary->operands[1]->v.value->type = NUL_VALUE;
      ($$)->v.binary->operands[1]->v.value->v.string_literal = "";
    }

  ;

exists_predicate
  : EXISTS subquery { WARNING(ERR_FEATURE_NOT_IMPLEMENTED, "EXISTS operator (grammar rule : exists_predicate)"); YYABORT; }
  ;

row_value_constructor
  : LEFT_PAREN row_value_constructor_list RIGHT_PAREN { $$ = $row_value_constructor_list; }
  | row_value_constructor_element { $$ = $row_value_constructor_element; }
  ;

row_value_constructor_subquery
  : query_expression { $$ = $query_expression; }
  ;

row_value_constructor_list
  : row_value_constructor_element row_value_constructor_list_tail { WARNING(ERR_FEATURE_NOT_IMPLEMENTED, "row_value_constructor_list: element/list_tail"); YYABORT; }
  | row_value_constructor_subquery { $$ = $row_value_constructor_subquery; }
  ;

row_value_constructor_list_tail
  : /* Empty */ { $$ = NULL; }
  | COMMA row_value_constructor_list { $$ = $row_value_constructor_list; }
  ;

row_value_constructor_element
  : value_expression { $$ = $value_expression; }
  | default_specification { $$ = $default_specification; }
  ;

/* The runtime system is responsible for ensuring
    types, as we need knowledge of column types
*/
value_expression
  : numeric_value_expression { $$ = $numeric_value_expression; }
  // WARNING: if this is enabled, we have to revisit the boolean logic to seperate
  // terms into UNION ALL terms
//  | boolean_term { $$ = $boolean_term; }
  | null_specification { $$ = $null_specification; }
//  | datetime_value_expression
//  | interval_expression
  ;

null_specification
  : NULL_TOKEN {
      SQL_STATEMENT(($$), value_STATEMENT);
      MALLOC_STATEMENT(($$), value, SqlValue);
      ($$)->v.value->type = NUL_VALUE;
      ($$)->v.value->v.string_literal = "";
    }
  ;

default_specification
  : DEFAULT { WARNING(ERR_FEATURE_NOT_IMPLEMENTED, "default_specification: DEFAULT"); YYABORT; }
  ;

numeric_value_expression
  : term { $$ = $term; }
  | numeric_value_expression PLUS term {
      SQL_STATEMENT($$, binary_STATEMENT);
      MALLOC_STATEMENT($$, binary, SqlBinaryOperation);
      ($$)->v.binary->operation = ADDITION;
      ($$)->v.binary->operands[0] = ($1);
      ($$)->v.binary->operands[1] = ($term);
    }
  | numeric_value_expression MINUS term {
      SQL_STATEMENT($$, binary_STATEMENT);
      MALLOC_STATEMENT($$, binary, SqlBinaryOperation);
      ($$)->v.binary->operation = SUBTRACTION;
      ($$)->v.binary->operands[0] = ($1);
      ($$)->v.binary->operands[1] = ($term);
    }
  | numeric_value_expression OVER partition_by_clause {
      WARNING(ERR_FEATURE_NOT_IMPLEMENTED, "OVER not implemented, just returning columns");
      $$ = $1;
    }
  ;

term
  : factor { $$ = $factor; }
  | term ASTERISK factor {
      SQL_STATEMENT($$, binary_STATEMENT);
      MALLOC_STATEMENT($$, binary, SqlBinaryOperation);
      ($$)->v.binary->operation = MULTIPLICATION;
      ($$)->v.binary->operands[0] = ($1);
      ($$)->v.binary->operands[1] = ($factor);
    }
  | term SOLIDUS factor {
      SQL_STATEMENT($$, binary_STATEMENT);
      MALLOC_STATEMENT($$, binary, SqlBinaryOperation);
      ($$)->v.binary->operation = DIVISION;
      ($$)->v.binary->operands[0] = ($1);
      ($$)->v.binary->operands[1] = ($factor);
    }
  | term PERCENT factor {
      SQL_STATEMENT($$, binary_STATEMENT);
      MALLOC_STATEMENT($$, binary, SqlBinaryOperation);
      ($$)->v.binary->operation = MODULO;
      ($$)->v.binary->operands[0] = ($1);
      ($$)->v.binary->operands[1] = ($factor);
    }
  | term concatenation_operator factor {
      SQL_STATEMENT($$, binary_STATEMENT);
      MALLOC_STATEMENT($$, binary, SqlBinaryOperation);
      ($$)->v.binary->operation = CONCAT;
      ($$)->v.binary->operands[0] = ($1);
      ($$)->v.binary->operands[1] = ($factor);
    }
  ;

concatenation_operator
  : PIPE PIPE { /* Left blank on purpose */ }
  ;

/// TODO: collate_clause is thoroughly ignored below
factor
  : PLUS numeric_primary factor_tail {
      SQL_STATEMENT($$, unary_STATEMENT);
      MALLOC_STATEMENT($$, unary, SqlUnaryOperation);
      ($$)->v.unary->operation = FORCE_NUM;
      ($$)->v.unary->operand = ($numeric_primary);
    }
  | MINUS numeric_primary factor_tail {
      SQL_STATEMENT($$, unary_STATEMENT);
      MALLOC_STATEMENT($$, unary, SqlUnaryOperation);
      ($$)->v.unary->operation = NEGATIVE;
      ($$)->v.unary->operand = ($numeric_primary);
    }
  | numeric_primary factor_tail { $$ = $numeric_primary; }
  ;

factor_tail
  : /* Empty */ { $$ = NULL; }
  | collate_clause { $$ = $collate_clause; }
  ;

collate_clause
  : COLLATE collation_name { WARNING(ERR_FEATURE_NOT_IMPLEMENTED, "COLLATE clause"); $$ = $collation_name; }
  ;

collation_name
  : qualified_name { $$ = $qualified_name; }
  ;

numeric_primary
  : value_expression_primary optional_subscript optional_cast_specification {
      $$ = $value_expression_primary;
      if($optional_cast_specification != NULL) {
          // For now, we support a subset of types. More shall be added as needed
          SqlValue *value;
          UNPACK_SQL_STATEMENT(value, $optional_cast_specification, value);
          char *c = value->v.string_literal;
          while(*c != '\0') {
              *c = toupper(*c);
              c++;
          }
          c = value->v.string_literal;
          if(strcmp(c, "TEXT") == 0) {
              SQL_STATEMENT($$, value_STATEMENT);
              MALLOC_STATEMENT($$, value, SqlValue);
              UNPACK_SQL_STATEMENT(value, $$, value);
              value->type = COERCE_TYPE;
              value->coerced_type = STRING_LITERAL;
              value->v.coerce_target = $value_expression_primary;
          } else if(strcmp(c, "NUMERIC") == 0) {
              SQL_STATEMENT($$, value_STATEMENT);
              MALLOC_STATEMENT($$, value, SqlValue);
              UNPACK_SQL_STATEMENT(value, $$, value);
              value->type = COERCE_TYPE;
              value->coerced_type = NUMBER_LITERAL;
              value->v.coerce_target = $value_expression_primary;
          } else if(strcmp(c, "INTEGER") == 0) {
              SQL_STATEMENT($$, value_STATEMENT);
              MALLOC_STATEMENT($$, value, SqlValue);
              UNPACK_SQL_STATEMENT(value, $$, value);
              value->type = COERCE_TYPE;
              value->coerced_type = INTEGER_LITERAL;
              value->v.coerce_target = $value_expression_primary;
          } else {
              WARNING(ERR_FEATURE_NOT_IMPLEMENTED, "coerce_type %s", c); YYABORT;
          }
      }
    }
//  | numeric_value_function
  ;

/* There is a reduce/reduce conflict here caused by
 *  not knowing if the columns in question are numeric
 *  or strings; the expansion ends up being pretty similar
 */
value_expression_primary
  : literal_value { $$ = $literal_value; }
  | column_reference { $$ = $column_reference; }
  | set_function_specification { $$ = $set_function_specification; }
  | scalar_subquery { $$ = $scalar_subquery; }
  | case_expression { $$ = $case_expression; }
  | LEFT_PAREN value_expression RIGHT_PAREN { $$ = $value_expression; }
//  | cast_specification
  ;

optional_cast_specification
  : /* Empty */ { $$ = NULL; }
  | COLON COLON identifier {
      $$ = $identifier;
    }
  | COLON COLON NUMERIC {
      SqlValue *value;
      SQL_STATEMENT($$, value_STATEMENT);
      MALLOC_STATEMENT($$, value, SqlValue);
      UNPACK_SQL_STATEMENT(value, $$, value);
      value->type = STRING_LITERAL;
      value->v.string_literal = octo_cmalloc(memory_chunks, strlen("NUMERIC"));
      strcpy(value->v.string_literal, "NUMERIC");
    }
  | COLON COLON INTEGER {
      SqlValue *value;
      SQL_STATEMENT($$, value_STATEMENT);
      MALLOC_STATEMENT($$, value, SqlValue);
      UNPACK_SQL_STATEMENT(value, $$, value);
      value->type = STRING_LITERAL;
      value->v.string_literal = octo_cmalloc(memory_chunks, strlen("INTEGER"));
      strcpy(value->v.string_literal, "INTEGER");
    }
  ;

case_expression
  : case_specification { $$ = $case_specification; }
//  | case_abbreviation
  ;

case_specification
  : simple_case { $$ = $simple_case; }
//  | searched_case
  ;

simple_case
  : CASE value_expression simple_when_clause optional_else_clause END {
      SQL_STATEMENT($$, cas_STATEMENT);
      MALLOC_STATEMENT($$, cas, SqlCaseStatement);
      SqlCaseStatement *cas;
      UNPACK_SQL_STATEMENT(cas, $$, cas);
      cas->value = $value_expression;
      cas->branches = $simple_when_clause;
      cas->optional_else = $optional_else_clause;
    }
  | CASE simple_when_clause optional_else_clause END {
      SQL_STATEMENT($$, cas_STATEMENT);
      MALLOC_STATEMENT($$, cas, SqlCaseStatement);
      SqlCaseStatement *cas;
      UNPACK_SQL_STATEMENT(cas, $$, cas);
      cas->value = NULL;
      cas->branches = $simple_when_clause;
      cas->optional_else = $optional_else_clause;
    }
  | CASE search_condition simple_when_clause optional_else_clause END {
      SQL_STATEMENT($$, cas_STATEMENT);
      MALLOC_STATEMENT($$, cas, SqlCaseStatement);
      SqlCaseStatement *cas;
      UNPACK_SQL_STATEMENT(cas, $$, cas);
      cas->value = $search_condition;
      cas->branches = $simple_when_clause;
      cas->optional_else = $optional_else_clause;
    }
  ;

simple_when_clause
  : WHEN value_expression THEN result simple_when_clause_tail {
      SQL_STATEMENT($$, cas_branch_STATEMENT);
      MALLOC_STATEMENT($$, cas_branch, SqlCaseBranchStatement);
      SqlCaseBranchStatement *cas_branch, *tail_cas_branch;
      UNPACK_SQL_STATEMENT(cas_branch, $$, cas_branch);
      cas_branch->condition = $value_expression;
      cas_branch->value = $result;
      dqinit(cas_branch);
      if($simple_when_clause_tail != NULL) {
        UNPACK_SQL_STATEMENT(tail_cas_branch, $simple_when_clause_tail, cas_branch);
        dqappend(cas_branch, tail_cas_branch);
      }
    }
  | WHEN search_condition THEN result simple_when_clause_tail {
      SQL_STATEMENT($$, cas_branch_STATEMENT);
      MALLOC_STATEMENT($$, cas_branch, SqlCaseBranchStatement);
      SqlCaseBranchStatement *cas_branch, *tail_cas_branch;
      UNPACK_SQL_STATEMENT(cas_branch, $$, cas_branch);
      cas_branch->condition = $search_condition;
      cas_branch->value = $result;
      dqinit(cas_branch);
      if($simple_when_clause_tail != NULL) {
        UNPACK_SQL_STATEMENT(tail_cas_branch, $simple_when_clause_tail, cas_branch);
        dqappend(cas_branch, tail_cas_branch);
      }
    }
  ;

simple_when_clause_tail
  : /* None */ { $$ = NULL; }
  | simple_when_clause { $$ = $simple_when_clause; }
  ;

optional_else_clause
  : /* Empty */ { $$ = NULL; }
  | ELSE result { $$ = $result; }
  ;

result
  : value_expression { $$ = $value_expression; }
  ;


set_function_specification
  : COUNT LEFT_PAREN ASTERISK RIGHT_PAREN {
      WARNING(ERR_FEATURE_NOT_IMPLEMENTED, "set_function_specification: COUNT LEFT_PAREN ASTERISK RIGHT_PAREN");
      SQL_STATEMENT($$, value_STATEMENT);
      MALLOC_STATEMENT($$, value, SqlValue);
      $$->v.value->type = UNKNOWN_SqlValueType;
      $$->v.value->v.string_literal = "0";
    }
  | COUNT LEFT_PAREN set_quantifier value_expression RIGHT_PAREN {
      WARNING(ERR_FEATURE_NOT_IMPLEMENTED, "set_function_specification: COUNT LEFT_PAREN set_quantifier value_expression RIGHT_PAREN");
      SQL_STATEMENT($$, value_STATEMENT);
      MALLOC_STATEMENT($$, value, SqlValue);
      $$->v.value->type = UNKNOWN_SqlValueType;
      $$->v.value->v.string_literal = "0";
    }
  | general_set_function { $$ = $general_set_function; }
  | generic_function_call { $$ = $generic_function_call; }
  ;

general_set_function
  : set_function_type LEFT_PAREN set_quantifier value_expression RIGHT_PAREN { WARNING(ERR_FEATURE_NOT_IMPLEMENTED, "general_set_function: set_function_type LEFT_PAREN set_quantifier value_expression RIGHT_PAREN"); YYABORT; }
  ;

set_function_type
  : AVG { WARNING(ERR_FEATURE_NOT_IMPLEMENTED, "set_function_type: AVG"); YYABORT; }
  | MAX { WARNING(ERR_FEATURE_NOT_IMPLEMENTED, "set_function_type: MAX"); YYABORT; }
  | MIN { WARNING(ERR_FEATURE_NOT_IMPLEMENTED, "set_function_type: MIN"); YYABORT; }
  | SUM { WARNING(ERR_FEATURE_NOT_IMPLEMENTED, "set_function_type: SUM"); YYABORT; }
  ;

generic_function_call
  : column_name LEFT_PAREN in_value_list RIGHT_PAREN {
      SQL_STATEMENT($$, value_STATEMENT);
      MALLOC_STATEMENT($$, value, SqlValue);
      SqlStatement *fc_statement;
      SqlFunctionCall *fc;
      SqlValue *value;
      UNPACK_SQL_STATEMENT(value, $$, value);

      value->type = CALCULATED_VALUE;
      SQL_STATEMENT(fc_statement, function_call_STATEMENT);
      MALLOC_STATEMENT(fc_statement, function_call, SqlFunctionCall);
      UNPACK_SQL_STATEMENT(fc, fc_statement, function_call);
      fc->function_name = $column_name;
      fc->parameters = $in_value_list;
      value->v.calculated = fc_statement;

      // Change the value to be a string literal rather than column reference
      UNPACK_SQL_STATEMENT(value, $column_name, value);
      value->type = FUNCTION_NAME;
    }
  ;

// We don't abort below because we want this to pass for fetching schema information
optional_subscript
  : /* Empty */ { $$ = NULL; }
  | LEFT_BRACKET literal_value RIGHT_BRACKET { WARNING(ERR_FEATURE_NOT_IMPLEMENTED, "arrays"); }
  ;

column_reference
  : qualifier PERIOD column_name {
      SqlValue *qual, *col_name;
      char *new_string, *c;
      int len_qual, len_col_name;
      UNPACK_SQL_STATEMENT(qual, $qualifier, value);
      UNPACK_SQL_STATEMENT(col_name, $column_name, value);
      len_qual = strlen(qual->v.string_literal);
      len_col_name = strlen(qual->v.string_literal);
      // +1 for null, +1 for '.'
      new_string = octo_cmalloc(memory_chunks, len_qual + len_col_name + 2);
      c = new_string;
      memcpy(c, qual->v.string_literal, len_qual);
      c += len_qual;
      *c++ = '.';
      memcpy(c, col_name->v.string_literal, len_col_name);
      c += len_col_name;
      *c++ = '\0';
      qual->v.string_literal = new_string;
    }
  | column_name { $$ = $column_name; }
  ;

qualifier
  : column_name { $$ = $column_name; }
  ;

scalar_subquery
  : subquery { $$ = $subquery; }
  ;

subquery
  : LEFT_PAREN query_expression RIGHT_PAREN { $$ = $query_expression; }
  ;

query_expression
  : non_join_query_expression { $$ = $non_join_query_expression; }
  | joined_table { $$ = $joined_table; }
  ;

non_join_query_expression
  : non_join_query_term { $$ = $non_join_query_term; }
  | query_expression UNION query_term non_join_query_expression_tail_tail {
        $$ = set_operation(SET_UNION, $query_expression, $query_term);
    }
  | query_expression UNION ALL query_term non_join_query_expression_tail_tail {
        $$ = set_operation(SET_UNION_ALL, $query_expression, $query_term);
    }
  | query_expression EXCEPT query_term non_join_query_expression_tail_tail {
        $$ = set_operation(SET_EXCEPT, $query_expression, $query_term);
    }
  | query_expression EXCEPT ALL query_term non_join_query_expression_tail_tail {
        $$ = set_operation(SET_EXCEPT_ALL, $query_expression, $query_term);
    }
  ;

non_join_query_expression_tail_tail
  : /* Empty */ { $$ = NULL; }
  | CORRESPONDING non_join_query_expression_tail_tail_tail { WARNING(ERR_FEATURE_NOT_IMPLEMENTED, "non_join_query_expression_tail_tail : CORRESPONDING non_join_query_expression_tail_tail_tail: BY LEFT_PAREN corresponding_column_list RIGHT_PAREN"); YYABORT; }
  ;

non_join_query_expression_tail_tail_tail
  : /* Empty */ { $$ = NULL; }
  | BY LEFT_PAREN corresponding_column_list RIGHT_PAREN { WARNING(ERR_FEATURE_NOT_IMPLEMENTED, "non_join_query_expression_tail_tail_tail: BY LEFT_PAREN corresponding_column_list RIGHT_PAREN"); YYABORT; }
  ;

corresponding_column_list
  : column_name_list { $$ = $column_name_list; }
  ;

column_name_list
  : column_name column_name_list_tail { WARNING(ERR_FEATURE_NOT_IMPLEMENTED, "column_name_list: column_name column_name_list_tail"); YYABORT; }
  ;

column_name_list_tail
  : /* Empty */ { $$ = NULL; }
  | COMMA column_name_list { $$ = $column_name_list; }
  ;

query_term
  : non_join_query_term { $$ = $non_join_query_term; }
  | joined_table { $$ = $joined_table; }
  ;

non_join_query_term
  : non_join_query_primary {$$ = $non_join_query_primary; }
  | query_term INTERSECT corresponding_spec query_primary {
        $$ = set_operation(SET_INTERSECT, $query_term, $query_primary);
    }
  | query_term INTERSECT ALL corresponding_spec query_primary {
        $$ = set_operation(SET_INTERSECT_ALL, $query_term, $query_primary);
    }
  ;

corresponding_spec
  : CORRESPONDING corresponding_spec_tail { WARNING(ERR_FEATURE_NOT_IMPLEMENTED, "corresponding_spec: CORRESPONDING corresponding_spec_tail"); YYABORT; }
  | /* Empty */
  ;

corresponding_spec_tail
  : BY LEFT_PAREN corresponding_column_list RIGHT_PAREN { WARNING(ERR_FEATURE_NOT_IMPLEMENTED, "corresponding_spec_tail: BY LEFT_PAREN corresponding_column_list RIGHT_PAREN"); YYABORT; }
  ;

non_join_query_primary
  : simple_table {$$ = $simple_table; }
  | LEFT_PAREN non_join_query_expression RIGHT_PAREN { $$ = $non_join_query_expression; }
  ;

simple_table
  : table_value_constructor { WARNING(ERR_FEATURE_NOT_IMPLEMENTED, "table_value_constructor"); YYABORT; }
  | explicit_table { WARNING(ERR_FEATURE_NOT_IMPLEMENTED, "explicit_table"); YYABORT; }
  | sql_select_statement { $$ = $sql_select_statement; }
  ;

table_value_constructor
  : VALUES table_value_constructor_list { $$ = $table_value_constructor_list; }
  ;

table_value_constructor_list
  : row_value_constructor table_value_constructor_list_tail { WARNING(ERR_FEATURE_NOT_IMPLEMENTED, "column_name_list: column_name column_name_list_tail"); YYABORT; }
  ;

table_value_constructor_list_tail
  : /* Empty */ { $$ = NULL; }
  | COMMA table_value_constructor_list { $$ = $table_value_constructor_list; }
  ;

explicit_table
  : TABLE column_name { WARNING(ERR_FEATURE_NOT_IMPLEMENTED, "corresponding_spec_tail: BY LEFT_PAREN corresponding_column_list RIGHT_PAREN"); YYABORT; }
  ;

query_primary
  : non_join_query_primary { $$ = $non_join_query_primary;}
  | joined_table { $$ = $joined_table;}
  ;

sql_schema_statement
  : sql_schema_definition_statement { $$ = $sql_schema_definition_statement; }
  | sql_schema_manipulation_statement { $$ = $sql_schema_manipulation_statement;}
  ;

/// TODO: not complete
sql_schema_manipulation_statement
  : drop_table_statement { $$ = $drop_table_statement; }
  ;

sql_schema_definition_statement
  : table_definition { $$ = $table_definition; }
  ;

/// TODO: not complete
table_definition
  : CREATE TABLE column_name LEFT_PAREN table_element_list RIGHT_PAREN table_definition_tail {
        SQL_STATEMENT($$, table_STATEMENT);
        MALLOC_STATEMENT($$, table, SqlTable);
        memset(($$)->v.table, 0, sizeof(SqlTable));
        assert($column_name->type == value_STATEMENT
          && $column_name->v.value->type == COLUMN_REFERENCE);
        ($$)->v.table->tableName = $column_name;
        ($$)->v.table->columns = $table_element_list;
        assign_table_to_columns($$);
        if(create_table_defaults($$, $table_definition_tail)) {
          YYABORT;
        }
      }
  ;

table_definition_tail
  : /* Empty */ {
      SQL_STATEMENT($$, keyword_STATEMENT);
      MALLOC_STATEMENT($$, keyword, SqlOptionalKeyword);
      ($$)->v.keyword->keyword = NO_KEYWORD;
      ($$)->v.keyword->v = NULL;
      dqinit(($$)->v.keyword);
    }
  | optional_keyword { $$ = $optional_keyword; }
  ;

optional_keyword
  : optional_keyword_element optional_keyword_tail {
      $$ = $optional_keyword_element;
      SqlOptionalKeyword *keyword;
      UNPACK_SQL_STATEMENT(keyword, $optional_keyword_tail, keyword);
      dqappend(keyword, ($$)->v.keyword);
    }
  ;

optional_keyword_element
  : GLOBAL literal_value {
      SQL_STATEMENT($$, keyword_STATEMENT);
      MALLOC_STATEMENT($$, keyword, SqlOptionalKeyword);
      ($$)->v.keyword->keyword = OPTIONAL_SOURCE;
      ($$)->v.keyword->v = $literal_value;
      dqinit(($$)->v.keyword);
    }
  | DELIM literal_value {
       SQL_STATEMENT($$, keyword_STATEMENT);
        MALLOC_STATEMENT($$, keyword, SqlOptionalKeyword);
       ($$)->v.keyword->keyword = OPTIONAL_DELIM;
       ($$)->v.keyword->v = $literal_value;
       dqinit(($$)->v.keyword);
     }
  ;

optional_keyword_tail
  : /* Empty */ {
      SQL_STATEMENT($$, keyword_STATEMENT);
      MALLOC_STATEMENT($$, keyword, SqlOptionalKeyword);
      ($$)->v.keyword->keyword = NO_KEYWORD;
      ($$)->v.keyword->v = NULL;
      dqinit(($$)->v.keyword);
    }
  | optional_keyword { assert($optional_keyword->type == keyword_STATEMENT); $$ = $optional_keyword; }
  ;

table_element_list
  :  table_element table_element_list_tail  {
      $$ = $table_element;
      assert($$->type == column_STATEMENT);
      if($table_element_list_tail)
      {
        assert($table_element_list_tail->type == column_STATEMENT);
        dqappend($table_element_list_tail->v.column, ($$)->v.column);
      }
    }
  ;

table_element_list_tail
  : /* Empty */ { $$ = 0; }
  | COMMA table_element_list { $$ = $table_element_list; }
  ;

table_element
  : column_definition { $$ = $column_definition; }
//  | table_constraint_definition
  ;

/// TODO: not complete
column_definition
  : column_name data_type column_definition_tail {
      SQL_STATEMENT($$, column_STATEMENT);
      MALLOC_STATEMENT($$, column, SqlColumn);
      dqinit(($$)->v.column);
      ($$)->v.column->columnName = $column_name;
      assert($data_type->type == data_type_STATEMENT);
      ($$)->v.column->type = $data_type->v.data_type;
      ($$)->v.column->keywords = $column_definition_tail;
    }
//  | more stuff
  ;

column_name
  : identifier { $$ = $identifier; }
  | LITERAL PERIOD LITERAL {
      SQL_STATEMENT($$, value_STATEMENT);
      MALLOC_STATEMENT($$, value, SqlValue);
      SqlValue *value;
      UNPACK_SQL_STATEMENT(value, $$, value);
      SqlValue *table_name, *column_name;
      UNPACK_SQL_STATEMENT(table_name, $1, value);
      UNPACK_SQL_STATEMENT(column_name, $3, value);
      int table_name_len = strlen(table_name->v.string_literal);
      int column_name_len = strlen(column_name->v.string_literal);
      // table + column + period + null
      int len = table_name_len + column_name_len + 2;
      value->type = COLUMN_REFERENCE;
      value->v.string_literal = octo_cmalloc(memory_chunks, len);
      char *c = value->v.string_literal;
      char *d = table_name->v.string_literal;
      // Convert to caps as we copy
      while(*d != '\0') {
        *c++ = toupper(*d++);
      }
      *c = '.';
      c++;
      d = column_name->v.string_literal;
      while(*d != '\0') {
        *c++ = toupper(*d++);
      }
      *c = '\0';
    }
  ;

column_definition_tail
  : /* Empty */ {
       SQL_STATEMENT($$, keyword_STATEMENT);
       MALLOC_STATEMENT($$, keyword, SqlOptionalKeyword);
       dqinit(($$)->v.keyword);
    }
  | EXTRACT literal_value column_definition_tail {
       SQL_STATEMENT($$, keyword_STATEMENT);
       MALLOC_STATEMENT($$, keyword, SqlOptionalKeyword);
       ($$)->v.keyword->keyword = OPTIONAL_EXTRACT;
       ($$)->v.keyword->v = $literal_value;
       dqinit(($$)->v.keyword);

       SqlOptionalKeyword *keyword;
       UNPACK_SQL_STATEMENT(keyword, $3, keyword);
       dqappend(keyword, ($$)->v.keyword);
    }
  | PIECE literal_value column_definition_tail {
       SqlOptionalKeyword *keyword;

       SQL_STATEMENT($$, keyword_STATEMENT);
       MALLOC_STATEMENT($$, keyword, SqlOptionalKeyword);
       keyword = $$->v.keyword;
       keyword->keyword = OPTIONAL_PIECE;
       keyword->v = $literal_value;
       dqinit(($$)->v.keyword);

       UNPACK_SQL_STATEMENT(keyword, $3, keyword);
       dqappend(keyword, ($$)->v.keyword);
    }
  | DELIM literal_value column_definition_tail {
       SQL_STATEMENT($$, keyword_STATEMENT);
       MALLOC_STATEMENT($$, keyword, SqlOptionalKeyword);
       ($$)->v.keyword->keyword = OPTIONAL_DELIM;
       ($$)->v.keyword->v = $literal_value;
       dqinit(($$)->v.keyword);

       SqlOptionalKeyword *keyword;
       UNPACK_SQL_STATEMENT(keyword, $3, keyword);
       dqappend(keyword, ($$)->v.keyword);
     }
  | GLOBAL literal_value column_definition_tail {
       SQL_STATEMENT($$, keyword_STATEMENT);
       MALLOC_STATEMENT($$, keyword, SqlOptionalKeyword);
       ($$)->v.keyword->keyword = OPTIONAL_SOURCE;
       ($$)->v.keyword->v = $literal_value;
       dqinit(($$)->v.keyword);

       SqlOptionalKeyword *keyword;
       UNPACK_SQL_STATEMENT(keyword, $3, keyword);
       dqappend(keyword, ($$)->v.keyword);
    }
  | KEY NUM literal_value column_definition_tail {
       SQL_STATEMENT($$, keyword_STATEMENT);
       MALLOC_STATEMENT($$, keyword, SqlOptionalKeyword);
       ($$)->v.keyword->keyword = OPTIONAL_KEY_NUM;
       ($$)->v.keyword->v = $literal_value;
       dqinit(($$)->v.keyword);

       SqlOptionalKeyword *keyword;
       UNPACK_SQL_STATEMENT(keyword, $4, keyword);
       dqappend(keyword, ($$)->v.keyword);
    }
  | ADVANCE literal_value column_definition_tail {
       SQL_STATEMENT($$, keyword_STATEMENT);
       MALLOC_STATEMENT($$, keyword, SqlOptionalKeyword);
       ($$)->v.keyword->keyword = OPTIONAL_ADVANCE;
       ($$)->v.keyword->v = $literal_value;
       dqinit(($$)->v.keyword);

       SqlOptionalKeyword *keyword;
       UNPACK_SQL_STATEMENT(keyword, $3, keyword);
       dqappend(keyword, ($$)->v.keyword);
    }
  | START literal_value column_definition_tail {
       SQL_STATEMENT($$, keyword_STATEMENT);
       MALLOC_STATEMENT($$, keyword, SqlOptionalKeyword);
       ($$)->v.keyword->keyword = OPTIONAL_START;
       ($$)->v.keyword->v = $literal_value;
       dqinit(($$)->v.keyword);

       SqlOptionalKeyword *keyword;
       UNPACK_SQL_STATEMENT(keyword, $3, keyword);
       dqappend(keyword, ($$)->v.keyword);
    }
  | END literal_value column_definition_tail {
       SQL_STATEMENT($$, keyword_STATEMENT);
       MALLOC_STATEMENT($$, keyword, SqlOptionalKeyword);
       ($$)->v.keyword->keyword = OPTIONAL_END;
       ($$)->v.keyword->v = $literal_value;
       dqinit(($$)->v.keyword);

       SqlOptionalKeyword *keyword;
       UNPACK_SQL_STATEMENT(keyword, $3, keyword);
       dqappend(keyword, ($$)->v.keyword);
    }
  | column_constraint_definition column_definition_tail {
       $$ = $column_constraint_definition;
       SqlOptionalKeyword *keyword;
       UNPACK_SQL_STATEMENT(keyword, $2, keyword);
       dqappend(keyword, ($$)->v.keyword);
    }
  ;

column_constraint_definition
  : constraint_name_definition column_constraint constraint_attributes {
      ($$) = $column_constraint;
    }
  ;

/// TODO: not complete
constraint_name_definition
  : /* Empty */ { $$ = NULL; }
  ;

/// TODO: not complete
column_constraint
  : NOT NULL_TOKEN {
      SQL_STATEMENT($$, keyword_STATEMENT);
      MALLOC_STATEMENT($$, keyword, SqlOptionalKeyword);
      ($$)->v.keyword->keyword = NOT_NULL;
      dqinit(($$)->v.keyword);
    }
  | unique_specifications { $$ = $unique_specifications; }
//  | reference_specifications
//  | check_constraint_definition
  ;

unique_specifications
  : UNIQUE {
      SQL_STATEMENT($$, keyword_STATEMENT);
      MALLOC_STATEMENT($$, keyword, SqlOptionalKeyword);
      ($$)->v.keyword->keyword = UNIQUE_CONSTRAINT;
      dqinit(($$)->v.keyword);
    }
  | PRIMARY KEY {
      SQL_STATEMENT($$, keyword_STATEMENT);
      MALLOC_STATEMENT($$, keyword, SqlOptionalKeyword);
      ($$)->v.keyword->keyword = PRIMARY_KEY;
      dqinit(($$)->v.keyword);
    }
  ;

/// TODO: not complete
constraint_attributes
  : /* Empty */
  ;

qualified_name
  : qualified_identifier { $$ = $qualified_identifier; }
//  | schema_name period qualified_identifier
  ;

qualified_identifier
  : identifier { $$ = $identifier; }
  ;

identifier
  : actual_identifier { $$ = $actual_identifier; }
//  | introducer character_set_specification actual_identifier
  ;

actual_identifier
  : regular_identifier { $$ = $regular_identifier; }
//  | delimited_identifier
  ;

regular_identifier
  : identifier_body { $$ = $identifier_body; }
  ;

identifier_body
  : IDENTIFIER_START { $$ = $IDENTIFIER_START; ($$)->loc = yyloc; }
  | EXTRINSIC_FUNCTION {
       if (config->is_rocto) {
          ERROR(ERR_ROCTO_M_CALL, NULL);
          /* we issue a parser error here so that parsing for this token finish
           * rather than using YYABORT to exit prematurely
           */
          YYERROR;
       } else {
          $$ = $EXTRINSIC_FUNCTION;
          ($$)->loc = yyloc;
       }
    }
//  | identifier_start underscore
//  | identifier_start identifier_part
  ;

data_type
  : character_string_type {
      SQL_STATEMENT($$, data_type_STATEMENT);
      ($$)->v.data_type = CHARACTER_STRING_TYPE;
    }
//  | character_string_type CHARACTER SET character_set_specification
//  | national_character_string_type
//  | bit_string_type
  | numeric_type {
      SQL_STATEMENT($$, data_type_STATEMENT);
      ($$)->v.data_type = NUMERIC_TYPE;
    }
  | integer_type {
      SQL_STATEMENT($$, data_type_STATEMENT);
      ($$)->v.data_type = INTEGER_TYPE;
    }
//  | datetime_type
//  | interval_type
  ;

// These should be implemented as constraints
character_string_type
  : CHARACTER character_string_type_char_tail { $$ = $character_string_type_char_tail; }
  | CHAR character_string_type_char_tail { $$ = $character_string_type_char_tail; }
  | CHARACTER VARYING character_string_type_char_tail { $$ = $character_string_type_char_tail; }
  | CHAR VARYING character_string_type_char_tail { $$ = $character_string_type_char_tail; }
  | VARCHAR character_string_type_char_tail { $$ = $character_string_type_char_tail; }
  ;

character_string_type_char_tail
  : /* Empty */ { $$ = NULL; }
  | LEFT_PAREN length RIGHT_PAREN { $$ = $length; }
  ;

length
  : literal_value { $$ = $literal_value; }
  ;

numeric_type
  : exact_numeric_type { $$ = $exact_numeric_type; }
//  | approximate_numeric_type
  ;

exact_numeric_type
  : NUMERIC exact_numeric_type_tail { $$ = $exact_numeric_type_tail; }
  | DECIMAL exact_numeric_type_tail { $$ = $exact_numeric_type_tail; }
  | DEC exact_numeric_type_tail { $$ = $exact_numeric_type_tail; }

integer_type
  : INTEGER { $$ = NULL; }
  | INT { $$ = NULL; }
  | SMALLINT { $$ = NULL; }
  ;


/// TODO: we should have a triple for this type of numeric which includes scale
exact_numeric_type_tail
  : /* Empty */ { $$ = NULL; }
  | LEFT_PAREN precision exact_numeric_type_tail_tail RIGHT_PAREN {
      $$ = $precision;
    }
  ;

exact_numeric_type_tail_tail
  : /* Empty */ { $$ = NULL; }
  | COMMA scale { $$ = $scale; }
  ;

precision
  : literal_value { $$ = $literal_value; }
  ;

scale
  : literal_value { $$ = $literal_value; }
  ;

literal_value
  : LITERAL { $$ = $LITERAL; ($$)->loc = yyloc; }

partition_by_clause
  : LEFT_PAREN PARTITION BY column_reference optional_order_by RIGHT_PAREN {
      $$ = NULL;
    }
  ;

optional_order_by
  : /* Empty */
  | ORDER BY sort_specification_list
  ;

%%

/****************************************************************
 *								*
 * Copyright (c) 2019-2020 YottaDB LLC and/or its subsidiaries.	*
 * All rights reserved.						*
 *								*
 *	This source code contains the intellectual property	*
 *	of its copyright holder(s), and is made available	*
 *	under a license.  If you do not know the terms of	*
 *	the license, please stop and do not read further.	*
 *								*
 ****************************************************************/

%require "3.0"
%debug

%code requires {
#ifndef YY_TYPEDEF_YY_SCANNER_T
#define YY_TYPEDEF_YY_SCANNER_T
typedef void* yyscan_t;
#endif
}

%{
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <string.h>
#include <ctype.h>
#include <errno.h>

#include "octo.h"
#include "octo_types.h"
#include "parser.h"
#include "helpers.h"

#define YYDEBUG 1
#define YYSTYPE SqlStatement *
/* YYMAXDEPTH defines the number of symbols the parser can store in its stack
 * if this value is excceded then a "memory exhausted" error is issued
 * the default is 10000
 * behavoir is undefined if this relation is false: YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES(YYMAXDEPTH)
 * where YYSTACK_ALLOC_MAXIUM is 2^32-1 on 32 bit machines and 2^64-1 on 64bit machines
 * and YYSTACK_BYTES is a macro generated by bison found in parser.c
 * it is currently (YYMAXDEPTH * 26 + 30)
 */
#define YYMAXDEPTH 10000000

#define CONDITIONAL_LIST_STMT(ret, unpacked, kind, SqlType) { \
      SqlStatement    *stmt;                        \
      SqlValue        *value;                       \
                                                    \
      SQL_STATEMENT(ret, value_STATEMENT);          \
      MALLOC_STATEMENT(ret, value, SqlValue);       \
      UNPACK_SQL_STATEMENT(value, ret, value);      \
                                                    \
      value->type = CALCULATED_VALUE;               \
      SQL_STATEMENT(stmt, kind##_STATEMENT);        \
      MALLOC_STATEMENT(stmt, kind, SqlType);        \
      UNPACK_SQL_STATEMENT(unpacked, stmt, kind);   \
      value->v.calculated = stmt;                   \
}

extern int yylex(YYSTYPE * yylval_param, YYLTYPE *llocp, yyscan_t yyscanner);
extern int yyparse(yyscan_t scan, SqlStatement **out, int *plan_id, ParseContext *parse_context);
extern void yyerror(YYLTYPE *llocp, yyscan_t scan, SqlStatement **out, int *plan_id, ParseContext *parse_context, char const *s);

%}

%define parse.error verbose
%define api.pure full
%locations
%lex-param   { yyscan_t scanner }
%parse-param { yyscan_t scanner } { SqlStatement **out } { int *plan_id } { ParseContext *parse_context }

%token ADVANCE
%token ALL
%token AND
%token ANY
%token AS
%token ASC
%token AVG
%token BEG
%token BETWEEN
%token BOOLEAN
%token BY
%token CASCADE
%token CASE
%token CAST
%token CHAR
%token CHARACTER
%token COALESCE
%token COLLATE
%token COMMAND
%token COMMIT
%token CORRESPONDING
%token COUNT
%token CREATE
%token CROSS
%token CURSOR
%token DATE
%token DEC
%token DECIMAL
%token DEFAULT
%token DELETE
%token DELIM
%token DESC
%token DISTINCT
%token DROP
%token ELSE
%token END
%token EXCEPT
%token EXISTS
%token EXTRACT
%token EXTRINSIC_FUNCTION
%token INTRINSIC_FUNCTION
%token FROM
%token FULL
%token FUNCTION
%token GLOBAL
%token GREATEST
%token GROUP
%token HAVING
%token IDENTIFIER_ALONE
%token IDENTIFIER_BACK_TICK
%token IDENTIFIER_PERIOD_IDENTIFIER
%token ILIKE
%token IN
%token INDEX
%token INNER
%token INSERT
%token INT
%token INTEGER
%token INTERSECT
%token INTO
%token IS
%token JOIN
%token KEY
%token LEAST
%token LEFT
%token LIKE
%token LIMIT
%token MAX
%token MIN
%token NATURAL
%token NOT
%token NULLIF
%token NUM
%token NUMERIC
%token ON
%token OR
%token ORDER
%token OUTER
%token OVER
%token PACK
%token PARTITION
%token PIECE
%token PRIMARY
%token RESTRICT
%token RETURNS
%token RIGHT
%token SELECT
%token SET
%token SHOW
%token SIMILAR
%token SMALLINT
%token START
%token SUM
%token TABLE
%token THEN
%token TIME
%token TO
%token UNION
%token UNIQUE
%token UNKNOWN
%token UNPACK
%token UPDATE
%token USING
%token VALUES
%token VARCHAR
%token VARYING
%token WHEN
%token WHERE

%token TRUE_TOKEN
%token FALSE_TOKEN
%token NULL_TOKEN
%token COMMA
%token LEFT_PAREN
%token RIGHT_PAREN
%token SEMICOLON
%token PLUS
%token MINUS
%token ASTERISK
%token SOLIDUS
%token PERCENT
%token PERIOD
%token EQUALS
%token NOT_EQUALS
%token LESS_THAN
%token GREATER_THAN
%token LESS_THAN_OR_EQUALS
%token GREATER_THAN_OR_EQUALS
%token PIPE
%token TILDE
%token EXCLAMATION
%token LEFT_BRACKET
%token RIGHT_BRACKET
%token COLON

%token LITERAL
%token FAKE_TOKEN
%token INVALID_TOKEN

%token ENDOFFILE
%token EXIT
%token QUIT

%%

sql_statement
  : sql_schema_statement semicolon_or_eof {
      parse_context->is_select = FALSE;
      if (!config->allow_schema_changes){
           ERROR(ERR_ROCTO_NO_SCHEMA, "");
           YYABORT;
      }
      *out = $sql_schema_statement;
      YYACCEPT;
    }
  | sql_data_statement semicolon_or_eof { *out = $sql_data_statement; YYACCEPT; }
  | query_expression semicolon_or_eof {
      SqlValueType	type;

      parse_context->command_tag = select_STATEMENT;
      parse_context->is_select = TRUE;
      if (parse_context->abort) {
        YYABORT;
      }
      if (qualify_query($query_expression, NULL, NULL)) {
          YYABORT;
      }
      if (populate_data_type($query_expression, &type, parse_context)) {
          YYABORT;
      }
      *out = $query_expression; YYACCEPT;
    }
  | BEG semicolon_or_eof {
      parse_context->command_tag = begin_STATEMENT;
      parse_context->is_select = FALSE;
      // For now, we don't do transaction, so just say OK to this word
      SQL_STATEMENT(*out, begin_STATEMENT);
      YYACCEPT;
    }
  | COMMIT semicolon_or_eof {
      parse_context->command_tag = commit_STATEMENT;
      parse_context->is_select = FALSE;
      SQL_STATEMENT(*out, commit_STATEMENT);
      YYACCEPT;
    }
  | error semicolon_or_eof { *out = NULL; YYABORT; }
  | sql_set_statement semicolon_or_eof {
      parse_context->is_select = FALSE;
      *out = $sql_set_statement;
      // No routine will be generated for SET statements, so indicate that for extended query
      STRCPY_LIT(parse_context->routine, "none", MAX_ROUTINE_LEN);
      YYACCEPT;
    }
  | semicolon_or_eof {
      parse_context->is_select = FALSE;
      SQL_STATEMENT(*out, no_data_STATEMENT);
      YYACCEPT;
    }
  | exit_command {
      parse_context->is_select = FALSE;
      SQL_STATEMENT(*out, no_data_STATEMENT);
      eof_hit = EOF_EXIT;
      YYACCEPT;
  }
  ;

semicolon_or_eof
  : SEMICOLON { if ('\0' != input_buffer_combined[cur_input_index]) cur_input_index--; } // The lexer will read one past the SEMICOLON if there is a character there so back up one character
  | ENDOFFILE { assert(EOF_CTRLD == eof_hit); } // The lexer should have set eof_hit at this point and this should always be true
  ;

exit_command
  : QUIT
  | EXIT
  ;

%include "parser/select.y"
%include "parser/insert.y"
%include "parser/update.y"
%include "parser/drop.y"
%include "parser/set.y"

sql_data_statement
  : sql_data_change_statement { $$ = $sql_data_change_statement; }
//  | open_statement
//  | fetch_statement
//  | close_statement
//  | select_statement_single_row
  ;

sql_data_change_statement

  : delete_statement_searched { $$ = $delete_statement_searched; }
//  | delete_statement_position
  | insert_statement { $$ = $insert_statement; }
//  | update_statement_positioned
  | update_statement_searched { $$ = $update_statement_searched; }
  ;

delete_statement_searched
  : DELETE FROM column_name delete_statement_searched_tail { WARNING(ERR_FEATURE_NOT_IMPLEMENTED, "DELETE FROM"); YYABORT; }
  ;

delete_statement_searched_tail
  : /* Empty */ { $$ = NULL; }
  | WHERE search_condition { WARNING(ERR_FEATURE_NOT_IMPLEMENTED, "WHERE search_condition"); YYABORT; }
  ;

search_condition
  : boolean_term {$$ = $boolean_term; }
  | search_condition OR boolean_term  {
      SQL_STATEMENT($$, binary_STATEMENT);
      MALLOC_STATEMENT($$, binary, SqlBinaryOperation);
      ($$)->v.binary->operation = BOOLEAN_OR;
      ($$)->v.binary->operands[0] = ($1);
      ($$)->v.binary->operands[1] = ($boolean_term);
    }
  ;

boolean_term
  : boolean_factor { $$ = $boolean_factor; }
  | boolean_term AND boolean_factor {
      SQL_STATEMENT($$, binary_STATEMENT);
      MALLOC_STATEMENT($$, binary, SqlBinaryOperation);
      ($$)->v.binary->operation = BOOLEAN_AND;
      ($$)->v.binary->operands[0] = ($1);
      ($$)->v.binary->operands[1] = ($boolean_factor);
    }
  ;

boolean_factor
  : boolean_test { $$ = $boolean_test; }
  | NOT boolean_test {
      SQL_STATEMENT($$, unary_STATEMENT);
      MALLOC_STATEMENT($$, unary, SqlUnaryOperation);
      ($$)->v.unary->operation = BOOLEAN_NOT;
      ($$)->v.unary->operand = ($boolean_test);
    }
  ;

boolean_test
  : predicate { $$ = $predicate; }
  | predicate IS NULL_TOKEN {
      SQL_STATEMENT($$, unary_STATEMENT);
      MALLOC_STATEMENT($$, unary, SqlUnaryOperation);
      // TODO: refactor this so that this is BOOLEAN_IS with a value of NULL (#498)
      // that way, we could use the same code for both NULL, NOT NULL, TRUE, and FALSE.
      ($$)->v.unary->operation = BOOLEAN_IS_NULL;
      ($$)->v.unary->operand = ($predicate);
    }
  | predicate IS NOT NULL_TOKEN {
      SQL_STATEMENT($$, unary_STATEMENT);
      MALLOC_STATEMENT($$, unary, SqlUnaryOperation);
      ($$)->v.unary->operation = BOOLEAN_IS_NOT_NULL;
      ($$)->v.unary->operand = ($predicate);
    }
  | predicate IS boolean_primary { WARNING(ERR_FEATURE_NOT_IMPLEMENTED, "boolean_test_tail: IS boolean_primary"); YYABORT; }
  | predicate IS NOT boolean_primary { WARNING(ERR_FEATURE_NOT_IMPLEMENTED, "boolean_test_tail: IS NOT boolean_primary"); YYABORT; }
  // TODO: IS DISTINCT FROM(#557)
  ;

boolean_primary
  : TRUE_TOKEN {
      SQL_STATEMENT($$, value_STATEMENT);
      MALLOC_STATEMENT($$, value, SqlValue);
      ($$)->v.value->type = BOOLEAN_VALUE;
      ($$)->v.value->v.string_literal = "1";
      INVOKE_PARSE_LITERAL_TO_PARAMETER(parse_context, ($$)->v.value, FALSE);
    }
  | FALSE_TOKEN {
      SQL_STATEMENT($$, value_STATEMENT);
      MALLOC_STATEMENT($$, value, SqlValue);
      ($$)->v.value->type = BOOLEAN_VALUE;
      ($$)->v.value->v.string_literal = "0";
      INVOKE_PARSE_LITERAL_TO_PARAMETER(parse_context, ($$)->v.value, FALSE);
    }
  | UNKNOWN { WARNING(ERR_FEATURE_NOT_IMPLEMENTED, "boolean_primary: UNKNOWN"); YYABORT; }
  ;

predicate
  : between_predicate { $$ = $between_predicate; }
  | in_predicate { $$ = $in_predicate; }
//  | like_predicate
  | quantified_comparison_predicate
  | comparison_predicate
//  | match_predicate
//  | overlaps_predicate
  ;

comparison_predicate
  : row_value_constructor
  | row_value_constructor comp_op row_value_constructor {
      SQL_STATEMENT($$, binary_STATEMENT);
      MALLOC_STATEMENT($$, binary, SqlBinaryOperation);
      ($$)->v.binary->operation = (BinaryOperations)$comp_op;	/* Note: "comp_op" rule returns "BinaryOperations" type */
      ($$)->v.binary->operands[0] = ($1);
      ($$)->v.binary->operands[1] = ($3);
    }
  | row_value_constructor TILDE row_value_constructor {
      /* generates a regex type statement
       * operand 1 - always &($$): is the actual SqlStatement that gets passed up
       * operand 2, and 3 - the left and right operands respectively
       * operand 4 - which operator to convert: 0 = regex; 1 = LIKE; 2 = SIMILAR
       * operand 5 - case sensitivity: FALSE = insensitive; TRUE = sensitive
       * operand 6 - not operator: FALSE = no NOT; TRUE = NOT
       */
      INVOKE_REGEX_SPECIFICATION(&($$), ($1), ($3), 0, TRUE, FALSE, parse_context);
    }
  | row_value_constructor TILDE ASTERISK row_value_constructor {
      INVOKE_REGEX_SPECIFICATION(&($$), ($1), ($4), 0, FALSE, FALSE, parse_context);
    }
  | row_value_constructor EXCLAMATION TILDE row_value_constructor {
      INVOKE_REGEX_SPECIFICATION(&($$), ($1), ($4), 0, TRUE, TRUE, parse_context);
    }
  | row_value_constructor EXCLAMATION TILDE ASTERISK row_value_constructor {
      INVOKE_REGEX_SPECIFICATION(&($$), ($1), ($5), 0, FALSE, TRUE, parse_context);
    }
  | row_value_constructor like_predicate row_value_constructor {
      INVOKE_REGEX_SPECIFICATION(&($$), ($1), ($3), 1, TRUE, FALSE, parse_context);
    }
  | row_value_constructor not_like_predicate row_value_constructor {
      INVOKE_REGEX_SPECIFICATION(&($$), ($1), ($3), 1, TRUE, TRUE, parse_context);
    }
  | row_value_constructor insensitive_like_predicate row_value_constructor {
      INVOKE_REGEX_SPECIFICATION(&($$), ($1), ($3), 1, FALSE, FALSE, parse_context);
    }
  | row_value_constructor not_insensitive_like_predicate row_value_constructor {
      INVOKE_REGEX_SPECIFICATION(&($$), ($1), ($3), 1, FALSE, TRUE, parse_context);
    }
  | row_value_constructor SIMILAR TO row_value_constructor {
      INVOKE_REGEX_SPECIFICATION(&($$), ($1), ($4), 2, TRUE, FALSE, parse_context);
    }
  | row_value_constructor NOT SIMILAR TO row_value_constructor {
      INVOKE_REGEX_SPECIFICATION(&($$), ($1), ($5), 2, TRUE, TRUE, parse_context);
    }
  ;

comp_op		/* Note: This rule actually returns a "BinaryOperations" type (not a proper "SqlStatement *" structure pointer)
		 * and caller rules need to know that.
		 */
  : EQUALS                 { $$ = (SqlStatement *)BOOLEAN_EQUALS; }
  | NOT_EQUALS             { $$ = (SqlStatement *)BOOLEAN_NOT_EQUALS; }
  | LESS_THAN              { $$ = (SqlStatement *)BOOLEAN_LESS_THAN; }
  | GREATER_THAN           { $$ = (SqlStatement *)BOOLEAN_GREATER_THAN; }
  | LESS_THAN_OR_EQUALS    { $$ = (SqlStatement *)BOOLEAN_LESS_THAN_OR_EQUALS; }
  | GREATER_THAN_OR_EQUALS { $$ = (SqlStatement *)BOOLEAN_GREATER_THAN_OR_EQUALS; }
  ;

like_predicate
  : TILDE TILDE
  | LIKE
  ;

not_like_predicate
  : EXCLAMATION TILDE TILDE
  | NOT LIKE
  ;

insensitive_like_predicate
  : TILDE TILDE ASTERISK
  | ILIKE
  ;

not_insensitive_like_predicate
  : EXCLAMATION TILDE TILDE ASTERISK
  | NOT ILIKE
  ;


between_predicate
  : row_value_constructor BETWEEN comparison_predicate AND comparison_predicate {
	$$ = between_predicate($row_value_constructor, $3, $5, FALSE);
    }
  | row_value_constructor NOT BETWEEN comparison_predicate AND comparison_predicate {
	$$ = between_predicate($row_value_constructor, $4, $6, TRUE);
    }
  ;


// COALESCE() is variadic, but must have at least one argument.
coalesce
  : COALESCE LEFT_PAREN in_value_list_nonempty RIGHT_PAREN {
      SqlCoalesceCall *call;
      CONDITIONAL_LIST_STMT($$, call, coalesce, SqlCoalesceCall);
      call->arguments = $in_value_list_nonempty;
    }
  ;

greatest
  : GREATEST LEFT_PAREN in_value_list_nonempty RIGHT_PAREN {
      SqlGreatest *call;
      CONDITIONAL_LIST_STMT($$, call, greatest, SqlGreatest);
      call->arguments = $in_value_list_nonempty;
    }
  ;

least
  : LEAST LEFT_PAREN in_value_list_nonempty RIGHT_PAREN {
      SqlLeast *call;
      CONDITIONAL_LIST_STMT($$, call, least, SqlLeast);
      call->arguments = $in_value_list_nonempty;
    }
  ;

nullif
  : NULLIF LEFT_PAREN value_expression[left] COMMA value_expression[right] RIGHT_PAREN {
      SqlNullIf *call;
      CONDITIONAL_LIST_STMT($$, call, null_if, SqlNullIf);
      call->left = $left;
      call->right = $right;
    }
  ;

in_predicate
  : row_value_constructor IN in_predicate_value {
      SQL_STATEMENT($$, binary_STATEMENT);
      MALLOC_STATEMENT($$, binary, SqlBinaryOperation);
      ($$)->v.binary->operation = BOOLEAN_IN;
      ($$)->v.binary->operands[0] = ($row_value_constructor);
      ($$)->v.binary->operands[1] = ($in_predicate_value);
    }
  | row_value_constructor NOT IN in_predicate_value {
      SQL_STATEMENT($$, binary_STATEMENT);
      MALLOC_STATEMENT($$, binary, SqlBinaryOperation);
      ($$)->v.binary->operation = BOOLEAN_NOT_IN;
      ($$)->v.binary->operands[0] = ($row_value_constructor);
      ($$)->v.binary->operands[1] = ($in_predicate_value);
    }
  ;

/// TODO: these require additional structures in octo_types.h
in_predicate_value
  : table_subquery { $$ = $table_subquery; }
  | LEFT_PAREN in_value_list_nonempty RIGHT_PAREN { $$ = $in_value_list_nonempty; }
  ;

table_subquery
  : subquery { $$ = $subquery; }
  ;

in_value_list_allow_empty
  : /* Empty */ {
      SQL_STATEMENT($$, column_list_STATEMENT);
      MALLOC_STATEMENT($$, column_list, SqlColumnList);
      SqlColumnList *column_list;
      UNPACK_SQL_STATEMENT(column_list, $$, column_list);
      dqinit(column_list);
    }
  | in_value_list_nonempty {
      $$ = $in_value_list_nonempty;
    }
  ;

in_value_list_nonempty
  : value_expression in_value_list_tail {
      SqlColumnList *column_list, *cl_tail;

      SQL_STATEMENT($$, column_list_STATEMENT);
      MALLOC_STATEMENT($$, column_list, SqlColumnList);
      UNPACK_SQL_STATEMENT(column_list, $$, column_list);
      ($$)->loc = yyloc;

      column_list->value = $value_expression;
      dqinit(column_list);
      if (NULL != $in_value_list_tail) {
        UNPACK_SQL_STATEMENT(cl_tail, $in_value_list_tail, column_list);
        dqappend(column_list, cl_tail);
      }
    }
  ;

in_value_list_tail
  : /* Empty */ { $$ = NULL; }
  | COMMA in_value_list_nonempty { $$ = $in_value_list_nonempty; }
  ;

quantified_comparison_predicate
  : row_value_constructor comp_op quantifier table_subquery {
	SqlStatement		*ret;

	SQL_STATEMENT(ret, binary_STATEMENT);
	MALLOC_STATEMENT(ret, binary, SqlBinaryOperation);
	ret->v.binary->operands[0] = ($row_value_constructor);
	ret->v.binary->operands[1] = ($table_subquery);
	// Assert that all the ANY boolean opcodes are lined up in same order as non-ANY ones
	assert((BOOLEAN_ANY_EQUALS - BOOLEAN_EQUALS) == (BOOLEAN_ANY_NOT_EQUALS - BOOLEAN_NOT_EQUALS));
	assert((BOOLEAN_ANY_EQUALS - BOOLEAN_EQUALS) == (BOOLEAN_ANY_LESS_THAN - BOOLEAN_LESS_THAN));
	assert((BOOLEAN_ANY_EQUALS - BOOLEAN_EQUALS) == (BOOLEAN_ANY_GREATER_THAN - BOOLEAN_GREATER_THAN));
	assert((BOOLEAN_ANY_EQUALS - BOOLEAN_EQUALS) == (BOOLEAN_ANY_LESS_THAN_OR_EQUALS - BOOLEAN_LESS_THAN_OR_EQUALS));
	assert((BOOLEAN_ANY_EQUALS - BOOLEAN_EQUALS) == (BOOLEAN_ANY_GREATER_THAN_OR_EQUALS - BOOLEAN_GREATER_THAN_OR_EQUALS));
	// Assert that all the ALL boolean opcodes are lined up in same order as non-ALL ones
	assert((BOOLEAN_ALL_EQUALS - BOOLEAN_EQUALS) == (BOOLEAN_ALL_NOT_EQUALS - BOOLEAN_NOT_EQUALS));
	assert((BOOLEAN_ALL_EQUALS - BOOLEAN_EQUALS) == (BOOLEAN_ALL_LESS_THAN - BOOLEAN_LESS_THAN));
	assert((BOOLEAN_ALL_EQUALS - BOOLEAN_EQUALS) == (BOOLEAN_ALL_GREATER_THAN - BOOLEAN_GREATER_THAN));
	assert((BOOLEAN_ALL_EQUALS - BOOLEAN_EQUALS) == (BOOLEAN_ALL_LESS_THAN_OR_EQUALS - BOOLEAN_LESS_THAN_OR_EQUALS));
	assert((BOOLEAN_ALL_EQUALS - BOOLEAN_EQUALS) == (BOOLEAN_ALL_GREATER_THAN_OR_EQUALS - BOOLEAN_GREATER_THAN_OR_EQUALS));
	/* Note: "comp_op" rule returns "BinaryOperations" type as a "SqlStatement *" so directly typecast it */
	ret->v.binary->operation = (((SqlStatement *)ALL == $quantifier)
					? (BinaryOperations)$comp_op + (BOOLEAN_ALL_EQUALS - BOOLEAN_EQUALS)
					: (BinaryOperations)$comp_op + (BOOLEAN_ANY_EQUALS - BOOLEAN_EQUALS));
	$$ = ret;
    }
  ;

quantifier
  : all
  | some
  ;

all
  : ALL { $$ = (SqlStatement *)ALL; }
  ;

some		/* rule is named to allow for SOME or ANY but lexer.l returns ANY in both cases so there is only one rule below */
  : ANY  { $$ = (SqlStatement *)ANY; }
  ;

exists_predicate
  : EXISTS subquery {
      SQL_STATEMENT($$, unary_STATEMENT);
      MALLOC_STATEMENT($$, unary, SqlUnaryOperation);
      ($$)->v.unary->operation = BOOLEAN_EXISTS;
      ($$)->v.unary->operand = ($subquery);
    }
  ;

row_value_constructor
  // Remove previous line and uncomment below line when `row_value_constructor_list` rule is uncommented.
  // : LEFT_PAREN row_value_constructor_list RIGHT_PAREN { $$ = $row_value_constructor_list; }
  : row_value_constructor_element { $$ = $row_value_constructor_element; }
  ;

// ----------------------------------------------------------------------------------------------
// Uncomment below block of code when `row_value_constructor_list` rule needs to be implemented.
// ----------------------------------------------------------------------------------------------
// row_value_constructor_subquery
//   : query_expression { $$ = $query_expression; }
//   ;
//
// row_value_constructor_list
//   : row_value_constructor_element row_value_constructor_list_tail { WARNING(ERR_FEATURE_NOT_IMPLEMENTED, "row_value_constructor_list: element/list_tail"); YYABORT; }
//   | row_value_constructor_subquery { $$ = $row_value_constructor_subquery; }
//   ;
//
// row_value_constructor_list_tail
//   : /* Empty */ { $$ = NULL; }
//   | COMMA row_value_constructor_list { $$ = $row_value_constructor_list; }
//   ;
// ----------------------------------------------------------------------------------------------

row_value_constructor_element
  : numeric_value_expression { $$ = $numeric_value_expression; }
  | default_specification { $$ = $default_specification; }
  ;

/* The runtime system is responsible for ensuring
    types, as we need knowledge of column types

  This is the entry-point for expressions; most rules which want 'an expression'
  should use this. Use other rules only if you need them to enforce precedence.
  Octo tries to match the operator precedence of Postgres wherever possible:
  https://www.postgresql.org/docs/current/sql-syntax-lexical.html#SQL-PRECEDENCE-TABLE
*/
value_expression
  : search_condition { $$ = $search_condition; }
/* WARNING: this is probably not the correct precedence for these expressions
 * interval_expression is a primary: https://ronsavage.github.io/SQL/sql-92.bnf.html#xref-interval%20literal
 * but this is the grammar rule with the _lowest_ precedence.
 * For example it will not allow in `1 + INTERVAL ...`; instead `1 + (INTERVAL ...)` will be required.
 * This should go near value_expression_primary instead.
 * The same holds for datetime_value_expression.
 */
// datetime_value_expression
//  | datetime_value_expression
//  | interval_expression
  ;

null_specification
  : NULL_TOKEN {
      SqlStatement	*ret;

      SQL_STATEMENT(ret, value_STATEMENT);
      MALLOC_STATEMENT(ret, value, SqlValue);
      ret->v.value->type = NUL_VALUE;
      ret->v.value->v.string_literal = "";
      $$ = ret;
    }
  ;

default_specification
  : DEFAULT { WARNING(ERR_FEATURE_NOT_IMPLEMENTED, "default_specification: DEFAULT"); YYABORT; }
  ;

numeric_value_expression
  : term { $$ = $term; }
  | numeric_value_expression PLUS term {
      SQL_STATEMENT($$, binary_STATEMENT);
      MALLOC_STATEMENT($$, binary, SqlBinaryOperation);
      ($$)->v.binary->operation = ADDITION;
      ($$)->v.binary->operands[0] = ($1);
      ($$)->v.binary->operands[1] = ($term);
    }
  | numeric_value_expression MINUS term {
      SQL_STATEMENT($$, binary_STATEMENT);
      MALLOC_STATEMENT($$, binary, SqlBinaryOperation);
      ($$)->v.binary->operation = SUBTRACTION;
      ($$)->v.binary->operands[0] = ($1);
      ($$)->v.binary->operands[1] = ($term);
    }
  | numeric_value_expression OVER partition_by_clause {
      WARNING(ERR_FEATURE_NOT_IMPLEMENTED, "OVER not implemented, just returning columns");
      $$ = $1;
    }
  ;

term
  : factor { $$ = $factor; }
  | term ASTERISK factor {
      SQL_STATEMENT($$, binary_STATEMENT);
      MALLOC_STATEMENT($$, binary, SqlBinaryOperation);
      ($$)->v.binary->operation = MULTIPLICATION;
      ($$)->v.binary->operands[0] = ($1);
      ($$)->v.binary->operands[1] = ($factor);
    }
  | term SOLIDUS factor {
      SQL_STATEMENT($$, binary_STATEMENT);
      MALLOC_STATEMENT($$, binary, SqlBinaryOperation);
      ($$)->v.binary->operation = DIVISION;
      ($$)->v.binary->operands[0] = ($1);
      ($$)->v.binary->operands[1] = ($factor);
    }
  | term PERCENT factor {
      SQL_STATEMENT($$, binary_STATEMENT);
      MALLOC_STATEMENT($$, binary, SqlBinaryOperation);
      ($$)->v.binary->operation = MODULO;
      ($$)->v.binary->operands[0] = ($1);
      ($$)->v.binary->operands[1] = ($factor);
    }
  | term concatenation_operator factor {
      SQL_STATEMENT($$, binary_STATEMENT);
      MALLOC_STATEMENT($$, binary, SqlBinaryOperation);
      ($$)->v.binary->operation = CONCAT;
      ($$)->v.binary->operands[0] = ($1);
      ($$)->v.binary->operands[1] = ($factor);
    }
  ;

concatenation_operator
  : PIPE PIPE { /* Left blank on purpose */ }
  ;

// TODO: exponentiation operator (with a separate precedence) (#558)
/// TODO: collate_clause is thoroughly ignored below
factor
  : PLUS numeric_primary factor_tail {
      SQL_STATEMENT($$, unary_STATEMENT);
      MALLOC_STATEMENT($$, unary, SqlUnaryOperation);
      ($$)->v.unary->operation = FORCE_NUM;
      ($$)->v.unary->operand = ($numeric_primary);
    }
  | MINUS numeric_primary factor_tail {
      SQL_STATEMENT($$, unary_STATEMENT);
      MALLOC_STATEMENT($$, unary, SqlUnaryOperation);
      ($$)->v.unary->operation = NEGATIVE;
      ($$)->v.unary->operand = ($numeric_primary);
    }
  | numeric_primary factor_tail { $$ = $numeric_primary; }
  ;

factor_tail
  : /* Empty */ { $$ = NULL; }
  | collate_clause { $$ = $collate_clause; }
  ;

collate_clause
  : COLLATE collation_name { WARNING(ERR_FEATURE_NOT_IMPLEMENTED, "COLLATE clause"); $$ = $collation_name; }
  ;

collation_name
  : qualified_name { $$ = $qualified_name; }
  ;

numeric_primary
  : value_expression_primary optional_subscript optional_cast_specification {
	if (NULL != $optional_cast_specification) {
		SqlStatement	*ret;

		ret = cast_specification($optional_cast_specification, $value_expression_primary);
		if (NULL == ret) {
			YYERROR;
		}
		$$ = ret;
	} else {
		$$ = $value_expression_primary;
	}
    }
//  | numeric_value_function
  ;

value_expression_primary
  : literal_value { $$ = $literal_value; }
  | column_reference { $$ = $column_reference; }
  | conditional_expression { $$ = $conditional_expression; }
  | set_function_specification { $$ = $set_function_specification; }
  | table_subquery { $$ = $table_subquery; }
  | LEFT_PAREN value_expression RIGHT_PAREN { $$ = $value_expression; }
  | null_specification { $$ = $null_specification; }
  | cast_expression { $$ = $cast_expression; }
  | boolean_primary { $$ = $boolean_primary; }
  | exists_predicate
  ;

cast_expression
  : CAST LEFT_PAREN search_condition AS literal_type RIGHT_PAREN {
      SqlStatement	*ret;

      ret = cast_specification($literal_type, $search_condition);
      if (NULL == ret) {
        YYERROR;
      }
      $$ = ret;
    }
  ;
  
conditional_expression
  : coalesce { $$ = $coalesce; }
  | nullif { $$ = $nullif; }
  | greatest { $$ = $greatest; }
  | least { $$ = $least; }
  | case_expression { $$ = $case_expression; }
  ;

optional_cast_specification
  : /* Empty */ { $$ = NULL; }
  | COLON COLON literal_type {
      $$ = (SqlStatement *)$literal_type;
    }
  | COLON COLON identifier {
      SqlValue	*value;

      UNPACK_SQL_STATEMENT(value, $identifier, value);
      ERROR(ERR_INVALID_TYPE, value->v.string_literal);
      $$ = (SqlStatement *)INVALID_SqlValueType;
    }
  ;

literal_type
  : data_type {
      $$ = (SqlStatement *)get_sqlvaluetype_from_sqldatatype((SqlDataType)$data_type);
    }
  ;

case_expression
  : case_specification { $$ = $case_specification; }
//  | case_abbreviation
  ;

case_specification
  : simple_case { $$ = $simple_case; }
//  | searched_case
  ;

simple_case
  : CASE value_expression simple_when_clause optional_else_clause END {
      SQL_STATEMENT($$, cas_STATEMENT);
      MALLOC_STATEMENT($$, cas, SqlCaseStatement);
      SqlCaseStatement *cas;
      UNPACK_SQL_STATEMENT(cas, $$, cas);
      cas->value = $value_expression;
      cas->branches = $simple_when_clause;
      cas->optional_else = $optional_else_clause;
    }
  | CASE simple_when_clause optional_else_clause END {
      SQL_STATEMENT($$, cas_STATEMENT);
      MALLOC_STATEMENT($$, cas, SqlCaseStatement);
      SqlCaseStatement *cas;
      UNPACK_SQL_STATEMENT(cas, $$, cas);
      cas->value = NULL;
      cas->branches = $simple_when_clause;
      cas->optional_else = $optional_else_clause;
    }
  ;

simple_when_clause
  : WHEN value_expression THEN result simple_when_clause_tail {
      SQL_STATEMENT($$, cas_branch_STATEMENT);
      MALLOC_STATEMENT($$, cas_branch, SqlCaseBranchStatement);
      SqlCaseBranchStatement *cas_branch, *tail_cas_branch;
      UNPACK_SQL_STATEMENT(cas_branch, $$, cas_branch);
      cas_branch->condition = $value_expression;
      cas_branch->value = $result;
      dqinit(cas_branch);
      if (NULL != $simple_when_clause_tail) {
        UNPACK_SQL_STATEMENT(tail_cas_branch, $simple_when_clause_tail, cas_branch);
        dqappend(cas_branch, tail_cas_branch);
      }
    }
  ;

simple_when_clause_tail
  : /* None */ { $$ = NULL; }
  | simple_when_clause { $$ = $simple_when_clause; }
  ;

optional_else_clause
  : /* Empty */ { $$ = NULL; }
  | ELSE result { $$ = $result; }
  ;

result
  : value_expression { $$ = $value_expression; }
  ;


set_function_specification
  : COUNT LEFT_PAREN ASTERISK RIGHT_PAREN {
	$$ = aggregate_function(COUNT_ASTERISK_AGGREGATE, NO_KEYWORD, NULL);
    }
  | COUNT LEFT_PAREN set_quantifier value_expression RIGHT_PAREN {
	YYLTYPE	tmploc;

	tmploc = $value_expression->loc;	/* needed so we can pass a different yyloc to "aggregate_function()" */
	$value_expression->loc = yyloc;		/* for later use by "aggregate_function()" */
	$$ = aggregate_function(COUNT_AGGREGATE, (OptionalKeyword)$set_quantifier, $value_expression);
	$value_expression->loc = tmploc;	/* Restore origin "loc" now that passing yyloc is done */
    }
  | general_set_function { $$ = $general_set_function; }
  | generic_function_call { $$ = $generic_function_call; }
  ;

general_set_function
  : set_function_type LEFT_PAREN set_quantifier value_expression RIGHT_PAREN {
	YYLTYPE	tmploc;

	tmploc = $value_expression->loc;	/* needed so we can pass a different yyloc to "aggregate_function()" */
	$value_expression->loc = yyloc;		/* for later use by "aggregate_function()" */
	$$ = aggregate_function((SqlAggregateType)$set_function_type, (OptionalKeyword)$set_quantifier, $value_expression);
	$value_expression->loc = tmploc;	/* Restore origin "loc" now that passing yyloc is done */
    }
  ;

set_function_type
  : AVG { $$ = (SqlStatement *)AVG_AGGREGATE; }
  | MAX { $$ = (SqlStatement *)MAX_AGGREGATE; }
  | MIN { $$ = (SqlStatement *)MIN_AGGREGATE; }
  | SUM { $$ = (SqlStatement *)SUM_AGGREGATE; }
  ;

generic_function_call
  : column_name LEFT_PAREN in_value_list_allow_empty RIGHT_PAREN {
      SQL_STATEMENT($$, value_STATEMENT);
      MALLOC_STATEMENT($$, value, SqlValue);
      SqlStatement *fc_statement;
      SqlFunctionCall *fc;
      SqlValue *value;
      UNPACK_SQL_STATEMENT(value, $$, value);

      value->type = CALCULATED_VALUE;
      SQL_STATEMENT(fc_statement, function_call_STATEMENT);
      MALLOC_STATEMENT(fc_statement, function_call, SqlFunctionCall);
      UNPACK_SQL_STATEMENT(fc, fc_statement, function_call);
      fc->function_name = $column_name;
      fc->parameters = $in_value_list_allow_empty;
      value->v.calculated = fc_statement;

      // Change the function name value to be a string literal rather than column reference
      UNPACK_SQL_STATEMENT(value, $column_name, value);
      value->type = FUNCTION_NAME;
      SQL_STATEMENT(fc->function_schema, create_function_STATEMENT);
      fc->function_schema->v.create_function = find_function(value->v.string_literal);	// Retrieve the DDL for the given function
      if (NULL == fc->function_schema->v.create_function) {	// Issue syntax error and abort if function doesn't exist
        yyerror(&(fc->function_name->loc), NULL, NULL, NULL, NULL, NULL);
	YYERROR;
      }
    }
  ;

// We don't abort below because we want this to pass for fetching schema information
optional_subscript
  : /* Empty */ { $$ = NULL; }
  | LEFT_BRACKET literal_value RIGHT_BRACKET { WARNING(ERR_FEATURE_NOT_IMPLEMENTED, "arrays"); }
  ;

column_reference
  : qualifier PERIOD column_name {
      SqlValue *qual, *col_name;
      char *new_string, *c;
      int len_qual, len_col_name;
      UNPACK_SQL_STATEMENT(qual, $qualifier, value);
      UNPACK_SQL_STATEMENT(col_name, $column_name, value);
      len_qual = strlen(qual->v.string_literal);
      len_col_name = strlen(qual->v.string_literal);
      // +1 for null, +1 for '.'
      new_string = octo_cmalloc(memory_chunks, len_qual + len_col_name + 2);
      c = new_string;
      memcpy(c, qual->v.string_literal, len_qual);
      c += len_qual;
      *c++ = '.';
      memcpy(c, col_name->v.string_literal, len_col_name);
      c += len_col_name;
      *c++ = '\0';
      qual->v.string_literal = new_string;
      $$ = $qualifier;
    }
  | column_name { $$ = $column_name; }
  ;

qualifier
  : column_name { $$ = $column_name; }
  ;

subquery
  : LEFT_PAREN query_expression RIGHT_PAREN { $$ = $query_expression; }
  ;

query_expression
  : non_join_query_expression { $$ = $non_join_query_expression; }
  | joined_table { $$ = $joined_table; }
  ;

non_join_query_expression
  : non_join_query_term { $$ = $non_join_query_term; }
  | query_expression UNION query_term non_join_query_expression_tail_tail {
        $$ = set_operation(SET_UNION, $query_expression, $query_term);
    }
  | query_expression UNION ALL query_term non_join_query_expression_tail_tail {
        $$ = set_operation(SET_UNION_ALL, $query_expression, $query_term);
    }
  | query_expression EXCEPT query_term non_join_query_expression_tail_tail {
        $$ = set_operation(SET_EXCEPT, $query_expression, $query_term);
    }
  | query_expression EXCEPT ALL query_term non_join_query_expression_tail_tail {
        $$ = set_operation(SET_EXCEPT_ALL, $query_expression, $query_term);
    }
  ;

non_join_query_expression_tail_tail
  : /* Empty */ { $$ = NULL; }
  | CORRESPONDING non_join_query_expression_tail_tail_tail { WARNING(ERR_FEATURE_NOT_IMPLEMENTED, "non_join_query_expression_tail_tail : CORRESPONDING non_join_query_expression_tail_tail_tail: BY LEFT_PAREN corresponding_column_list RIGHT_PAREN"); YYABORT; }
  ;

non_join_query_expression_tail_tail_tail
  : /* Empty */ { $$ = NULL; }
  | BY LEFT_PAREN corresponding_column_list RIGHT_PAREN { WARNING(ERR_FEATURE_NOT_IMPLEMENTED, "non_join_query_expression_tail_tail_tail: BY LEFT_PAREN corresponding_column_list RIGHT_PAREN"); YYABORT; }
  ;

corresponding_column_list
  : column_name_list { $$ = $column_name_list; }
  ;

column_name_list
  : column_name column_name_list_tail { WARNING(ERR_FEATURE_NOT_IMPLEMENTED, "column_name_list: column_name column_name_list_tail"); YYABORT; }
  ;

column_name_list_tail
  : /* Empty */ { $$ = NULL; }
  | COMMA column_name_list { $$ = $column_name_list; }
  ;

query_term
  : non_join_query_term { $$ = $non_join_query_term; }
  | joined_table { $$ = $joined_table; }
  ;

non_join_query_term
  : non_join_query_primary {$$ = $non_join_query_primary; }
  | query_term INTERSECT corresponding_spec query_primary {
        $$ = set_operation(SET_INTERSECT, $query_term, $query_primary);
    }
  | query_term INTERSECT ALL corresponding_spec query_primary {
        $$ = set_operation(SET_INTERSECT_ALL, $query_term, $query_primary);
    }
  ;

corresponding_spec
  : CORRESPONDING corresponding_spec_tail { WARNING(ERR_FEATURE_NOT_IMPLEMENTED, "corresponding_spec: CORRESPONDING corresponding_spec_tail"); YYABORT; }
  | /* Empty */
  ;

corresponding_spec_tail
  : BY LEFT_PAREN corresponding_column_list RIGHT_PAREN { WARNING(ERR_FEATURE_NOT_IMPLEMENTED, "corresponding_spec_tail: BY LEFT_PAREN corresponding_column_list RIGHT_PAREN"); YYABORT; }
  ;

non_join_query_primary
  : simple_table {$$ = $simple_table; }
  | LEFT_PAREN non_join_query_expression RIGHT_PAREN { $$ = $non_join_query_expression; }
  ;

simple_table
  : table_value_constructor { WARNING(ERR_FEATURE_NOT_IMPLEMENTED, "table_value_constructor"); YYABORT; }
  | explicit_table { WARNING(ERR_FEATURE_NOT_IMPLEMENTED, "explicit_table"); YYABORT; }
  | sql_select_statement { $$ = $sql_select_statement; }
  ;

table_value_constructor
  : VALUES table_value_constructor_list { $$ = $table_value_constructor_list; }
  ;

table_value_constructor_list
  : row_value_constructor table_value_constructor_list_tail { WARNING(ERR_FEATURE_NOT_IMPLEMENTED, "column_name_list: column_name column_name_list_tail"); YYABORT; }
  ;

table_value_constructor_list_tail
  : /* Empty */ { $$ = NULL; }
  | COMMA table_value_constructor_list { $$ = $table_value_constructor_list; }
  ;

explicit_table
  : TABLE column_name { WARNING(ERR_FEATURE_NOT_IMPLEMENTED, "corresponding_spec_tail: BY LEFT_PAREN corresponding_column_list RIGHT_PAREN"); YYABORT; }
  ;

query_primary
  : non_join_query_primary { $$ = $non_join_query_primary;}
  | joined_table { $$ = $joined_table;}
  ;

sql_schema_statement
  : sql_schema_definition_statement { $$ = $sql_schema_definition_statement; }
  | sql_schema_manipulation_statement { $$ = $sql_schema_manipulation_statement;}
  ;

/// TODO: not complete
sql_schema_manipulation_statement
  : drop_table_statement { $$ = $drop_table_statement; parse_context->command_tag = drop_table_STATEMENT; }
  | drop_function_statement { $$ = $drop_function_statement; parse_context->command_tag = drop_function_STATEMENT; }
  ;

sql_schema_definition_statement
  : table_definition { $$ = $table_definition; parse_context->command_tag = create_table_STATEMENT; }
  | index_definition { $$ = $index_definition; }
  | function_definition { $$ = $function_definition; }
  ;

/// TODO: not complete
table_definition
  : CREATE TABLE column_name LEFT_PAREN table_element_list RIGHT_PAREN table_definition_tail {
        SQL_STATEMENT($$, create_table_STATEMENT);
        MALLOC_STATEMENT($$, create_table, SqlTable);
        memset(($$)->v.create_table, 0, sizeof(SqlTable));
        assert($column_name->type == value_STATEMENT
          && $column_name->v.value->type == COLUMN_REFERENCE);
        ($$)->v.create_table->tableName = $column_name;
        ($$)->v.create_table->columns = $table_element_list;
        assign_table_to_columns($$);
        if (create_table_defaults($$, $table_definition_tail)) {
          YYABORT;
        }
      }
  ;

table_definition_tail
  : /* Empty */ {
      SQL_STATEMENT($$, keyword_STATEMENT);
      MALLOC_STATEMENT($$, keyword, SqlOptionalKeyword);
      ($$)->v.keyword->keyword = NO_KEYWORD;
      ($$)->v.keyword->v = NULL;
      dqinit(($$)->v.keyword);
    }
  | optional_keyword { $$ = $optional_keyword; }
  ;

optional_keyword
  : optional_keyword_element optional_keyword_tail {
      $$ = $optional_keyword_element;
      SqlOptionalKeyword *keyword;
      UNPACK_SQL_STATEMENT(keyword, $optional_keyword_tail, keyword);
      dqappend(keyword, ($$)->v.keyword);
    }
  ;

optional_keyword_element
  : GLOBAL literal_value {
      SQL_STATEMENT($$, keyword_STATEMENT);
      MALLOC_STATEMENT($$, keyword, SqlOptionalKeyword);
      ($$)->v.keyword->keyword = OPTIONAL_SOURCE;
      ($$)->v.keyword->v = $literal_value;
      dqinit(($$)->v.keyword);
    }
  | DELIM literal_value {
	char	*with_flag_byte, *str_lit;
	size_t	length;

	SQL_STATEMENT($$, keyword_STATEMENT);
	MALLOC_STATEMENT($$, keyword, SqlOptionalKeyword);
	($$)->v.keyword->keyword = OPTIONAL_DELIM;
	($$)->v.keyword->v = $literal_value;
	str_lit = ($$)->v.keyword->v->v.value->v.string_literal;
	length = strlen(str_lit) + 2;	// "is_dollar_char" byte and a null terminator
	with_flag_byte = octo_cmalloc(memory_chunks, length);
	with_flag_byte[0] = DELIM_IS_LITERAL;	// Use first byte as a flag to indicate that DELIM is NOT a $CHAR list
	snprintf(&with_flag_byte[1], length-1, "%s", str_lit);
	($$)->v.keyword->v->v.value->v.string_literal = with_flag_byte;
	dqinit(($$)->v.keyword);
     }
  | DELIM LEFT_PAREN delim_char_list RIGHT_PAREN {
	SqlStatement			*char_list_literal;
	SqlDelimiterCharacterList	*start_delim_char_list, *cur_delim_char_list;
	char				*c, *temp, *str_lit;
	int				copied, len_used, len_alloc;

	SQL_STATEMENT($$, keyword_STATEMENT);
        MALLOC_STATEMENT($$, keyword, SqlOptionalKeyword);
	($$)->v.keyword->keyword = OPTIONAL_DELIM;

	SQL_STATEMENT(char_list_literal, value_STATEMENT);
	MALLOC_STATEMENT(char_list_literal, value, SqlValue);
	char_list_literal->v.value->type = DELIM_VALUE;
	len_alloc = INT8_TO_STRING_MAX * 8;
	str_lit = octo_cmalloc(memory_chunks, len_alloc);
	str_lit[0] = DELIM_IS_DOLLAR_CHAR;	// Use first byte as a flag to indicate that DELIM is a $CHAR list
	len_used = 1;
	char_list_literal->v.value->v.string_literal = str_lit;
	c = &str_lit[1];

	// Need to allocate space to store string for full $CHAR call
	UNPACK_SQL_STATEMENT(start_delim_char_list, $delim_char_list, delim_char_list);
	cur_delim_char_list = start_delim_char_list;
	copied = snprintf(c, INT16_TO_STRING_MAX, "$CHAR(");
	len_used += copied;
	assert(INT16_TO_STRING_MAX > copied);
	c += copied;
	do {
		/* Expand allocation if there's not enough space for another value.
		 * Note that it is acceptable here to do a new allocation without freeing the previous one
		 * as the items allocated with octo_cmalloc are automatically freed after query execution is complete (or cancelled)
		 */
		if (INT8_TO_STRING_MAX > len_alloc - len_used) {
			len_alloc *= 2;
			temp = str_lit;
			str_lit = octo_cmalloc(memory_chunks, len_alloc);
			memcpy(str_lit, temp, len_used);
			c = str_lit;
			c+= len_used;
		}
		copied = snprintf(c, INT8_TO_STRING_MAX, "%d", cur_delim_char_list->character);
		assert(INT8_TO_STRING_MAX > copied);
		c += copied;
		len_used += copied;
		cur_delim_char_list = cur_delim_char_list->next;
		if(start_delim_char_list != cur_delim_char_list) {
			copied = snprintf(c, 3, ",");
			assert(3 > copied);
			c += copied;
			len_used += copied;
		}
	} while (cur_delim_char_list != start_delim_char_list);
	copied = snprintf(c, 2, ")");
	assert(2 > copied);
	c += copied;
	*c = '\0';
	char_list_literal->v.value->v.string_literal = str_lit;

	($$)->v.keyword->v = char_list_literal;
	dqinit(($$)->v.keyword);
    }
  ;

delim_char_list
  : literal_value delim_char_list_tail {
	SqlDelimiterCharacterList	*delim_char_list;
	SqlStatement			*literal;
	SqlValueType			type;
	long				delim_int;
	char				*end_ptr, *str_lit;

	literal = $literal_value;
	type = literal->v.value->type;
	str_lit = literal->v.value->v.string_literal;
	/* We should only accept integer arguments for subsequent call to $CHAR, however
	 * the lexer returns NUMERICs even if an integer is passed. To account for this,
	 * we confirm NUMERIC here, then check the result of strtol below to confirm that
	 * the value was in fact an integer.
	 *
	 * TODO: Add support for hexadecimal arguments.
	 */
	if (NUMERIC_LITERAL != type) {
		ERROR(ERR_TYPE_NOT_COMPATIBLE, get_user_visible_type_string(type), "column DELIM specification");
		yyerror(&yyloc, NULL, NULL, NULL, NULL, NULL);
		YYERROR;
	}

	SQL_STATEMENT($$, delim_char_list_STATEMENT);
	MALLOC_STATEMENT($$, delim_char_list, SqlDelimiterCharacterList);
	UNPACK_SQL_STATEMENT(delim_char_list, $$, delim_char_list);

	assert(value_STATEMENT == literal->type);

	delim_int = strtol(str_lit, &end_ptr, 10);
	if ((ERANGE == errno) || (0 > delim_int) || (DELIM_MAX < delim_int)) {
		ERROR(ERR_INVALID_KEYWORD_CHAR, delim_int, "delimiter");
		yyerror(&yyloc, NULL, NULL, NULL, NULL, NULL);
		YYERROR;
	}
	// Confirm that the value passed was in fact an INTEGER and not NUMERIC. Check based off of `man strtol`.
	if (('\0' != str_lit[0]) && ('\0' == *end_ptr)) {
		delim_char_list->character = (int)delim_int;	// Range check above guarantees this is a safe cast
	} else {
		ERROR(ERR_TYPE_NOT_COMPATIBLE, "NUMERIC", "column DELIM specification");
		yyerror(&yyloc, NULL, NULL, NULL, NULL, NULL);
		YYERROR;
	}
	dqinit(delim_char_list);
	if ($delim_char_list_tail) {
		assert(delim_char_list_STATEMENT == $delim_char_list_tail->type);
		dqappend(delim_char_list, $delim_char_list_tail->v.delim_char_list);
	}
    }
  ;

delim_char_list_tail
  : /* Empty */ { $$ = NULL; }
  | COMMA delim_char_list { $$ = $delim_char_list; }
  ;

optional_keyword_tail
  : /* Empty */ {
      SQL_STATEMENT($$, keyword_STATEMENT);
      MALLOC_STATEMENT($$, keyword, SqlOptionalKeyword);
      ($$)->v.keyword->keyword = NO_KEYWORD;
      ($$)->v.keyword->v = NULL;
      dqinit(($$)->v.keyword);
    }
  | optional_keyword { assert($optional_keyword->type == keyword_STATEMENT); $$ = $optional_keyword; }
  ;

table_element_list
  :  table_element table_element_list_tail  {
      $$ = $table_element;
      assert($$->type == column_STATEMENT);
      if ($table_element_list_tail)
      {
        assert($table_element_list_tail->type == column_STATEMENT);
        dqappend($table_element_list_tail->v.column, ($$)->v.column);
      }
    }
  ;

table_element_list_tail
  : /* Empty */ { $$ = 0; }
  | COMMA table_element_list { $$ = $table_element_list; }
  ;

table_element
  : column_definition { $$ = $column_definition; }
//  | table_constraint_definition
  ;

/// TODO: not complete
column_definition
  : column_name data_type column_definition_tail {
      SQL_STATEMENT($$, column_STATEMENT);
      MALLOC_STATEMENT($$, column, SqlColumn);
      dqinit(($$)->v.column);
      ($$)->v.column->columnName = $column_name;
      ($$)->v.column->type = (SqlDataType)$data_type;
      ($$)->v.column->keywords = $column_definition_tail;
    }
//  | more stuff
  ;

column_name
  : identifier { $$ = $identifier; }
  | LITERAL PERIOD LITERAL {
      SQL_STATEMENT($$, value_STATEMENT);
      MALLOC_STATEMENT($$, value, SqlValue);
      SqlValue *value;
      UNPACK_SQL_STATEMENT(value, $$, value);
      SqlValue *table_name, *column_name;
      UNPACK_SQL_STATEMENT(table_name, $1, value);
      UNPACK_SQL_STATEMENT(column_name, $3, value);
      int table_name_len = strlen(table_name->v.string_literal);
      int column_name_len = strlen(column_name->v.string_literal);
      // table + column + period + null
      int len = table_name_len + column_name_len + 2;
      value->type = COLUMN_REFERENCE;
      value->v.string_literal = octo_cmalloc(memory_chunks, len);
      char *c = value->v.string_literal;
      char *d = table_name->v.string_literal;
      // Convert to caps as we copy
      while(*d != '\0') {
        *c++ = toupper(*d++);
      }
      *c = '.';
      c++;
      d = column_name->v.string_literal;
      while(*d != '\0') {
        *c++ = toupper(*d++);
      }
      *c = '\0';
    }
  ;

column_definition_tail
  : /* Empty */ {
       SQL_STATEMENT($$, keyword_STATEMENT);
       MALLOC_STATEMENT($$, keyword, SqlOptionalKeyword);
       dqinit(($$)->v.keyword);
    }
  | EXTRACT literal_value column_definition_tail {
       SQL_STATEMENT($$, keyword_STATEMENT);
       MALLOC_STATEMENT($$, keyword, SqlOptionalKeyword);
       ($$)->v.keyword->keyword = OPTIONAL_EXTRACT;
       ($$)->v.keyword->v = $literal_value;
       dqinit(($$)->v.keyword);

       SqlOptionalKeyword *keyword;
       UNPACK_SQL_STATEMENT(keyword, $3, keyword);
       dqappend(keyword, ($$)->v.keyword);
    }
  | PIECE literal_value column_definition_tail {
       SqlOptionalKeyword *keyword;

       SQL_STATEMENT($$, keyword_STATEMENT);
       MALLOC_STATEMENT($$, keyword, SqlOptionalKeyword);
       keyword = $$->v.keyword;
       keyword->keyword = OPTIONAL_PIECE;
       keyword->v = $literal_value;
       dqinit(($$)->v.keyword);

       UNPACK_SQL_STATEMENT(keyword, $3, keyword);
       dqappend(keyword, ($$)->v.keyword);
    }
  | DELIM literal_value column_definition_tail {
       SQL_STATEMENT($$, keyword_STATEMENT);
       MALLOC_STATEMENT($$, keyword, SqlOptionalKeyword);
       ($$)->v.keyword->keyword = OPTIONAL_DELIM;
       ($$)->v.keyword->v = $literal_value;
       dqinit(($$)->v.keyword);

       SqlOptionalKeyword *keyword;
       UNPACK_SQL_STATEMENT(keyword, $3, keyword);
       dqappend(keyword, ($$)->v.keyword);
     }
  | GLOBAL literal_value column_definition_tail {
       SQL_STATEMENT($$, keyword_STATEMENT);
       MALLOC_STATEMENT($$, keyword, SqlOptionalKeyword);
       ($$)->v.keyword->keyword = OPTIONAL_SOURCE;
       ($$)->v.keyword->v = $literal_value;
       dqinit(($$)->v.keyword);

       SqlOptionalKeyword *keyword;
       UNPACK_SQL_STATEMENT(keyword, $3, keyword);
       dqappend(keyword, ($$)->v.keyword);
    }
  | KEY NUM literal_value column_definition_tail {
       SQL_STATEMENT($$, keyword_STATEMENT);
       MALLOC_STATEMENT($$, keyword, SqlOptionalKeyword);
       ($$)->v.keyword->keyword = OPTIONAL_KEY_NUM;
       ($$)->v.keyword->v = $literal_value;
       dqinit(($$)->v.keyword);

       SqlOptionalKeyword *keyword;
       UNPACK_SQL_STATEMENT(keyword, $4, keyword);
       dqappend(keyword, ($$)->v.keyword);
    }
  | ADVANCE literal_value column_definition_tail {
       SQL_STATEMENT($$, keyword_STATEMENT);
       MALLOC_STATEMENT($$, keyword, SqlOptionalKeyword);
       ($$)->v.keyword->keyword = OPTIONAL_ADVANCE;
       ($$)->v.keyword->v = $literal_value;
       dqinit(($$)->v.keyword);

       SqlOptionalKeyword *keyword;
       UNPACK_SQL_STATEMENT(keyword, $3, keyword);
       dqappend(keyword, ($$)->v.keyword);
    }
  | START literal_value column_definition_tail {
       SQL_STATEMENT($$, keyword_STATEMENT);
       MALLOC_STATEMENT($$, keyword, SqlOptionalKeyword);
       ($$)->v.keyword->keyword = OPTIONAL_START;
       ($$)->v.keyword->v = $literal_value;
       dqinit(($$)->v.keyword);

       SqlOptionalKeyword *keyword;
       UNPACK_SQL_STATEMENT(keyword, $3, keyword);
       dqappend(keyword, ($$)->v.keyword);
    }
  | END literal_value column_definition_tail {
       SQL_STATEMENT($$, keyword_STATEMENT);
       MALLOC_STATEMENT($$, keyword, SqlOptionalKeyword);
       ($$)->v.keyword->keyword = OPTIONAL_END;
       ($$)->v.keyword->v = $literal_value;
       dqinit(($$)->v.keyword);

       SqlOptionalKeyword *keyword;
       UNPACK_SQL_STATEMENT(keyword, $3, keyword);
       dqappend(keyword, ($$)->v.keyword);
    }
  | column_constraint_definition column_definition_tail {
       $$ = $column_constraint_definition;
       SqlOptionalKeyword *keyword;
       UNPACK_SQL_STATEMENT(keyword, $2, keyword);
       dqappend(keyword, ($$)->v.keyword);
    }
  ;

column_constraint_definition
  : constraint_name_definition column_constraint constraint_attributes {
      ($$) = $column_constraint;
    }
  ;

/// TODO: not complete
constraint_name_definition
  : /* Empty */ { $$ = NULL; }
  ;

/// TODO: not complete
column_constraint
  : NOT NULL_TOKEN {
      SQL_STATEMENT($$, keyword_STATEMENT);
      MALLOC_STATEMENT($$, keyword, SqlOptionalKeyword);
      ($$)->v.keyword->keyword = NOT_NULL;
      dqinit(($$)->v.keyword);
    }
  | unique_specifications { $$ = $unique_specifications; }
//  | reference_specifications
//  | check_constraint_definition
  ;

unique_specifications
  : UNIQUE {
      SQL_STATEMENT($$, keyword_STATEMENT);
      MALLOC_STATEMENT($$, keyword, SqlOptionalKeyword);
      ($$)->v.keyword->keyword = UNIQUE_CONSTRAINT;
      dqinit(($$)->v.keyword);
    }
  | PRIMARY KEY {
      SQL_STATEMENT($$, keyword_STATEMENT);
      MALLOC_STATEMENT($$, keyword, SqlOptionalKeyword);
      ($$)->v.keyword->keyword = PRIMARY_KEY;
      dqinit(($$)->v.keyword);
    }
  ;

/// TODO: not complete
constraint_attributes
  : /* Empty */
  ;

// TODO: Implement indexes. For now, create a dummy struct to ignore them in run_query.
index_definition
	: INDEX index_name literal_value {
		WARNING(ERR_FEATURE_NOT_IMPLEMENTED, "INDEX statements");
		SQL_STATEMENT($$, index_STATEMENT);
		MALLOC_STATEMENT($$, index, SqlIndex);
		memset(($$)->v.index, 0, sizeof(SqlIndex));
		}
	;

index_name
	: column_name { $$ = $column_name; }
	;

qualified_name
  : qualified_identifier { $$ = $qualified_identifier; }
//  | schema_name period qualified_identifier
  ;

qualified_identifier
  : identifier { $$ = $identifier; }
  ;

identifier
  : actual_identifier { $$ = $actual_identifier; }
//  | introducer character_set_specification actual_identifier
  ;

actual_identifier
  : regular_identifier { $$ = $regular_identifier; }
//  | delimited_identifier
  ;

regular_identifier
  : identifier_body { $$ = $identifier_body; }
  ;

identifier_body
  : IDENTIFIER_START { $$ = $IDENTIFIER_START; ($$)->loc = yyloc; }
  | m_function {
	/* Disallow invoking arbitary M code (e.g. `SELECT $$^MCODE()`). Only M code defined
	 * in the DDL (through a CREATE FUNCTION statement) is allowed to be invoked through an SQL function.
	 */
	ERROR(ERR_M_CALL, NULL);
	/* We issue a parser error here so that parsing for this token finish
	 * rather than using YYABORT to exit prematurely.
	 */
	yyerror(&yyloc, NULL, NULL, NULL, NULL, NULL);
	YYERROR;
    }
//  | identifier_start underscore
//  | identifier_start identifier_part
  ;

IDENTIFIER_START
  : IDENTIFIER_BACK_TICK { $$ = $IDENTIFIER_BACK_TICK; ($$)->loc = yyloc; }
  | IDENTIFIER_PERIOD_IDENTIFIER { $$ = $IDENTIFIER_PERIOD_IDENTIFIER; ($$)->loc = yyloc; }
  | IDENTIFIER_ALONE { $$ = $IDENTIFIER_ALONE; ($$)->loc = yyloc; }
  ;

data_type
  : character_string_type {
      $$ = (SqlStatement *)STRING_TYPE;
    }
//  | character_string_type CHARACTER SET character_set_specification
//  | national_character_string_type
//  | bit_string_type
  | numeric_type {
      $$ = (SqlStatement *)NUMERIC_TYPE;
    }
  | integer_type {
	SQL_STATEMENT($$, data_type_STATEMENT);
      $$ = (SqlStatement *)INTEGER_TYPE;
    }
  | boolean_type {
	SQL_STATEMENT($$, data_type_STATEMENT);
      $$ = (SqlStatement *)BOOLEAN_TYPE;
    }
  | datetime_type {
	/* For now treat DATE or TIME types as equivalent to the STRING/VARCHAR type */
      SQL_STATEMENT($$, data_type_STATEMENT);
      $$ = (SqlStatement *)STRING_TYPE;
    }
//  | interval_type
  ;

// These should be implemented as constraints
character_string_type
  : CHARACTER character_string_type_char_tail { $$ = $character_string_type_char_tail; }
  | CHAR character_string_type_char_tail { $$ = $character_string_type_char_tail; }
  | CHARACTER VARYING character_string_type_char_tail { $$ = $character_string_type_char_tail; }
  | CHAR VARYING character_string_type_char_tail { $$ = $character_string_type_char_tail; }
  | VARCHAR character_string_type_char_tail { $$ = $character_string_type_char_tail; }
  ;

character_string_type_char_tail
  : /* Empty */ { $$ = NULL; }
  | LEFT_PAREN length RIGHT_PAREN { $$ = $length; }
  ;

length
  : literal_value { $$ = $literal_value; }
  ;

numeric_type
  : exact_numeric_type { $$ = $exact_numeric_type; }
//  | approximate_numeric_type
  ;

exact_numeric_type
  : NUMERIC exact_numeric_type_tail { $$ = $exact_numeric_type_tail; }
  | DECIMAL exact_numeric_type_tail { $$ = $exact_numeric_type_tail; }
  | DEC exact_numeric_type_tail { $$ = $exact_numeric_type_tail; }
  ;

integer_type
  : INTEGER integer_type_tail { $$ = NULL; }
  | INT integer_type_tail { $$ = NULL; }
  | SMALLINT integer_type_tail { $$ = NULL; }
  ;

boolean_type
  : BOOLEAN { $$ = NULL; }
  ;

datetime_type
  : DATE { $$ = NULL; }
  | TIME time_type_tail { $$ = $time_type_tail; }
  ;

time_type_tail
  : /* Empty */ { $$ = NULL; }
  | LEFT_PAREN precision RIGHT_PAREN {
      $$ = $precision;
    }

/// TODO: we should have a triple for this type of numeric which includes scale
exact_numeric_type_tail
  : /* Empty */ { $$ = NULL; }
  | LEFT_PAREN precision exact_numeric_type_tail_tail RIGHT_PAREN {
      $$ = $precision;
    }
  ;

exact_numeric_type_tail_tail
  : /* Empty */ { $$ = NULL; }
  | COMMA scale { $$ = $scale; }
  ;

integer_type_tail
  : /* Empty */ { $$ = NULL; }
  | LEFT_PAREN precision RIGHT_PAREN {
      $$ = $precision;
    }

precision
  : literal_value { $$ = $literal_value; }
  ;

scale
  : literal_value { $$ = $literal_value; }
  ;

literal_value
  : LITERAL {
	SqlStatement *ret = $LITERAL;
	ret->loc = yyloc;
	if (value_STATEMENT == ret->type) {
		if ((NUMERIC_LITERAL == ret->v.value->type)
			|| (INTEGER_LITERAL == ret->v.value->type)
			|| (BOOLEAN_VALUE == ret->v.value->type)
			|| (STRING_LITERAL == ret->v.value->type)) {
			INVOKE_PARSE_LITERAL_TO_PARAMETER(parse_context, ret->v.value, FALSE);
		} else if (PARAMETER_VALUE == ret->v.value->type) {
			// ROCTO ONLY: Populate ParseContext to handle prepared statements in extended query protocol
			if (config->is_rocto && (TRUE == parse_context->is_extended_query)) {
				if (0 <= parse_context->num_bind_parms) {
					parse_context->num_bind_parms++;
					// Resize is_bind_parm array as needed
					if (parse_context->total_parms >= parse_context->is_bind_parm_size) {
						if (parse_context->total_parms > (2 * parse_context->is_bind_parm_size)) {
							// Sync is_bind_parm array size to total_parms
							EXPAND_ARRAY_ALLOCATION(parse_context->is_bind_parm,
								parse_context->is_bind_parm_size, parse_context->total_parms,
								boolean_t);
							TRACE(ERR_MEM_REALLOCATION, "expanded", "parse_context->is_bind_parm");
						}
						DOUBLE_ARRAY_ALLOCATION(parse_context->is_bind_parm,
							parse_context->is_bind_parm_size, boolean_t);
						TRACE(ERR_MEM_REALLOCATION, "doubled", "parse_context->is_bind_parm");
					}
					parse_context->is_bind_parm[parse_context->total_parms] = TRUE;
				}
				// Only track parameter offsets when binding, but skip if populating types during
				// handle_parse, in which case these members will be NULL
				if ((NULL != parse_context->parm_start) && (NULL != parse_context->parm_end)) {
					// -1 to convert parameter indexing (starts at 1) to zero-indexing for array access
					parse_context->parm_start[parse_context->num_bind_parms-1] = ret->loc.first_column;
					parse_context->parm_end[parse_context->num_bind_parms-1] = ret->loc.last_column;
				}
				INVOKE_PARSE_LITERAL_TO_PARAMETER(parse_context, ret->v.value, FALSE);
			} else if (!parse_context->abort) {
				parse_context->abort = TRUE;
				ERROR(ERR_DOLLAR_SYNTAX, "");
				yyerror(&yyloc, NULL, NULL, NULL, NULL, NULL);
			}
		}
	}
	$$ = ret;
	}

partition_by_clause
  : LEFT_PAREN PARTITION BY column_reference optional_order_by RIGHT_PAREN {
      $$ = NULL;
    }
  ;

optional_order_by
  : /* Empty */
  | ORDER BY sort_specification_list
  ;

function_definition
  : CREATE FUNCTION IDENTIFIER_START LEFT_PAREN function_parameter_type_list RIGHT_PAREN RETURNS data_type AS m_function {
	SqlStatement *type;

	SQL_STATEMENT($$, create_function_STATEMENT);
	MALLOC_STATEMENT($$, create_function, SqlFunction);
	memset(($$)->v.create_function, 0, sizeof(SqlFunction));

	($$)->v.create_function->function_name = $IDENTIFIER_START;
	($$)->v.create_function->parameter_type_list = $function_parameter_type_list;
	SQL_STATEMENT(type, data_type_STATEMENT);
	type->v.data_type = (SqlDataType)$data_type;
	($$)->v.create_function->return_type = type;
	($$)->v.create_function->extrinsic_function = $m_function;
	($$)->v.create_function->extrinsic_function->v.value->type = FUNCTION_NAME;
      }
  ;

function_parameter_type_list
  : /* Empty */ { $$ = 0; }
  |  data_type function_parameter_type_list_tail  {
	SqlParameterTypeList *parameter_type_list;
	SqlStatement *type;
	SQL_STATEMENT($$, parameter_type_list_STATEMENT);
	MALLOC_STATEMENT($$, parameter_type_list, SqlParameterTypeList);
	UNPACK_SQL_STATEMENT(parameter_type_list, $$, parameter_type_list);

	SQL_STATEMENT(type, data_type_STATEMENT);
	type->v.data_type = (SqlDataType)$data_type;
	parameter_type_list->data_type = type;
	dqinit(parameter_type_list);
	if ($function_parameter_type_list_tail) {
		assert(parameter_type_list_STATEMENT == $function_parameter_type_list_tail->type);
		dqappend(parameter_type_list, $function_parameter_type_list_tail->v.parameter_type_list);
	}
    }
  ;

function_parameter_type_list_tail
  : /* Empty */ { $$ = 0; }
  | COMMA function_parameter_type_list { $$ = $function_parameter_type_list; }
  ;

m_function
  : EXTRINSIC_FUNCTION {
		char *c;

		$$ = $EXTRINSIC_FUNCTION;
		($$)->loc = yyloc;
		/* The lexer makes it difficult to enforce the M name rule that '%' only occurs
		 * at the start of a label or routine name. Accordingly, we add an extra check
		 * here to cover the missed case where a '%' occurs in the middle of a label,
		 * e.g. $$BAD%FUNC. Note that a case like $$LABEL^BAD%FUNC is handled by the parser,
		 * which detects the '%' embedded in the routine name as an unexpected PERCENT token.
		 */
		c = ($$)->v.value->v.string_literal;
		do {
			if ('%' == *c) {
				if (('$' != *(c-1)) && ('^' != *(c-1))) {
					ERROR(ERR_PERCENT_IN_EXTRINSIC_FUNCTION_NAME, "");
					yyerror(&yyloc, NULL, NULL, NULL, NULL, NULL);
					YYABORT;
				}
			}
			c++;
		} while ('\0' != *c);
    }
  | INTRINSIC_FUNCTION {
		$$ = $INTRINSIC_FUNCTION;
		($$)->loc = yyloc;
    }
  ;

%%

{}%
/****************************************************************
 *								*
 * Copyright (c) 2019 YottaDB LLC and/or its subsidiaries.	*
 * All rights reserved.						*
 *								*
 *	This source code contains the intellectual property	*
 *	of its copyright holder(s), and is made available	*
 *	under a license.  If you do not know the terms of	*
 *	the license, please stop and do not read further.	*
 *								*
 ****************************************************************/

#include "physical_plan.h"
#include "template_helpers.h"

TEMPLATE(tmpl_tablejoin, PhysicalPlan *plan, LogicalPlan *tablejoin, unsigned int cur_key, boolean_t right_join_second_half,
								int dot_count, char *tableName, char *columnName) {
	TEMPLATE_INIT();

	SqlKey			*key, *save_key;
	unsigned int		total_keys, key_start;
	int			left_table_id, right_table_id, this_table_id;
	enum SqlJoinType	this_join_type, next_join_type;
	SqlOptionalKeyword	*limit_keyword;
	LogicalPlan		*right_tablejoin;
	boolean_t		deferred_plans_emitted, nested_call, this_join_is_left_join;

	total_keys = plan->total_iter_keys;
	assert(((NULL != tablejoin) && (LP_TABLE_JOIN == tablejoin->type)) || ((NULL == tablejoin) && (cur_key == total_keys)));
	if (cur_key < total_keys)
	{
		key = plan->iterKeys[cur_key];
		left_table_id = key->unique_id;
	}
	nested_call = FALSE;
	this_join_type = ((NULL == tablejoin) ? NO_JOIN
						: tablejoin->extra_detail.lp_table_join.cur_join_type);
	this_join_is_left_join = ((LEFT_JOIN == this_join_type) || ((FULL_JOIN == this_join_type) && !right_join_second_half));
	key_start = cur_key;
	assert(((RIGHT_JOIN != this_join_type) && (FULL_JOIN != this_join_type)) || cur_key);
	for ( ; cur_key < total_keys; cur_key++) {
		// For each key, output the key start, a FOR loop, QUIT, and increment
		key = plan->iterKeys[cur_key];
		if (key->unique_id != left_table_id)
		{	// we are done with all key columns in this table; recurse to move on to next table/key
			nested_call = TRUE;
			break;
		}
		if (this_join_is_left_join && plan->treat_key_as_null[key->unique_id])
			continue;
		// If this plan has no ORDER BY or GROUP BY, then any LIMIT usage can be safely applied right away.
		// Otherwise, we need to apply the LIMIT after the ORDER BY processing finally happens in "tmpl_physical_plan"
		//	or GROUP BY processing finally happens in "tmpl_group_by"
		limit_keyword = ((NULL == plan->order_by) && !IS_GROUP_BY_PLAN(plan))
					? get_keyword_from_keywords(plan->keywords, OPTIONAL_LIMIT)
					: NULL;
		/* If this is the second half of the right join, then treat all keys as non-fixed.
		 * And do not include cross-reference keys. Only primary-keys. This is because we want
		 * to include ALL rows from the right table for the RIGHT JOIN.
		 */
		if (key->value && !right_join_second_half) {
			TMPL(tmpl_print_dots, dot_count);
			%{}SET {}%
			TMPL(tmpl_key, key);
			%{}={}%
			TMPL(tmpl_print_expression, key->value, plan);
			%{} IF ($DATA({}%
			TMPL(tmpl_key_source, plan, key);
			%{})'=0){}%
			if (NULL != limit_keyword) {
				TMPL(tmpl_limit_check, limit_keyword, "&", ">%ydboctozlimit");
			}
			%{} DO`n{{ PLAN_LINE_START }}{}%
			dot_count++;
			continue;
		}
		if (key->is_cross_reference_key && right_join_second_half)
			continue;
		if (right_join_second_half && (NULL != key->cross_reference_output_key))
		{	/* Temporarily save cross-reference output key and clear it to generate correct key loop
			 * for second half of the right join.
			 */
			save_key = key->cross_reference_output_key;
			key->cross_reference_output_key = NULL;
		} else
			save_key = NULL;
		TMPL(tmpl_print_dots, dot_count);
		TMPL(tmpl_key_start, key);
		%{}`n{{ PLAN_LINE_START }}{}%
		TMPL(tmpl_print_dots, dot_count);
		%{}FOR  SET {}%
		TMPL(tmpl_key, key);
		%{}=$ORDER({}%
		TMPL(tmpl_key_advance, plan, key);
		%{}) QUIT:({}%
		TMPL(tmpl_key_end, key);
		%{}){}%
		if (NULL != limit_keyword) {
			TMPL(tmpl_limit_check, limit_keyword, "!", "'>%ydboctozlimit");
		}
		%{}  DO`n{{ PLAN_LINE_START }}{}%
		if (NULL != save_key)
			key->cross_reference_output_key = save_key;	/* Restore cross-reference output key */
		dot_count++;
	}
	deferred_plans_emitted = FALSE;
	// If there is an INNER/OUTER JOIN with an ON condition, generate an IF statement in M for doing the check
	if (INNER_JOIN == this_join_type) {
		LogicalPlan		*join_condition;

		join_condition = tablejoin->extra_detail.lp_table_join.join_on_condition;
		if (NULL != join_condition)
			join_condition = join_condition->v.lp_default.operand[0];
		if (NULL != join_condition) {
			TMPL(tmpl_tablejoin_deferred_plans, plan, dot_count);
			deferred_plans_emitted = TRUE;
			TMPL(tmpl_print_dots, dot_count);
			%{}IF ({}%
			TMPL(tmpl_print_expression, join_condition, plan);
			%{}) DO`n{{ PLAN_LINE_START }}{}%
			dot_count++;
		}
	}
	if (this_join_is_left_join && !plan->treat_key_as_null[left_table_id]) {
		LogicalPlan		*join_condition;

		join_condition = tablejoin->extra_detail.lp_table_join.join_on_condition;
		if (NULL != join_condition)
			join_condition = join_condition->v.lp_default.operand[0];
		if (NULL != join_condition) {
			TMPL(tmpl_tablejoin_deferred_plans, plan, dot_count);
			deferred_plans_emitted = TRUE;
			TMPL(tmpl_print_dots, dot_count);
			%{}IF ({}%
			TMPL(tmpl_print_expression, join_condition, plan);
			%{}) DO`n{{ PLAN_LINE_START }}{}%
			dot_count++;
		}
		TMPL(tmpl_print_dots, dot_count);
		%{}SET %%ydboctoz({{ key_start|%d }})=1`n{{ PLAN_LINE_START }}{}%
	}
	if ((RIGHT_JOIN == this_join_type) || (FULL_JOIN == this_join_type))
	{
		if (!right_join_second_half) {
			LogicalPlan		*join_condition;

			if (!this_join_is_left_join)
			{
				join_condition = tablejoin->extra_detail.lp_table_join.join_on_condition;
				if (NULL != join_condition)
					join_condition = join_condition->v.lp_default.operand[0];
				if (NULL != join_condition) {
					TMPL(tmpl_tablejoin_deferred_plans, plan, dot_count);
					deferred_plans_emitted = TRUE;
					TMPL(tmpl_print_dots, dot_count);
					%{}IF ({}%
					TMPL(tmpl_print_expression, join_condition, plan);
					%{}) DO`n{{ PLAN_LINE_START }}{}%
					dot_count++;
				}
			}
			/* Generate an M line to indicate a matched right table row ONLY if the current invocation of
			 * `tmpl_tablejoin` is not from the NO_MATCHING_RIGHT_TABLE_ROWS (search for occurrence below)
			 * code block. In that code block, we set `plan->treat_key_as_null[table_id]` to TRUE and we
			 * passed FALSE as `this_join_is_left_join`. So that is what we check for below.
			 */
			if (!this_join_is_left_join || !plan->treat_key_as_null[left_table_id]) {
				TMPL(tmpl_print_dots, dot_count);
				%{}SET %%ydboctoz({}%
				TMPL(tmpl_rightjoin_key, plan, key_start, cur_key);
				%{})=""`n{{ PLAN_LINE_START }}{}%
			}
		} else {
			/* Generate code for second half of RIGHT JOIN */
			/* First, if there are any cross-reference keys, generate code to set them based off the primary key.
			 * This is needed since we based the for loop for the second half of the RIGHT JOIN on the primary key
			 * only and so later references to the column corresponding to any cross-reference key for the same
			 * table need the cross-reference key value set properly (an optimization in "tmpl_column_reference"
			 * to generate the key instead of the column value relies on this).
			 */
			unsigned int	tmp_key;

			for (tmp_key = key_start; tmp_key < cur_key; tmp_key++)
			{
				key = plan->iterKeys[tmp_key];
				if (key->is_cross_reference_key)
				{
					assert(!key->skip_column_reference_optimization);
					TMPL(tmpl_print_dots, dot_count);
					%{}SET {}%
					TMPL(tmpl_key, key);
					%{}={}%
					key->skip_column_reference_optimization = TRUE;
					TMPL(tmpl_column_reference, plan, key->cross_reference_column_alias);
					key->skip_column_reference_optimization = FALSE;
					%{}`n{{ PLAN_LINE_START }}{}%
				}
			}
			TMPL(tmpl_print_dots, dot_count);
			%{}IF '$DATA(%%ydboctoz({}%
			TMPL(tmpl_rightjoin_key, plan, key_start, cur_key);
			%{})) DO`n{{ PLAN_LINE_START }}{}%
			dot_count++;
		}
	}
	if (!nested_call)
	{
		if (!deferred_plans_emitted) {
			TMPL(tmpl_tablejoin_deferred_plans, plan, dot_count);
		}
		TMPL(tmpl_tablejoin_body, plan, dot_count, tableName, columnName);
	} else {
		assert(cur_key < total_keys);
		right_tablejoin = tablejoin->v.lp_default.operand[1];
		next_join_type = right_tablejoin->extra_detail.lp_table_join.cur_join_type;
		// Treat a FULL_JOIN as a LEFT_JOIN at this stage. It will be treated as a RIGHT JOIN at a later stage.
		if (FULL_JOIN == next_join_type)
			next_join_type = LEFT_JOIN;
		if (LEFT_JOIN == next_join_type)
		{
			TMPL(tmpl_print_dots, dot_count);
			%{}SET %%ydboctoz({{ cur_key|%d }})=0`n{{ PLAN_LINE_START }}{}%
		}
		TMPL(tmpl_tablejoin, plan, right_tablejoin, cur_key, FALSE, dot_count, tableName, columnName);
		if (LEFT_JOIN == next_join_type)
		{	/* Generate M code to include rows from the left table where there is no matching right table rows
			 * (NO_MATCHING_RIGHT_TABLE_ROWS code block).
			 */
			assert(NULL != right_tablejoin->extra_detail.lp_table_join.join_on_condition);
			%{}`n{{ PLAN_LINE_START }}{}%
			TMPL(tmpl_print_dots, dot_count);
			%{}IF %%ydboctoz({{ cur_key|%d }})=0 DO`n{{ PLAN_LINE_START }}{}%
			dot_count++;
			/* Treat all keys in the right table as NULL and invoke nested joins (if needed) */
			key = plan->iterKeys[cur_key];
			right_table_id = key->unique_id;
			plan->treat_key_as_null[right_table_id] = TRUE;
			TMPL(tmpl_tablejoin, plan, right_tablejoin, cur_key, FALSE, dot_count, tableName, columnName);
			/* Undo NULL-treating of keys in right table */
			assert(plan->treat_key_as_null[right_table_id]);
			plan->treat_key_as_null[right_table_id] = FALSE;
		}
	}
	if (plan->tablejoin == tablejoin)
	{	/* This is the outermost "tmpl_tablejoin" invocation. Do additional invocation for RIGHT JOINs (if any)
		 * to include rows from the right table where there is no matching left table rows.
		 * We do that by scanning the linked list of tablejoins and finding the first tablejoin that is a RIGHT JOIN,
		 * setting all keys for prior tablejoins to be NULL and invoking "tmpl_tablejoin". And redoing this for
		 * every other RIGHT JOIN until the end of the tablejoin linked list is reached.
		 */
		LogicalPlan	*this_table_join;
		int		num_tables = 0, cur_tables;
		boolean_t	key_nullified;

		this_table_join = tablejoin;
		cur_key = 0;
		key_nullified = FALSE;
		dot_count = 0;
		do {
			assert(LP_TABLE_JOIN == this_table_join->type);
			this_join_type = this_table_join->extra_detail.lp_table_join.cur_join_type;
			if ((RIGHT_JOIN == this_join_type) || (FULL_JOIN == this_join_type))
			{	/* Set keys of all tables till now to NULL */
				assert(cur_key < total_keys);
				cur_tables = 0;
				for ( ; cur_key < total_keys; cur_key++)
				{
					this_table_id = plan->iterKeys[cur_key]->unique_id;
					if (!plan->treat_key_as_null[this_table_id])
					{
						if (cur_tables == num_tables)
							break;
						plan->treat_key_as_null[this_table_id] = TRUE;
						key_nullified = TRUE;
						cur_tables++;
					}
				}
				assert(cur_key);
				%{}`n{{ PLAN_LINE_START }}{}%
				TMPL(tmpl_tablejoin, plan, this_table_join, cur_key, TRUE, dot_count, tableName, columnName);
				num_tables = 1;	// include this table as first one for next round of RIGHT JOIN key nullification
			} else
				num_tables++;
			this_table_join = this_table_join->v.lp_default.operand[1];
		} while (NULL != this_table_join);
		if (key_nullified)
		{	/* We nullified at least one key above for a RIGHT JOIN. Undo all of those. */
			for (cur_key = 0; cur_key < total_keys; cur_key++)
			{
				this_table_id = plan->iterKeys[cur_key]->unique_id;
				plan->treat_key_as_null[this_table_id] = FALSE;
			}
		}
	}
	TEMPLATE_END();
}
%{}

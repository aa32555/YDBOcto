{}%
/****************************************************************
 *								*
 * Copyright (c) 2019-2020 YottaDB LLC and/or its subsidiaries.	*
 * All rights reserved.						*
 *								*
 *	This source code contains the intellectual property	*
 *	of its copyright holder(s), and is made available	*
 *	under a license.  If you do not know the terms of	*
 *	the license, please stop and do not read further.	*
 *								*
 ****************************************************************/

#include <assert.h>

#include "logical_plan.h"
#include "physical_plan.h"
#include "template_helpers.h"

/* Note on input parameters:
 * a) If the input parameter `dot_count` is non-zero, it implies the caller wants the M code generation to split each
 *    leaf level expression into a separate M line (to avoid generating all of them in one M line and exceeding the
 *    M max source line length limit (currently 32Kb).
 * b) The input parameter `depth` is a recursion depth indicator which is used only if `dot_count` is non-zero.
 */
TEMPLATE(tmpl_print_expression, LogicalPlan *plan, PhysicalPlan *pplan, int dot_count, int depth) {
	TEMPLATE_INIT();

	char		*m_operator, *sql_operator, *compare_operator;
	boolean_t	use_string_comparison;
	SqlValue	*value;
	SqlColumnAlias	*subquery_column_alias;
	LogicalPlan	*key, *piece_num, *cur_plan, *branch_value, *cas_value, *condition;
	LogicalPlan	*cur_branch, *default_value;
	LogicalPlan	*first_operand, *second_operand, *t_operand;
	LogicalPlan	*cur_lp_key, *derived_column;
	boolean_t	split_m_line;
	SqlValueType	coerce_type, pre_coerce_type, return_type;
	LPActionType	plan_type;
	boolean_t	is_avg;
	int		aggregate_cnt;
	PhysicalPlan	*output_pplan;
	boolean_t	stash_columns_in_keys;

	assert(NULL != plan);
	first_operand = plan->v.lp_default.operand[0];
	second_operand = plan->v.lp_default.operand[1];
	/* By default, do not split the M line. But do it only for AND or OR boolean operations as they can result in very
	 * long M lines (see #416 for example using NOT IN which translates to a sequence of AND operations). Do this only
	 * if caller has set "dot_count" to a non-zero value as that indicates the caller is okay generating split M lines.
	 * The caller in that case relies on "%ydboctobool" as the M variable that holds the boolean result.
	 */
	split_m_line = FALSE;
	depth++;
	plan_type = plan->type;
	m_operator = NULL;
	switch(plan_type) {
	case LP_WHERE:
		TMPL(tmpl_print_expression, first_operand, pplan, dot_count, depth);
		TEMPLATE_END();
		break;
	case LP_VALUE:
		value = plan->v.lp_value.value;
		switch(value->type) {
		case BOOLEAN_VALUE:
			%{}$GET({{ config->global_names.cursor }}(cursorId,"parameters",{{ value->parameter_index }})){}%
			break;
		case INTEGER_LITERAL:
			%{}($GET({{ config->global_names.cursor }}(cursorId,"parameters",{{ value->parameter_index }}))\1){}%
			break;
		case NUMERIC_LITERAL:
			%{}(+$GET({{ config->global_names.cursor }}(cursorId,"parameters",{{ value->parameter_index }}))){}%
			break;
		case PARAMETER_VALUE:
			// Fallthrough as we don't know the actual type of a PARAMETER_VALUE
		case STRING_LITERAL:
			%{}$GET({{ config->global_names.cursor }}(cursorId,"parameters",{{ value->parameter_index }})){}%
			break;
		case FUNCTION_NAME:
			%{}{{ value->v.string_literal }}{}%
			break;
		case NUL_VALUE:
			%{}$ZYSQLNULL{}%
			break;
		case COLUMN_REFERENCE:
			// We should only pass LP_COLUMN_ALIASes to this function
		default:
			assert(FALSE);
			FATAL(ERR_UNKNOWN_KEYWORD_STATE, "");
			break;
		}
		break;
	case LP_COERCE_TYPE:
		coerce_type = plan->extra_detail.lp_coerce_type.coerce_type;
		pre_coerce_type = plan->extra_detail.lp_coerce_type.pre_coerce_type;
		switch(coerce_type) {
		case BOOLEAN_VALUE:
			switch(pre_coerce_type) {
			case BOOLEAN_VALUE:
				break;
			case INTEGER_LITERAL:
				%{}$$Integer2Boolean^%%ydboctoplanhelpers({}%
				break;
			case NUMERIC_LITERAL:
				%{}$$Integer2Boolean^%%ydboctoplanhelpers({}%
				break;
			case STRING_LITERAL:
				%{}$$String2Boolean^%%ydboctoplanhelpers({}%
				break;
			case NUL_VALUE:
				break;
			default:
				break;
			}
			break;
		case INTEGER_LITERAL:
			%{}({}%
			break;
		case NUMERIC_LITERAL:
			%{}(+{}%
			break;
		case NUL_VALUE:
			break;
		case STRING_LITERAL:
			if (BOOLEAN_VALUE == pre_coerce_type) {
				%{}$$Boolean2String^%%ydboctoplanhelpers({}%
			}
			break;
		default:
			assert(FALSE);
			break;
		}
		%{}({}%
		TMPL(tmpl_print_expression, plan->v.lp_default.operand[0], pplan, dot_count, depth);
		%{}){}%
		switch(plan->extra_detail.lp_coerce_type.coerce_type) {
		case BOOLEAN_VALUE:
			switch(pre_coerce_type) {
			case INTEGER_LITERAL:
			case NUMERIC_LITERAL:
			case STRING_LITERAL:
				%{}){}%
			default:
				break;
			}
			break;
		case INTEGER_LITERAL:
			%{}\1){}%
			break;
		case NUMERIC_LITERAL:
			%{}){}%
			break;
		case NUL_VALUE:
			break;
		case STRING_LITERAL:
			if (BOOLEAN_VALUE == pre_coerce_type) {
				%{}){}%
			}
			break;
		default:
			break;
		}
		break;
	case LP_DERIVED_COLUMN:
		GET_LP(key, plan, 0, LP_KEY);
		if (pplan->treat_key_as_null[key->v.lp_key.key->unique_id])
		{	/* Treat all columns in the table as NULL (used for OUTER JOINs) */
			%{}$ZYSQLNULL{}%
			break;
		}
		subquery_column_alias = plan->extra_detail.lp_derived_column.subquery_column_alias;
		if (pplan->tablejoin_body_group_by_done && subquery_column_alias->group_by_column_number) {
			/* This column reference was specified in the GROUP BY clause and GROUP BY related processing already
			 * happened and wrote the records (based on the FROM/WHERE clauses) into the lvn subtree under
			 * GROUP_BY_SUBSCRIPT. Retrieve the column reference from there.
			 */
			%{}$$mval2str^%%ydboctoplanhelpers{}%
			%{}($$mvalPiece^%%ydboctoplanhelpers{}%
			%{}(%%ydboctog,{{ subquery_column_alias->group_by_column_number|%d }}){}%
			%{}){}%
			break;
		}
		output_pplan = get_physical_plan_from_unique_id(pplan, key->v.lp_key.key->unique_id);
		stash_columns_in_keys = ((NULL != output_pplan) && (output_pplan->stash_columns_in_keys));
		GET_LP(piece_num, plan, 1, LP_PIECE_NUMBER);
		assert(!stash_columns_in_keys || (1 == piece_num->v.lp_piece_number.piece_number));
		if (!stash_columns_in_keys) {
			%{}$$mval2str^%%ydboctoplanhelpers({}%
			%{}$$mvalPiece^%%ydboctoplanhelpers({}%
		}
		TMPL(tmpl_key, key->v.lp_key.key);
		if (!stash_columns_in_keys) {
			(*buffer_index)--;	// Go back one, removing paren
			%{},{}%
			TMPL(tmpl_key, key->v.lp_key.key);
			%{}),{{ piece_num->v.lp_piece_number.piece_number|%d }}{}%
			%{})){}%
		}
		break;
	case LP_COLUMN_ALIAS:
		/* Check if this LP_COLUMN_ALIAS was later replaced by a LP_DERIVED_COLUMN.
		 * If so generate code for the latter.
		 */
		derived_column = plan->extra_detail.lp_column_alias.derived_column;
		if (NULL != derived_column) {
			TMPL(tmpl_print_expression, derived_column, pplan, dot_count, depth);
		} else {
			TMPL(tmpl_column_reference, pplan, plan->v.lp_column_alias.column_alias, FALSE);
		}
		break;
	case LP_KEY:
		TMPL(tmpl_key, plan->v.lp_key.key);
		break;
	case LP_ADDITION:
		m_operator = "+";
		break;
	case LP_SUBTRACTION:
		m_operator = "-";
		break;
	case LP_DIVISION:
		m_operator = "/";
		break;
	case LP_MULTIPLICATION:
		m_operator = "*";
		break;
	case LP_MODULO:
		m_operator = "#";
		break;
	case LP_CONCAT:
		m_operator = "_";
		break;
	case LP_BOOLEAN_OR:
		m_operator = "!";
		split_m_line = (0 != dot_count);
		break;
	case LP_BOOLEAN_AND:
		m_operator = "&";
		split_m_line = (0 != dot_count);
		break;
	case LP_BOOLEAN_IS:
		m_operator = "=";
		break;
	case LP_BOOLEAN_EQUALS:
		m_operator = "=";
		break;
	case LP_BOOLEAN_NOT_EQUALS:
		m_operator = "'=";
		break;
	case LP_BOOLEAN_LESS_THAN:
	case LP_BOOLEAN_GREATER_THAN:
	case LP_BOOLEAN_LESS_THAN_OR_EQUALS:
	case LP_BOOLEAN_GREATER_THAN_OR_EQUALS:
		// If the arguments are strings, we need to use the M follows operator ']' as appropriate.
		use_string_comparison = lp_is_bool_operand_type_string(plan);
		if (use_string_comparison) {
			// String type. Need to use "]" or "']" operator and swap operands as needed.
			if (LP_BOOLEAN_GREATER_THAN == plan_type) {
				m_operator = "]";
			} else if (LP_BOOLEAN_LESS_THAN_OR_EQUALS == plan_type) {
				m_operator = "']";
			} else {
				// Swap operands first
				t_operand = first_operand;
				first_operand = second_operand;
				second_operand = t_operand;
				if (LP_BOOLEAN_GREATER_THAN_OR_EQUALS == plan_type) {
					m_operator = "']";
				} else
					m_operator = "]";
				}
		} else {
			// Numeric/Integer type. Easy to do <, >, <= and >= comparison.
			if (LP_BOOLEAN_LESS_THAN == plan_type) {
				m_operator = "<";
			} else if (LP_BOOLEAN_GREATER_THAN_OR_EQUALS == plan_type) {
				m_operator = "'<";
			} else if (LP_BOOLEAN_LESS_THAN_OR_EQUALS == plan_type) {
				m_operator = "'>";
			} else {
				m_operator = ">";
			}
		}
		break;
	case LP_BOOLEAN_REGEX_SENSITIVE:
	case LP_BOOLEAN_REGEX_INSENSITIVE:
	case LP_BOOLEAN_REGEX_SENSITIVE_LIKE:
	case LP_BOOLEAN_REGEX_SENSITIVE_SIMILARTO:
	case LP_BOOLEAN_REGEX_INSENSITIVE_LIKE:
	case LP_BOOLEAN_REGEX_INSENSITIVE_SIMILARTO:
		%{}$$regexmatch^%%ydboctoplanhelpers({}%
		TMPL(tmpl_print_expression, first_operand, pplan, 0, 0);
		%{},{}%
		TMPL(tmpl_print_expression, second_operand, pplan, 0, 0);
		if ((LP_BOOLEAN_REGEX_SENSITIVE_LIKE == plan_type) || (LP_BOOLEAN_REGEX_INSENSITIVE_LIKE == plan_type)) {
			%{},{{ PP_LIKE|%d }}{}%
		} else if ((LP_BOOLEAN_REGEX_SENSITIVE_SIMILARTO == plan_type)
				|| (LP_BOOLEAN_REGEX_INSENSITIVE_SIMILARTO == plan_type)) {
			%{},{{ PP_SIMILAR_TO|%d }}{}%
		} else {
			%{},{{ PP_TILDE|%d }}{}%
		}
		if ((LP_BOOLEAN_REGEX_INSENSITIVE == plan_type)
				|| (LP_BOOLEAN_REGEX_INSENSITIVE_LIKE == plan_type)
				|| (LP_BOOLEAN_REGEX_INSENSITIVE_SIMILARTO == plan_type)) {
			// The extra ',3' below marks this as case insensitive
			%{},3{}%
		}
		%{}){}%
		break;
	case LP_BOOLEAN_IN:
	case LP_BOOLEAN_NOT_IN:
		if ((LP_INSERT == second_operand->type) || (LP_SET_OPERATION == second_operand->type)) {
			/* This is IN or NOT IN used with a sub-query on the right hand side.
			 *
			 * Note that there is a NULL related subtlety that needs to be handled here.
			 *
			 * For LP_BOOLEAN_IN, if the left-hand expression yields null, or if there are no equal right-hand values
			 * and at least one right-hand expression yields null, the result of the IN construct will be null, not
			 * false.
			 *
			 * For LP_BOOLEAN_NOT_IN, if the left-hand expression yields null, or if there are no equal right-hand
			 * values and at least one right-hand expression yields null, the result of the NOT IN construct will be
			 * null, not true.
			 */
			cur_lp_key = lp_get_output_key(second_operand);
			%{}$SELECT({}%
			/* If RHS did not return any row, then result of NOT IN is TRUE */
			if (LP_BOOLEAN_NOT_IN == plan_type) {
				int	unique_id;

				unique_id = cur_lp_key->v.lp_key.key->unique_id;
				%{}(1>=$DATA(%%ydboctocursor(cursorId,"keys",{{ unique_id|%d }},"",""))):1,{}%
			}
			/* If LHS is NULL, the result is NULL */
			%{}$ZYISSQLNULL({}%
			TMPL(tmpl_print_expression, first_operand, pplan, 0, 0);
			%{}):$ZYSQLNULL,{}%
			/* Check if RHS has at least one equal value. If so use that. */
			%{}$DATA({}%
			TMPL(tmpl_key, cur_lp_key->v.lp_key.key);
			(*buffer_index)--;
			%{},{}%
			TMPL(tmpl_print_expression, first_operand, pplan, 0, 0);
			%{})){}%
			if (LP_BOOLEAN_IN == plan_type) {
				%{}:1,{}%
			} else {
				%{}:0,{}%
			}
			/* Check if at least one right-hand expression yields NULL */
			%{}$DATA({}%
			TMPL(tmpl_key, cur_lp_key->v.lp_key.key);
			(*buffer_index)--;
			%{},$ZYSQLNULL)):$ZYSQLNULL,1:{}%
			/* Now that all prior checks did not yield a definitive return value, return true/false for IN/NOT-IN */
			if (LP_BOOLEAN_IN == plan_type) {
				%{}0{}%
			} else {
				%{}1{}%
			}
			%{}){}%
		} else {
			/* This is IN or NOT IN used with a list of values on the right hand side. */

			LogicalPlan	*plan, *value;
			boolean_t	first_iteration;

			/* x IN (1,2) can be written equivalently as (x == 1) OR (x == 2)
			 * x NOT IN (1,2) can be written equivalently as (x != 1) AND (x != 2)
			 * Therefore treat LP_BOOLEAN_IN and LP_BOOLEAN_NOT_IN the same way we treat
			 * LP_BOOLEAN_AND/LP_BOOLEAN_OR in terms of "split_m_line" handling.
			 */
			split_m_line = (0 != dot_count);
			assert(LP_COLUMN_LIST == second_operand->type);
			plan = second_operand;
			if (!split_m_line) {
				/* Note: "split_m_line" could be FALSE in case IN usage is in the SELECT column list */
				%{}({}%
			} else {
				/* Initialize the M line that would have already been generated by caller ("set %ydboctobool=") */
				if (LP_BOOLEAN_IN == plan_type) {
					%{}0{}%
				} else {
					%{}1{}%
				}
			}
			first_iteration = TRUE;
			do {
				if (split_m_line) {
					%{}`n{{ PLAN_LINE_START }}{}%
					TMPL(tmpl_print_dots, dot_count);
					%{}SET %%ydboctobool=%%ydboctobool{}%
					if (LP_BOOLEAN_IN == plan_type) {
						%{}!{}%
					} else {
						%{}&{}%
					}
				} else if (!first_iteration) {
					if (LP_BOOLEAN_IN == plan_type) {
						%{}!{}%
					} else {
						%{}&{}%
					}
				}
				%{}({}%
				TMPL(tmpl_print_expression, first_operand, pplan, dot_count, depth);
				if (LP_BOOLEAN_IN == plan_type) {
					%{}={}%
				} else {
					%{}'={}%
				}
				value = plan->v.lp_default.operand[0];
				assert(LP_COLUMN_LIST != value->type);
				TMPL(tmpl_print_expression, value, pplan, dot_count, depth);
				%{}){}%
				plan = plan->v.lp_default.operand[1];
				first_iteration = FALSE;
			} while (NULL != plan);
			if (!split_m_line) {
				%{}){}%
			}
		}
		break;
	case LP_BOOLEAN_ANY_EQUALS:
	case LP_BOOLEAN_ANY_NOT_EQUALS:
	case LP_BOOLEAN_ANY_LESS_THAN:
	case LP_BOOLEAN_ANY_GREATER_THAN:
	case LP_BOOLEAN_ANY_LESS_THAN_OR_EQUALS:
	case LP_BOOLEAN_ANY_GREATER_THAN_OR_EQUALS:
	case LP_BOOLEAN_ALL_EQUALS:
	case LP_BOOLEAN_ALL_NOT_EQUALS:
	case LP_BOOLEAN_ALL_LESS_THAN:
	case LP_BOOLEAN_ALL_GREATER_THAN:
	case LP_BOOLEAN_ALL_LESS_THAN_OR_EQUALS:
	case LP_BOOLEAN_ALL_GREATER_THAN_OR_EQUALS:
		assert((LP_INSERT == second_operand->type) || (LP_SET_OPERATION == second_operand->type));
		// Fetch the second value from the output key of this query/table
		key = lp_get_output_key(second_operand);
		switch(plan_type) {
		case LP_BOOLEAN_ANY_EQUALS:
			compare_operator = "=";
			sql_operator = "ANY";
			break;
		case LP_BOOLEAN_ANY_NOT_EQUALS:
			compare_operator = "'=";
			sql_operator = "ANY";
			break;
		case LP_BOOLEAN_ANY_LESS_THAN:
			compare_operator = "<";
			sql_operator = "ANY";
			break;
		case LP_BOOLEAN_ANY_GREATER_THAN:
			compare_operator = ">";
			sql_operator = "ANY";
			break;
		case LP_BOOLEAN_ANY_LESS_THAN_OR_EQUALS:
			compare_operator = "<=";
			sql_operator = "ANY";
			break;
		case LP_BOOLEAN_ANY_GREATER_THAN_OR_EQUALS:
			compare_operator = ">=";
			sql_operator = "ANY";
			break;
		case LP_BOOLEAN_ALL_EQUALS:
			compare_operator = "=";
			sql_operator = "ALL";
			break;
		case LP_BOOLEAN_ALL_NOT_EQUALS:
			compare_operator = "'=";
			sql_operator = "ALL";
			break;
		case LP_BOOLEAN_ALL_LESS_THAN:
			compare_operator = "<";
			sql_operator = "ALL";
			break;
		case LP_BOOLEAN_ALL_GREATER_THAN:
			compare_operator = ">";
			sql_operator = "ALL";
			break;
		case LP_BOOLEAN_ALL_LESS_THAN_OR_EQUALS:
			compare_operator = "<=";
			sql_operator = "ALL";
			break;
		default:
			assert(LP_BOOLEAN_ALL_GREATER_THAN_OR_EQUALS == plan_type);
			compare_operator = ">=";
			sql_operator = "ALL";
			break;
		}
		use_string_comparison = lp_is_bool_operand_type_string(plan);
		%{}$${{ sql_operator }}^%%ydboctoplanhelpers({}%
		TMPL(tmpl_print_expression, first_operand, pplan, 0, 0);
		%{},{{ key->v.lp_key.key->unique_id|%d }},"{{ compare_operator }}",{{ use_string_comparison|%d }}){}%
		break;
	case LP_FORCE_NUM:
		%{}+{}%
		TMPL(tmpl_print_expression, first_operand, pplan, 0, 0);
		break;
	case LP_NEGATIVE:
		%{}-{}%
		TMPL(tmpl_print_expression, first_operand, pplan, 0, 0);
		break;
	case LP_BOOLEAN_NOT:
		%{}'{}%
		TMPL(tmpl_print_expression, first_operand, pplan, 0, 0);
		break;
	case LP_BOOLEAN_EXISTS:
	case LP_BOOLEAN_NOT_EXISTS:
		assert((LP_INSERT == first_operand->type) || (LP_SET_OPERATION == first_operand->type));
		// Fetch the first value from the output key of this query/table
		key = lp_get_output_key(first_operand);
		if (LP_BOOLEAN_NOT_EXISTS == plan_type) {
			%{}'{}%
		}
		%{}$$EXISTS^%%ydboctoplanhelpers({{ key->v.lp_key.key->unique_id|%d }}){}%
		break;
	case LP_BOOLEAN_IS_NULL:
	case LP_BOOLEAN_IS_NOT_NULL:
		if (LP_BOOLEAN_IS_NOT_NULL == plan_type) {
			%{}'{}%
		}
		%{}$ZYISSQLNULL({}%
		TMPL(tmpl_print_expression, first_operand, pplan, 0, 0);
		%{}){}%
		break;
	case LP_COALESCE_CALL:
		/* first_operand is a LP_COLUMN_LIST, but we want to get the first LP_COLUMN_VALUE */
		cur_plan = first_operand->v.lp_default.operand[1];
		/* TODO: this might break the `if` after the switch, we should use a new variable instead */
		first_operand = first_operand->v.lp_default.operand[0];
		%{}$SELECT('$ZYISSQLNULL({}%
		TMPL(tmpl_print_expression, first_operand, pplan, 0, 0);
		%{}):{}%
		TMPL(tmpl_print_expression, first_operand, pplan, 0, 0);
		%{},{}%
		while (NULL != cur_plan) {
			%{}'$ZYISSQLNULL({}%
			TMPL(tmpl_print_expression, cur_plan->v.lp_default.operand[0], pplan, 0, 0);
			%{}):{}%
			TMPL(tmpl_print_expression, cur_plan->v.lp_default.operand[0], pplan, 0, 0);
			%{},{}%
			cur_plan = cur_plan->v.lp_default.operand[1];
		}
		%{}1:$ZYSQLNULL){}%
		break;
	case LP_FUNCTION_CALL:
		/* As noted in lp_generate_where.c, the first_operand here is the SQL function name, which is not needed during
		 * physical planning. Hence, we skip ignore that node in the tree and use only second_operand, which is the node
		 * containing the relevant extrinsic function call.
		 */
		assert(NULL != second_operand);
		/* The SqlFunctionCall argument list begins after the return type, which occurs after the extrinsic function node.
		 * Accordingly, initialize cur_plan for iteration starting from the return type node instead of the parent extrinsic
		 * function node, using t_operand to store this for convenience.
		 */
		t_operand = second_operand->v.lp_default.operand[1];
		cur_plan = t_operand;
		// Check for a BOOLEAN return type. If so, convert any string values to 0/1 in the generated plan.
		return_type = t_operand->v.lp_default.operand[0]->v.lp_value.value->type;
		if (BOOLEAN_VALUE == return_type) {
			%{}$$String2Boolean^%%ydboctoplanhelpers({}%
		}
		%{}{}%
		TMPL(tmpl_print_expression, second_operand->v.lp_default.operand[0], pplan, 0, 0);
		%{}({}%
		while (NULL != cur_plan->v.lp_default.operand[1]) {
			if (cur_plan != t_operand) {
				%{},{}%
			}
			cur_plan = cur_plan->v.lp_default.operand[1];
			TMPL(tmpl_print_expression, cur_plan->v.lp_default.operand[0], pplan, 0, 0);
		}
		%{}){}%
		if (BOOLEAN_VALUE == return_type) {
			%{}){}%
		}
		break;
	case LP_AGGREGATE_FUNCTION_COUNT_ASTERISK:
	case LP_AGGREGATE_FUNCTION_COUNT:
	case LP_AGGREGATE_FUNCTION_MIN:
	case LP_AGGREGATE_FUNCTION_MAX:
	case LP_AGGREGATE_FUNCTION_SUM:
	case LP_AGGREGATE_FUNCTION_COUNT_DISTINCT:
	case LP_AGGREGATE_FUNCTION_SUM_DISTINCT:
	case LP_AGGREGATE_FUNCTION_AVG:
	case LP_AGGREGATE_FUNCTION_AVG_DISTINCT:
		/* Note that the GROUP_BY_SUBSCRIPT node might not exist in case all values aggregated were NULL.
		 * Hence the need for $GET.
		 */
		%{}$GET({}%
		TMPL(tmpl_key, pplan->outputKey);
		(*buffer_index)--;
		assert(plan->extra_detail.lp_aggregate_function.aggregate_cnt);
		aggregate_cnt = plan->extra_detail.lp_aggregate_function.aggregate_cnt;
		is_avg = ((LP_AGGREGATE_FUNCTION_AVG == plan_type) || (LP_AGGREGATE_FUNCTION_AVG_DISTINCT == plan_type));
		/* AVG is slightly different from other aggregate functions in that the actual average is not stored anywhere
		 * yet. Only the cumulative sum and cumulative count are stored (in `Avg` or `AvgDistinct` labels in
		 * `src/aux/_ydboctoplanhelpers.m`). So generate code that computes the average using the stored quantities.
		 */
		if (is_avg) {
			/* In case of AVG function, the SUM and COUNT are stored separately so use that to find the AVG.
			 * The SUM and COUNT are stored in a negative subscript so do the negation here.
			 */
			aggregate_cnt = - aggregate_cnt;
		}
		%{},{{ GROUP_BY_SUBSCRIPT }},%%ydboctog,{{ aggregate_cnt|%d }}{}%
		if (is_avg) {
			%{},"SUM"{}%
		}
		%{}),{}%
		/* In case no rows exist, set default value of 0 for COUNT and NULL for AVG/SUM/MIN/MAX.
		 * Similar code exists in "tmpl_group_by.ctemplate".
		 */
		switch(plan_type) {
		case LP_AGGREGATE_FUNCTION_MIN:
		case LP_AGGREGATE_FUNCTION_MAX:
		case LP_AGGREGATE_FUNCTION_SUM:
		case LP_AGGREGATE_FUNCTION_SUM_DISTINCT:
		case LP_AGGREGATE_FUNCTION_AVG:
		case LP_AGGREGATE_FUNCTION_AVG_DISTINCT:
			%{}$ZYSQLNULL{}%
			break;
		default:
			assert((LP_AGGREGATE_FUNCTION_COUNT_ASTERISK == plan_type)
				|| (LP_AGGREGATE_FUNCTION_COUNT == plan_type)
				|| (LP_AGGREGATE_FUNCTION_COUNT_DISTINCT == plan_type));
			%{}0{}%
			break;
		}
		%{}){}%
		if (is_avg) {
			%{}/{}%
			%{}$GET({}%
			TMPL(tmpl_key, pplan->outputKey);
			(*buffer_index)--;
			%{},{{ GROUP_BY_SUBSCRIPT }},%%ydboctog,{{ aggregate_cnt|%d }},"COUNT"){}%
			%{},1){}%
		}
		break;
	case LP_INSERT:
	case LP_SET_OPERATION:
		// Fetch the first value from the output key of this query/table
		key = lp_get_output_key(plan);
		%{}$$GetScalar^%%ydboctoplanhelpers({{ key->v.lp_key.key->unique_id|%d }}){}%
		break;
	case LP_CASE:
		%{}$SELECT({}%
		GET_LP(cur_plan, plan, 0, LP_CASE_STATEMENT);
		cas_value = cur_plan->v.lp_default.operand[0];
		default_value = cur_plan->v.lp_default.operand[1];
		GET_LP(cur_plan, plan, 1, LP_CASE_BRANCH);
		while (NULL != cur_plan) {
			GET_LP(cur_branch, cur_plan, 0, LP_CASE_BRANCH_STATEMENT);
			condition = cur_branch->v.lp_default.operand[0];
			branch_value = cur_branch->v.lp_default.operand[1];
			%{}({}%
			TMPL(tmpl_print_expression, condition, pplan, 0, 0);
			%{})=({}%
			if (NULL != cas_value) {
				TMPL(tmpl_print_expression, cas_value, pplan, 0, 0);
			} else {
				%{}1{}%
			}
			%{}):({}%
			TMPL(tmpl_print_expression, branch_value, pplan, 0, 0);
			%{}),{}%
			cur_plan = cur_plan->v.lp_default.operand[1];
		}
		if (NULL != default_value) {
			%{}1:{}%
			TMPL(tmpl_print_expression, default_value, pplan, 0, 0);
			%{}){}%
		} else {
			%{}1:$ZYSQLNULL){}%
		}
		break;
	default:
		assert(FALSE);
		FATAL(ERR_UNKNOWN_KEYWORD_STATE, "");
	}
	if (m_operator) {
		if (split_m_line) {
			/* Evaluate left hand side of boolean AND or OR */
			TMPL(tmpl_print_expression, first_operand, pplan, dot_count, depth);
			%{}`n{{ PLAN_LINE_START }}{}%
			TMPL(tmpl_print_dots, dot_count);
			/* Move result into temporary variable (using recursion "depth" to avoid interference from M code generated
			 * by next "tmpl_print_expression" call which evaluates right side of boolean AND or OR).
			 */
			%{}SET %%ydboctobool({{ depth|%d }})=%%ydboctobool{}%
			/* Evaluate right hand side of boolean AND or OR */
			%{}`n{{ PLAN_LINE_START }}{}%
			TMPL(tmpl_print_dots, dot_count);
			%{}SET %%ydboctobool={}%
			TMPL(tmpl_print_expression, second_operand, pplan, dot_count, depth);
			/* Evaluate result of boolean AND or OR */
			%{}`n{{ PLAN_LINE_START }}{}%
			TMPL(tmpl_print_dots, dot_count);
			%{}SET %%ydboctobool=%%ydboctobool({{ depth|%d }}){{ m_operator }}%%ydboctobool{}%
		} else {
			%{}({}%
			TMPL(tmpl_print_expression, first_operand, pplan, 0, 0);
			%{}{{ m_operator }}{}%
			TMPL(tmpl_print_expression, second_operand, pplan, 0, 0);
			%{}){}%
		}
	}
	TEMPLATE_END();
}
%{}

{}%
/****************************************************************
 *								*
 * Copyright (c) 2019 YottaDB LLC and/or its subsidiaries.	*
 * All rights reserved.						*
 *								*
 *	This source code contains the intellectual property	*
 *	of its copyright holder(s), and is made available	*
 *	under a license.  If you do not know the terms of	*
 *	the license, please stop and do not read further.	*
 *								*
 ****************************************************************/

#include <assert.h>

#include "logical_plan.h"
#include "physical_plan.h"
#include "template_helpers.h"

TEMPLATE(tmpl_print_expression, LogicalPlan *plan, PhysicalPlan *pplan) {
	TEMPLATE_INIT();

	char		*m_operator = NULL, *sql_operator, *compare_operator;
	boolean_t	use_string_comparison;
	SqlValue	*value;
	LogicalPlan	*key, *piece_num, *cur_plan, *branch_value, *cas_value, *condition;
	LogicalPlan	*cur_branch, *default_value;
	LogicalPlan	*first_operand, *second_operand, *t_operand;

	assert(NULL != plan);
	first_operand = plan->v.operand[0];
	second_operand = plan->v.operand[1];

	switch(plan->type) {
	case LP_WHERE:
		TMPL(tmpl_print_expression, first_operand, pplan);
		TEMPLATE_END();
		break;
	case LP_VALUE:
		value = plan->v.value;
		switch(value->type) {
		case BOOLEAN_VALUE:
			// Handle case where LP_BOOLEAN_REGEX* gets optimized
			if (NULL == value->parameter_index) {
				%{}"1"{}%
			} else {
				%{}$GET({{ config->global_names.cursor }}(cursorId,"parameters",{{ value->parameter_index }})){}%
			}
			break;
		case STRING_LITERAL:
			%{}$GET({{ config->global_names.cursor }}(cursorId,"parameters",{{ value->parameter_index }})){}%
			break;
		case NUMERIC_LITERAL:
			%{}+$GET({{ config->global_names.cursor }}(cursorId,"parameters",{{ value->parameter_index }})){}%
			break;
		case COLUMN_REFERENCE:
			// We should only pass LP_COLUMN_ALIASes to this function
			assert(FALSE);
			break;
		case FUNCTION_NAME:
			%{}{{ value->v.string_literal }}{}%
			break;
		case PARAMETER_VALUE:
			%{}parm{{ value->v.string_literal + 1 }}{}%
			break;
		case NUL_VALUE:
			%{}""{}%
			break;
		case INTEGER_LITERAL:
			%{}$GET({{ config->global_names.cursor }}(cursorId,"parameters",{{ value->parameter_index }}))\1{}%
			break;
		default:
			FATAL(ERR_UNKNOWN_KEYWORD_STATE, "");
		}
		break;
	case LP_DERIVED_COLUMN:
		GET_LP(key, plan, 0, LP_KEY);
		if (pplan->treat_key_as_null[key->v.key->unique_id])
		{   /* Treat all columns in the table as NULL (used for OUTER JOINs) */
			%{}""{}%	/* needs to be replaced with $ZYSQLNULL when #311 is fixed */
		break;
		}
		GET_LP(piece_num, plan, 1, LP_PIECE_NUMBER);
		%{}($PIECE({}%
		TMPL(tmpl_key, key->v.key);
		// We're getting a bit abusive again; go back one, removing paren, comma and print
		(*buffer_index)--;
		%{},{}%
		TMPL(tmpl_key, key->v.key);
		%{}),"|",{{ piece_num->v.piece_number|%d }})){}%
		break;
	case LP_COLUMN_ALIAS:
		TMPL(tmpl_column_reference, pplan, plan->v.column_alias);
		break;
	case LP_KEY:
		TMPL(tmpl_key, plan->v.key);
		break;
	case LP_ADDITION:
		m_operator = "+";
		break;
	case LP_SUBTRACTION:
		m_operator = "-";
		break;
	case LP_DIVISION:
		m_operator = "/";
		break;
	case LP_MULTIPLICATION:
		m_operator = "*";
		break;
	case LP_MODULO:
		m_operator = "#";
		break;
	case LP_CONCAT:
		m_operator = "_";
		break;
	case LP_BOOLEAN_OR:
		m_operator = "!";
		break;
	case LP_BOOLEAN_AND:
		m_operator = "&";
		break;
	case LP_BOOLEAN_IS:
		m_operator = "=";
		break;
	case LP_BOOLEAN_EQUALS:
		m_operator = "=";
		break;
	case LP_BOOLEAN_NOT_EQUALS:
		m_operator = "'=";
		break;
	case LP_BOOLEAN_LESS_THAN:
	case LP_BOOLEAN_GREATER_THAN:
	case LP_BOOLEAN_LESS_THAN_OR_EQUALS:
	case LP_BOOLEAN_GREATER_THAN_OR_EQUALS:
		// If the arguments are strings, we need to use the M follows operator ']' as appropriate.
		use_string_comparison = lp_is_bool_operand_type_string(plan);
		if (use_string_comparison) {
			// String type. Need to use "]" or "']" operator and swap operands as needed.
			if (LP_BOOLEAN_GREATER_THAN == plan->type) {
				m_operator = "]";
			} else if (LP_BOOLEAN_LESS_THAN_OR_EQUALS == plan->type) {
				m_operator = "']";
			} else {
				// Swap operands first
				t_operand = first_operand;
				first_operand = second_operand;
				second_operand = t_operand;
				if (LP_BOOLEAN_GREATER_THAN_OR_EQUALS == plan->type) {
					m_operator = "']";
				} else
					m_operator = "]";
				}
		} else {
			// Numeric/Integer type. Easy to do <, >, <= and >= comparison.
			if (LP_BOOLEAN_LESS_THAN == plan->type) {
				m_operator = "<";
			} else if (LP_BOOLEAN_GREATER_THAN_OR_EQUALS == plan->type) {
				m_operator = "'<";
			} else if (LP_BOOLEAN_LESS_THAN_OR_EQUALS == plan->type) {
				m_operator = "'>";
			} else {
				m_operator = ">";
			}
		}
		break;
	case LP_BOOLEAN_REGEX_SENSITIVE:
		%{}$$regmatch^%%ydbposix({}%
		TMPL(tmpl_print_expression, first_operand, pplan);
		%{},{}%
		TMPL(tmpl_print_expression, second_operand, pplan);
		%{}){}%
		break;
	case LP_BOOLEAN_REGEX_INSENSITIVE:
		// The extra ',3' below marks this as case insensitive
		%{}$$regmatch^%%ydbposix({}%
		TMPL(tmpl_print_expression, first_operand, pplan);
		%{},{}%
		TMPL(tmpl_print_expression, second_operand, pplan);
		%{},3){}%
		break;
	case LP_BOOLEAN_IN:
	case LP_BOOLEAN_NOT_IN:
		// IN expressions require a key; we would have resolved the keys already in `generate_physical_plan.c`
		//  so enforce that the search list is a key to search in.
		assert(LP_KEY == second_operand->type);
		%{}($DATA({}%
		TMPL(tmpl_key, second_operand->v.key);
		(*buffer_index)--;
		%{},{}%
		TMPL(tmpl_print_expression, first_operand, pplan);
		if (LP_BOOLEAN_IN == plan->type) {
			%{}))'=0){}%
		} else {
			%{}))=0){}%
		}
		break;
	case LP_BOOLEAN_ANY_EQUALS:
	case LP_BOOLEAN_ANY_NOT_EQUALS:
	case LP_BOOLEAN_ANY_LESS_THAN:
	case LP_BOOLEAN_ANY_GREATER_THAN:
	case LP_BOOLEAN_ANY_LESS_THAN_OR_EQUALS:
	case LP_BOOLEAN_ANY_GREATER_THAN_OR_EQUALS:
	case LP_BOOLEAN_ALL_EQUALS:
	case LP_BOOLEAN_ALL_NOT_EQUALS:
	case LP_BOOLEAN_ALL_LESS_THAN:
	case LP_BOOLEAN_ALL_GREATER_THAN:
	case LP_BOOLEAN_ALL_LESS_THAN_OR_EQUALS:
	case LP_BOOLEAN_ALL_GREATER_THAN_OR_EQUALS:
		assert((LP_INSERT == second_operand->type) || (LP_SET_OPERATION == second_operand->type));
		// Fetch the second value from the output key of this query/table
		key = lp_get_output_key(second_operand);
		switch(plan->type) {
		case LP_BOOLEAN_ANY_EQUALS:
			compare_operator = "=";
			sql_operator = "ANY";
			break;
		case LP_BOOLEAN_ANY_NOT_EQUALS:
			compare_operator = "'=";
			sql_operator = "ANY";
			break;
		case LP_BOOLEAN_ANY_LESS_THAN:
			compare_operator = "<";
			sql_operator = "ANY";
			break;
		case LP_BOOLEAN_ANY_GREATER_THAN:
			compare_operator = ">";
			sql_operator = "ANY";
			break;
		case LP_BOOLEAN_ANY_LESS_THAN_OR_EQUALS:
			compare_operator = "<=";
			sql_operator = "ANY";
			break;
		case LP_BOOLEAN_ANY_GREATER_THAN_OR_EQUALS:
			compare_operator = ">=";
			sql_operator = "ANY";
			break;
		case LP_BOOLEAN_ALL_EQUALS:
			compare_operator = "=";
			sql_operator = "ALL";
			break;
		case LP_BOOLEAN_ALL_NOT_EQUALS:
			compare_operator = "'=";
			sql_operator = "ALL";
			break;
		case LP_BOOLEAN_ALL_LESS_THAN:
			compare_operator = "<";
			sql_operator = "ALL";
			break;
		case LP_BOOLEAN_ALL_GREATER_THAN:
			compare_operator = ">";
			sql_operator = "ALL";
			break;
		case LP_BOOLEAN_ALL_LESS_THAN_OR_EQUALS:
			compare_operator = "<=";
			sql_operator = "ALL";
			break;
		case LP_BOOLEAN_ALL_GREATER_THAN_OR_EQUALS:
			compare_operator = ">=";
			sql_operator = "ALL";
			break;
		default:
			assert(FALSE);
			break;
		}
		use_string_comparison = lp_is_bool_operand_type_string(plan);
		%{}$${{ sql_operator }}^%%ydboctoplanhelpers({}%
		TMPL(tmpl_print_expression, first_operand, pplan);
		%{},{{ key->v.key->unique_id|%d }},"{{ compare_operator }}",{{ use_string_comparison|%d }}){}%
		break;
	case LP_FORCE_NUM:
		%{}+{}%
		TMPL(tmpl_print_expression, first_operand, pplan);
		break;
	case LP_NEGATIVE:
		%{}-{}%
		TMPL(tmpl_print_expression, first_operand, pplan);
		break;
	case LP_BOOLEAN_NOT:
		%{}'{}%
		TMPL(tmpl_print_expression, first_operand, pplan);
		break;
	case LP_BOOLEAN_EXISTS:
	case LP_BOOLEAN_NOT_EXISTS:
		assert((LP_INSERT == first_operand->type) || (LP_SET_OPERATION == first_operand->type));
		// Fetch the first value from the output key of this query/table
		key = lp_get_output_key(first_operand);
		if (LP_BOOLEAN_NOT_EXISTS == plan->type) {
			%{}'{}%
		}
		%{}$$EXISTS^%%ydboctoplanhelpers({{ key->v.key->unique_id|%d }}){}%
		break;
	case LP_FUNCTION_CALL:
		cur_plan = plan;
		%{}{}%
		TMPL(tmpl_print_expression, first_operand, pplan);
		%{}({}%
		while (NULL != cur_plan->v.operand[1]) {
			if (cur_plan != plan) {
				%{},{}%
			}
			cur_plan = cur_plan->v.operand[1];
			TMPL(tmpl_print_expression, cur_plan->v.operand[0], pplan);
		}
		%{}){}%
		break;
	case LP_INSERT:
	case LP_SET_OPERATION:
		// Fetch the first value from the output key of this query/table
		key = lp_get_output_key(plan);
		%{}$$GetScalar^%%ydboctoplanhelpers({{ key->v.key->unique_id|%d }}){}%
		break;
	case LP_CASE:
		%{}$SELECT({}%
		GET_LP(cur_plan, plan, 0, LP_CASE_STATEMENT);
		cas_value = cur_plan->v.operand[0];
		default_value = cur_plan->v.operand[1];
		GET_LP(cur_plan, plan, 1, LP_CASE_BRANCH);
		while (NULL != cur_plan) {
			GET_LP(cur_branch, cur_plan, 0, LP_CASE_BRANCH_STATEMENT);
			condition = cur_branch->v.operand[0];
			branch_value = cur_branch->v.operand[1];
			%{}({}%
			TMPL(tmpl_print_expression, condition, pplan);
			%{})=({}%
			if (NULL != cas_value) {
				TMPL(tmpl_print_expression, cas_value, pplan);
			} else {
				%{}1{}%
			}
			%{}):({}%
			TMPL(tmpl_print_expression, branch_value, pplan);
			%{}),{}%
			cur_plan = cur_plan->v.operand[1];
		}
		if (NULL != default_value) {
			%{}1:{}%
			TMPL(tmpl_print_expression, default_value, pplan);
			%{}){}%
		} else {
			%{}1:""){}%
		}
		break;
	default:
		assert(FALSE);
		FATAL(ERR_UNKNOWN_KEYWORD_STATE, "");
	}
	if (m_operator) {
		%{}({}%
		TMPL(tmpl_print_expression, first_operand, pplan);
		%{}{{ m_operator }}{}%
		TMPL(tmpl_print_expression, second_operand, pplan);
		%{}){}%
	}
	TEMPLATE_END();
}
%{}

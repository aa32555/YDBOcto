{}%
/****************************************************************
 *								*
 * Copyright (c) 2019-2020 YottaDB LLC and/or its subsidiaries.	*
 * All rights reserved.						*
 *								*
 *	This source code contains the intellectual property	*
 *	of its copyright holder(s), and is made available	*
 *	under a license.  If you do not know the terms of	*
 *	the license, please stop and do not read further.	*
 *								*
 ****************************************************************/

#include <assert.h>

#include "logical_plan.h"
#include "physical_plan.h"
#include "template_helpers.h"

/* Note on input parameters:
 * a) If the input parameter `dot_count` is non-zero, it implies the caller wants the M code generation to split each
 *    leaf level expression into a separate M line (to avoid generating all of them in one M line and exceeding the
 *    M max source line length limit (currently 32Kb).
 * b) The input parameter `depth` is a recursion depth indicator which is used only if `dot_count` is non-zero.
 */
TEMPLATE(tmpl_print_expression, LogicalPlan *plan, PhysicalPlan *pplan, int dot_count, int depth) {
	TEMPLATE_INIT();

	char		*m_operator = NULL, *sql_operator, *compare_operator;
	boolean_t	use_string_comparison;
	SqlValue	*value;
	SqlColumnAlias	*subquery_column_alias;
	LogicalPlan	*key, *piece_num, *cur_plan, *branch_value, *cas_value, *condition;
	LogicalPlan	*cur_branch, *default_value;
	LogicalPlan	*first_operand, *second_operand, *t_operand;
	LogicalPlan	*cur_lp_key, *derived_column;
	boolean_t	split_m_line;
	SqlValueType	coerce_type, pre_coerce_type;
	LPActionType	plan_type;
	boolean_t	is_avg;
	int		aggregate_cnt;

	assert(NULL != plan);
	first_operand = plan->v.lp_default.operand[0];
	second_operand = plan->v.lp_default.operand[1];
	/* By default, do not split the M line. But do it only for AND or OR boolean operations as they can result in very
	 * long M lines (see #416 for example using NOT IN which translates to a sequence of AND operations). Do this only
	 * if caller has set "dot_count" to a non-zero value as that indicates the caller is okay generating split M lines.
	 * The caller in that case relies on "%ydboctobool" as the M variable that holds the boolean result.
	 */
	split_m_line = FALSE;
	depth++;
	plan_type = plan->type;
	switch(plan_type) {
	case LP_WHERE:
		TMPL(tmpl_print_expression, first_operand, pplan, dot_count, depth);
		TEMPLATE_END();
		break;
	case LP_VALUE:
		value = plan->v.lp_value.value;
		switch(value->type) {
		case BOOLEAN_VALUE:
			%{}$GET({{ config->global_names.cursor }}(cursorId,"parameters",{{ value->parameter_index }})){}%
			break;
		/* NOTE: For the INTEGER_LITERAL and NUMERIC_LITERAL case, one might be tempted to typecast the result
		 * (like indicated in the commented lines for the respective `case` blocks below). But one should not
		 * do that until $ZYSQLNULL (YottaDB/DBMS/YDBOcto/issues/311 which in turn depends YottaDB/DB/YDB/issues/484)
		 * is fully implemented. See https://gitlab.com/YottaDB/DBMS/YDBOcto/issues/235#note_217262044 for more details.
		 * Hence INTEGER_LITERAL/NUMERIC_LITERAL/STRING_LITERAL all fall through to the same case block for now.
		 */
		case INTEGER_LITERAL:
			// Below line is commented until #311 is fixed (see above comment for details)
			// %{}$GET({{ config->global_names.cursor }}(cursorId,"parameters",{{ value->parameter_index }}))\1{}%
		case NUMERIC_LITERAL:
			// Below line is commented until #311 is fixed (see above comment for details)
			// %{}+$GET({{ config->global_names.cursor }}(cursorId,"parameters",{{ value->parameter_index }})){}%
		case PARAMETER_VALUE:
			// Fallthrough as we don't know the actual type of a PARAMETER_VALUE
		case STRING_LITERAL:
			%{}$GET({{ config->global_names.cursor }}(cursorId,"parameters",{{ value->parameter_index }})){}%
			break;
		case FUNCTION_NAME:
			%{}{{ value->v.string_literal }}{}%
			break;
		case NUL_VALUE:
			%{}$ZYSQLNULL{}%
			break;
		case COLUMN_REFERENCE:
			// We should only pass LP_COLUMN_ALIASes to this function
		default:
			assert(FALSE);
			FATAL(ERR_UNKNOWN_KEYWORD_STATE, "");
			break;
		}
		break;
	case LP_COERCE_TYPE:
		coerce_type = plan->extra_detail.lp_coerce_type.coerce_type;
		pre_coerce_type = plan->extra_detail.lp_coerce_type.pre_coerce_type;
		switch(coerce_type) {
		case BOOLEAN_VALUE:
			switch(pre_coerce_type) {
			case BOOLEAN_VALUE:
				break;
			case INTEGER_LITERAL:
				%{}$$Integer2Boolean^%%ydboctoplanhelpers({}%
				break;
			case NUMERIC_LITERAL:
				%{}$$Integer2Boolean^%%ydboctoplanhelpers({}%
				break;
			case STRING_LITERAL:
				%{}$$String2Boolean^%%ydboctoplanhelpers({}%
				break;
			case NUL_VALUE:
				/* Need to address it as part of YDBOcto#311 */
				break;
			default:
				break;
			}
			break;
		case INTEGER_LITERAL:
			%{}({}%
			break;
		case NUMERIC_LITERAL:
			%{}(+{}%
			break;
		case NUL_VALUE:
			break;
		case STRING_LITERAL:
			if (BOOLEAN_VALUE == pre_coerce_type) {
				%{}$$Boolean2String^%%ydboctoplanhelpers({}%
			}
			break;
		default:
			assert(FALSE);
			break;
		}
		%{}({}%
		TMPL(tmpl_print_expression, plan->v.lp_default.operand[0], pplan, dot_count, depth);
		%{}){}%
		switch(plan->extra_detail.lp_coerce_type.coerce_type) {
		case BOOLEAN_VALUE:
			switch(pre_coerce_type) {
			case INTEGER_LITERAL:
			case NUMERIC_LITERAL:
			case STRING_LITERAL:
				%{}){}%
			default:
				break;
			}
			break;
		case INTEGER_LITERAL:
			%{}\1){}%
			break;
		case NUMERIC_LITERAL:
			%{}){}%
			break;
		case NUL_VALUE:
			break;
		case STRING_LITERAL:
			if (BOOLEAN_VALUE == pre_coerce_type) {
				%{}){}%
			}
			break;
		default:
			break;
		}
		break;
	case LP_DERIVED_COLUMN:
		GET_LP(key, plan, 0, LP_KEY);
		if (pplan->treat_key_as_null[key->v.lp_key.key->unique_id])
		{	/* Treat all columns in the table as NULL (used for OUTER JOINs) */
			%{}$ZYSQLNULL{}%
			break;
		}
		subquery_column_alias = plan->extra_detail.lp_derived_column.subquery_column_alias;
		if (pplan->tablejoin_body_group_by_done && subquery_column_alias->group_by_column_number) {
			/* This column reference was specified in the GROUP BY clause and GROUP BY related processing already
			 * happened and wrote the records (based on the FROM/WHERE clauses) into the lvn subtree under
			 * GROUP_BY_SUBSCRIPT. Retrieve the column reference from there.
			 */
			%{}$$mval2str^%%ydboctoplanhelpers{}%
			%{}($$mvalPiece^%%ydboctoplanhelpers{}%
			%{}(%%ydboctog,{{ subquery_column_alias->group_by_column_number|%d }}){}%
			%{}){}%
			break;
		}
		GET_LP(piece_num, plan, 1, LP_PIECE_NUMBER);
		%{}$$mval2str^%%ydboctoplanhelpers{}%
		%{}($$mvalPiece^%%ydboctoplanhelpers({}%
		TMPL(tmpl_key, key->v.lp_key.key);
		(*buffer_index)--;	// Go back one, removing paren
		%{},{}%
		TMPL(tmpl_key, key->v.lp_key.key);
		%{}),{{ piece_num->v.lp_piece_number.piece_number|%d }}){}%
		%{}){}%
		break;
	case LP_COLUMN_ALIAS:
		/* Check if this LP_COLUMN_ALIAS was later replaced by a LP_DERIVED_COLUMN.
		 * If so generate code for the latter.
		 */
		derived_column = plan->extra_detail.lp_column_alias.derived_column;
		if (NULL != derived_column) {
			TMPL(tmpl_print_expression, derived_column, pplan, dot_count, depth);
		} else {
			TMPL(tmpl_column_reference, pplan, plan->v.lp_column_alias.column_alias);
		}
		break;
	case LP_KEY:
		TMPL(tmpl_key, plan->v.lp_key.key);
		break;
	case LP_ADDITION:
		m_operator = "+";
		break;
	case LP_SUBTRACTION:
		m_operator = "-";
		break;
	case LP_DIVISION:
		m_operator = "/";
		break;
	case LP_MULTIPLICATION:
		m_operator = "*";
		break;
	case LP_MODULO:
		m_operator = "#";
		break;
	case LP_CONCAT:
		m_operator = "_";
		break;
	case LP_BOOLEAN_OR:
		m_operator = "!";
		split_m_line = (0 != dot_count);
		break;
	case LP_BOOLEAN_AND:
		m_operator = "&";
		split_m_line = (0 != dot_count);
		break;
	case LP_BOOLEAN_IS:
		m_operator = "=";
		break;
	case LP_BOOLEAN_EQUALS:
		m_operator = "=";
		break;
	case LP_BOOLEAN_NOT_EQUALS:
		m_operator = "'=";
		break;
	case LP_BOOLEAN_LESS_THAN:
	case LP_BOOLEAN_GREATER_THAN:
	case LP_BOOLEAN_LESS_THAN_OR_EQUALS:
	case LP_BOOLEAN_GREATER_THAN_OR_EQUALS:
		// If the arguments are strings, we need to use the M follows operator ']' as appropriate.
		use_string_comparison = lp_is_bool_operand_type_string(plan);
		if (use_string_comparison) {
			// String type. Need to use "]" or "']" operator and swap operands as needed.
			if (LP_BOOLEAN_GREATER_THAN == plan_type) {
				m_operator = "]";
			} else if (LP_BOOLEAN_LESS_THAN_OR_EQUALS == plan_type) {
				m_operator = "']";
			} else {
				// Swap operands first
				t_operand = first_operand;
				first_operand = second_operand;
				second_operand = t_operand;
				if (LP_BOOLEAN_GREATER_THAN_OR_EQUALS == plan_type) {
					m_operator = "']";
				} else
					m_operator = "]";
				}
		} else {
			// Numeric/Integer type. Easy to do <, >, <= and >= comparison.
			if (LP_BOOLEAN_LESS_THAN == plan_type) {
				m_operator = "<";
			} else if (LP_BOOLEAN_GREATER_THAN_OR_EQUALS == plan_type) {
				m_operator = "'<";
			} else if (LP_BOOLEAN_LESS_THAN_OR_EQUALS == plan_type) {
				m_operator = "'>";
			} else {
				m_operator = ">";
			}
		}
		break;
	case LP_BOOLEAN_REGEX_SENSITIVE:
	case LP_BOOLEAN_REGEX_INSENSITIVE:
		%{}$$regmatch^%%ydbposix({}%
		TMPL(tmpl_print_expression, first_operand, pplan, 0, 0);
		%{},{}%
		TMPL(tmpl_print_expression, second_operand, pplan, 0, 0);
		if (LP_BOOLEAN_REGEX_INSENSITIVE == plan_type) {
			// The extra ',3' below marks this as case insensitive
			%{},3{}%
		}
		%{}){}%
		break;
	case LP_BOOLEAN_IN:
	case LP_BOOLEAN_NOT_IN:
		assert((LP_INSERT == second_operand->type) || (LP_SET_OPERATION == second_operand->type));
		%{}($DATA({}%
		cur_lp_key = lp_get_output_key(second_operand);
		TMPL(tmpl_key, cur_lp_key->v.lp_key.key);
		(*buffer_index)--;
		%{},{}%
		TMPL(tmpl_print_expression, first_operand, pplan, 0, 0);
		if (LP_BOOLEAN_IN == plan_type) {
			%{}))'=0){}%
		} else {
			%{}))=0){}%
		}
		break;
	case LP_BOOLEAN_ANY_EQUALS:
	case LP_BOOLEAN_ANY_NOT_EQUALS:
	case LP_BOOLEAN_ANY_LESS_THAN:
	case LP_BOOLEAN_ANY_GREATER_THAN:
	case LP_BOOLEAN_ANY_LESS_THAN_OR_EQUALS:
	case LP_BOOLEAN_ANY_GREATER_THAN_OR_EQUALS:
	case LP_BOOLEAN_ALL_EQUALS:
	case LP_BOOLEAN_ALL_NOT_EQUALS:
	case LP_BOOLEAN_ALL_LESS_THAN:
	case LP_BOOLEAN_ALL_GREATER_THAN:
	case LP_BOOLEAN_ALL_LESS_THAN_OR_EQUALS:
	case LP_BOOLEAN_ALL_GREATER_THAN_OR_EQUALS:
		assert((LP_INSERT == second_operand->type) || (LP_SET_OPERATION == second_operand->type));
		// Fetch the second value from the output key of this query/table
		key = lp_get_output_key(second_operand);
		switch(plan_type) {
		case LP_BOOLEAN_ANY_EQUALS:
			compare_operator = "=";
			sql_operator = "ANY";
			break;
		case LP_BOOLEAN_ANY_NOT_EQUALS:
			compare_operator = "'=";
			sql_operator = "ANY";
			break;
		case LP_BOOLEAN_ANY_LESS_THAN:
			compare_operator = "<";
			sql_operator = "ANY";
			break;
		case LP_BOOLEAN_ANY_GREATER_THAN:
			compare_operator = ">";
			sql_operator = "ANY";
			break;
		case LP_BOOLEAN_ANY_LESS_THAN_OR_EQUALS:
			compare_operator = "<=";
			sql_operator = "ANY";
			break;
		case LP_BOOLEAN_ANY_GREATER_THAN_OR_EQUALS:
			compare_operator = ">=";
			sql_operator = "ANY";
			break;
		case LP_BOOLEAN_ALL_EQUALS:
			compare_operator = "=";
			sql_operator = "ALL";
			break;
		case LP_BOOLEAN_ALL_NOT_EQUALS:
			compare_operator = "'=";
			sql_operator = "ALL";
			break;
		case LP_BOOLEAN_ALL_LESS_THAN:
			compare_operator = "<";
			sql_operator = "ALL";
			break;
		case LP_BOOLEAN_ALL_GREATER_THAN:
			compare_operator = ">";
			sql_operator = "ALL";
			break;
		case LP_BOOLEAN_ALL_LESS_THAN_OR_EQUALS:
			compare_operator = "<=";
			sql_operator = "ALL";
			break;
		default:
			assert(LP_BOOLEAN_ALL_GREATER_THAN_OR_EQUALS == plan_type);
			compare_operator = ">=";
			sql_operator = "ALL";
			break;
		}
		use_string_comparison = lp_is_bool_operand_type_string(plan);
		%{}$${{ sql_operator }}^%%ydboctoplanhelpers({}%
		TMPL(tmpl_print_expression, first_operand, pplan, 0, 0);
		%{},{{ key->v.lp_key.key->unique_id|%d }},"{{ compare_operator }}",{{ use_string_comparison|%d }}){}%
		break;
	case LP_FORCE_NUM:
		%{}+{}%
		TMPL(tmpl_print_expression, first_operand, pplan, 0, 0);
		break;
	case LP_NEGATIVE:
		%{}-{}%
		TMPL(tmpl_print_expression, first_operand, pplan, 0, 0);
		break;
	case LP_BOOLEAN_NOT:
		%{}'{}%
		TMPL(tmpl_print_expression, first_operand, pplan, 0, 0);
		break;
	case LP_BOOLEAN_EXISTS:
	case LP_BOOLEAN_NOT_EXISTS:
		assert((LP_INSERT == first_operand->type) || (LP_SET_OPERATION == first_operand->type));
		// Fetch the first value from the output key of this query/table
		key = lp_get_output_key(first_operand);
		if (LP_BOOLEAN_NOT_EXISTS == plan_type) {
			%{}'{}%
		}
		%{}$$EXISTS^%%ydboctoplanhelpers({{ key->v.lp_key.key->unique_id|%d }}){}%
		break;
	case LP_BOOLEAN_IS_NULL:
	case LP_BOOLEAN_IS_NOT_NULL:
		if (LP_BOOLEAN_IS_NOT_NULL == plan_type) {
			%{}'{}%
		}
		%{}$ZYISSQLNULL({}%
		TMPL(tmpl_print_expression, first_operand, pplan, 0, 0);
		%{}){}%
		break;
	case LP_FUNCTION_CALL:
		cur_plan = plan;
		%{}{}%
		TMPL(tmpl_print_expression, first_operand, pplan, 0, 0);
		%{}({}%
		while (NULL != cur_plan->v.lp_default.operand[1]) {
			if (cur_plan != plan) {
				%{},{}%
			}
			cur_plan = cur_plan->v.lp_default.operand[1];
			TMPL(tmpl_print_expression, cur_plan->v.lp_default.operand[0], pplan, 0, 0);
		}
		%{}){}%
		break;
	case LP_AGGREGATE_FUNCTION_COUNT_ASTERISK:
	case LP_AGGREGATE_FUNCTION_COUNT:
	case LP_AGGREGATE_FUNCTION_MIN:
	case LP_AGGREGATE_FUNCTION_MAX:
	case LP_AGGREGATE_FUNCTION_SUM:
	case LP_AGGREGATE_FUNCTION_COUNT_DISTINCT:
	case LP_AGGREGATE_FUNCTION_SUM_DISTINCT:
	case LP_AGGREGATE_FUNCTION_AVG:
	case LP_AGGREGATE_FUNCTION_AVG_DISTINCT:
		/* Note that the GROUP_BY_SUBSCRIPT node might not exist in case all values aggregated were NULL.
		 * Hence the need for $GET.
		 */
		%{}$GET({}%
		TMPL(tmpl_key, pplan->outputKey);
		(*buffer_index)--;
		assert(plan->extra_detail.lp_aggregate_function.aggregate_cnt);
		aggregate_cnt = plan->extra_detail.lp_aggregate_function.aggregate_cnt;
		is_avg = ((LP_AGGREGATE_FUNCTION_AVG == plan_type) || (LP_AGGREGATE_FUNCTION_AVG_DISTINCT == plan_type));
		/* AVG is slightly different from other aggregate functions in that the actual average is not stored anywhere
		 * yet. Only the cumulative sum and cumulative count are stored (in `Avg` or `AvgDistinct` labels in
		 * `src/aux/_ydboctoplanhelpers.m`). So generate code that computes the average using the stored quantities.
		 */
		if (is_avg) {
			/* In case of AVG function, the SUM and COUNT are stored separately so use that to find the AVG.
			 * The SUM and COUNT are stored in a negative subscript so do the negation here.
			 */
			aggregate_cnt = - aggregate_cnt;
		}
		%{},{{ GROUP_BY_SUBSCRIPT }},%%ydboctog,{{ aggregate_cnt|%d }}{}%
		if (is_avg) {
			%{},"SUM"{}%
		}
		%{}),{}%
		/* In case no rows exist, set default value of 0 for COUNT and NULL for AVG/SUM/MIN/MAX.
		 * Similar code exists in "tmpl_group_by.ctemplate".
		 */
		switch(plan_type) {
		case LP_AGGREGATE_FUNCTION_MIN:
		case LP_AGGREGATE_FUNCTION_MAX:
		case LP_AGGREGATE_FUNCTION_SUM:
		case LP_AGGREGATE_FUNCTION_SUM_DISTINCT:
		case LP_AGGREGATE_FUNCTION_AVG:
		case LP_AGGREGATE_FUNCTION_AVG_DISTINCT:
			%{}$ZYSQLNULL{}%
			break;
		default:
			assert((LP_AGGREGATE_FUNCTION_COUNT_ASTERISK == plan_type)
				|| (LP_AGGREGATE_FUNCTION_COUNT == plan_type)
				|| (LP_AGGREGATE_FUNCTION_COUNT_DISTINCT == plan_type));
			%{}0{}%
			break;
		}
		%{}){}%
		if (is_avg) {
			%{}/{}%
			%{}$GET({}%
			TMPL(tmpl_key, pplan->outputKey);
			(*buffer_index)--;
			%{},{{ GROUP_BY_SUBSCRIPT }},%%ydboctog,{{ aggregate_cnt|%d }},"COUNT"){}%
			%{},1){}%
		}
		break;
	case LP_INSERT:
	case LP_SET_OPERATION:
		// Fetch the first value from the output key of this query/table
		key = lp_get_output_key(plan);
		%{}$$GetScalar^%%ydboctoplanhelpers({{ key->v.lp_key.key->unique_id|%d }}){}%
		break;
	case LP_CASE:
		%{}$SELECT({}%
		GET_LP(cur_plan, plan, 0, LP_CASE_STATEMENT);
		cas_value = cur_plan->v.lp_default.operand[0];
		default_value = cur_plan->v.lp_default.operand[1];
		GET_LP(cur_plan, plan, 1, LP_CASE_BRANCH);
		while (NULL != cur_plan) {
			GET_LP(cur_branch, cur_plan, 0, LP_CASE_BRANCH_STATEMENT);
			condition = cur_branch->v.lp_default.operand[0];
			branch_value = cur_branch->v.lp_default.operand[1];
			%{}({}%
			TMPL(tmpl_print_expression, condition, pplan, 0, 0);
			%{})=({}%
			if (NULL != cas_value) {
				TMPL(tmpl_print_expression, cas_value, pplan, 0, 0);
			} else {
				%{}1{}%
			}
			%{}):({}%
			TMPL(tmpl_print_expression, branch_value, pplan, 0, 0);
			%{}),{}%
			cur_plan = cur_plan->v.lp_default.operand[1];
		}
		if (NULL != default_value) {
			%{}1:{}%
			TMPL(tmpl_print_expression, default_value, pplan, 0, 0);
			%{}){}%
		} else {
			%{}1:""){}%
		}
		break;
	default:
		assert(FALSE);
		FATAL(ERR_UNKNOWN_KEYWORD_STATE, "");
	}
	if (m_operator) {
		if (split_m_line) {
			/* Evaluate left hand side of boolean AND or OR */
			TMPL(tmpl_print_expression, first_operand, pplan, dot_count, depth);
			%{}`n{{ PLAN_LINE_START }}{}%
			TMPL(tmpl_print_dots, dot_count);
			/* Move result into temporary variable (using recursion "depth" to avoid interference from M code generated
			 * by next "tmpl_print_expression" call which evaluates right side of boolean AND or OR).
			 */
			%{}SET %%ydboctobool({{ depth|%d }})=%%ydboctobool{}%
			/* Evaluate right hand side of boolean AND or OR */
			%{}`n{{ PLAN_LINE_START }}{}%
			TMPL(tmpl_print_dots, dot_count);
			%{}SET %%ydboctobool={}%
			TMPL(tmpl_print_expression, second_operand, pplan, dot_count, depth);
			/* Evaluate result of boolean AND or OR */
			%{}`n{{ PLAN_LINE_START }}{}%
			TMPL(tmpl_print_dots, dot_count);
			%{}SET %%ydboctobool=%%ydboctobool({{ depth|%d }}){{ m_operator }}%%ydboctobool{}%
		} else {
			%{}({}%
			TMPL(tmpl_print_expression, first_operand, pplan, 0, 0);
			%{}{{ m_operator }}{}%
			TMPL(tmpl_print_expression, second_operand, pplan, 0, 0);
			%{}){}%
		}
	}
	TEMPLATE_END();
}
%{}

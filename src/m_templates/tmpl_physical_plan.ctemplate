{%
/****************************************************************
 *								*
 * Copyright (c) 2019 YottaDB LLC and/or its subsidiaries.	*
 * All rights reserved.						*
 *								*
 *	This source code contains the intellectual property	*
 *	of its copyright holder(s), and is made available	*
 *	under a license.  If you do not know the terms of	*
 *	the license, please stop and do not read further.	*
 *								*
 ****************************************************************/

#include "physical_plan.h"
#include "template_helpers.h"

TEMPLATE(tmpl_physical_plan, PhysicalPlan *plan) {
    TEMPLATE_INIT();

    int			i;
    SqlKey		*key, *t_key;
    SqlColumnAlias	*column_alias;
    SqlValue		*value;
    LogicalPlan		*lp_temp;
    char		*tableName = "";
    char		*columnName = "";
    unsigned int	cur_key;
    int			dot_count;

    %}
{{ plan->plan_name }}(cursorId)
    {% // The whitespace here is needed for proper M formatting

	assert(NULL == plan->treat_key_as_null);
	plan->treat_key_as_null = octo_cmalloc(memory_chunks, sizeof(boolean_t) * config->plan_id);

    // Check if there are any cross references that need to be built
    // If this a plan for a cross reference, put safeguards in place to prevent building twice
    if(plan->outputKey && plan->outputKey->is_cross_reference_key) {
        UNPACK_SQL_STATEMENT(value, plan->outputKey->table->tableName, value);
        tableName = value->v.reference;
        UNPACK_SQL_STATEMENT (value, plan->outputKey->column->columnName, value);
        columnName = value->v.reference;
        GET_LP(lp_temp, plan->projection, 0, LP_WHERE);
        GET_LP(lp_temp, lp_temp, 0, LP_COLUMN_ALIAS);
        column_alias = lp_temp->v.column_alias;
    %}LOCK +^{{ config->global_names.raw_xref }}("{{ tableName }}","{{ columnName }}"):10
    IF $GET(^{{ config->global_names.raw_octo }}("xref_status","{{ tableName }}","{{ columnName }}"))="done" LOCK -^{{ config->global_names.raw_xref }}("{{ tableName }}","{{ columnName }}") QUIT
    IF '$ZTRIGGER("item","+{% TMPL(tmpl_column_reference_trigger, plan, column_alias); %} -commands=SET,KILL -xecute=""DO handleSet^{{ plan->filename }}""") H
    SET %%ydboctoCancel("{{ tableName }}","{{ columnName }}","Trigger")="-{% TMPL(tmpl_column_reference_trigger, plan, column_alias); %} -commands=SET,KILL -xecute=""DO handleSet^{{ plan->filename }}"""
    SET %%ydboctoCancel("{{ tableName }}","{{ columnName }}","Node")="^{{ config->global_names.raw_xref }}(""{{ tableName }}"",""{{ columnName }}"")"
    {% // Whitespace needed
    } else {
        for(cur_key = 0; cur_key < plan->total_iter_keys; cur_key++) {
            key = plan->iterKeys[cur_key];
            t_key = key->cross_reference_output_key;
            if(t_key == NULL)
                continue;
            UNPACK_SQL_STATEMENT(value, t_key->table->tableName, value);
            tableName = value->v.reference;
            UNPACK_SQL_STATEMENT (value, t_key->column->columnName, value);
            columnName = value->v.reference;
            %}DO:'$DATA(^{{ config->global_names.raw_octo }}("xref_status","{{ tableName }}","{{ columnName }}")) ^{{ t_key->cross_reference_filename }}(cursorId)
    {%
        }
    }
    %}NEW %%ydboctoz{%
    if(plan->set_operation == PP_NOT_SET) {
        %} KILL {% TMPL(tmpl_key, plan->outputKey); %}
    {%
    } else {
        %}
    {% // Whitespace for MUMPS
    }

    cur_key = 0;
    dot_count = 0;
    TMPL(tmpl_tablejoin, plan, plan->tablejoin, cur_key, FALSE, dot_count, tableName, columnName);

    // If this expression had an order by, we now need to go back and make the ordering uniform
    // If we have a lot of plans each of which have the same output key and order by, then do this step
    // only for the last plan in that set.
    assert((NULL == plan->order_by) || ((NULL != plan->outputKey) && !plan->outputKey->is_cross_reference_key));
    if (plan->order_by
        && ((NULL == plan->next) || (NULL == plan->next->order_by)
                || (plan->outputKey->unique_id != plan->next->outputKey->unique_id)))
    {
        char    		*direction;
	SqlOptionalKeyword	*keyword;
	SqlValue		*value;

	// Check if LIMIT has been specified.
	// If so, apply that here (we skipped this in "tmpl_tablejoin.ctemplate" because of the presence of ORDER BY).
	keyword = get_keyword_from_keywords(plan->keywords, OPTIONAL_LIMIT);
	if (NULL != keyword)
		UNPACK_SQL_STATEMENT(value, keyword->v, value);
	direction = ((OPTIONAL_DESC == plan->order_by->extra_detail) ? "-1" : "1");
        %}
    NEW %%ydboctoi0,%%ydboctoi1,%%ydboctoi2
    SET %%ydboctoi0=1,%%ydboctoi1="",%%ydboctoi2=""
    FOR  SET %%ydboctoi1=$ORDER({% TMPL(tmpl_key, plan->outputKey); buff_ptr--; %},"order",%%ydboctoi1),{{ direction }})  QUIT:$DATA({%
	TMPL(tmpl_key, plan->outputKey); buff_ptr--;
	%},"order",%%ydboctoi1))=0  DO  QUIT:(%%ydboctoi1=""){%
	if (NULL != keyword)
		%}!({{ value->v.string_literal }}<%%ydboctoi0){%
	%}
    {%
    %}. FOR  SET %%ydboctoi2=$ORDER({% TMPL(tmpl_key, plan->outputKey); buff_ptr--; %},"order",%%ydboctoi1,%%ydboctoi2)) QUIT:(%%ydboctoi2=""){%
	if (NULL != keyword)
		%}!({{ value->v.string_literal }}<%%ydboctoi0){%
    %}  SET {% TMPL(tmpl_key, plan->outputKey); buff_ptr--; %},%%ydboctoi0)={%
              TMPL(tmpl_key, plan->outputKey); buff_ptr--; %},"order",%%ydboctoi1,%%ydboctoi2) IF $INCREMENT(%%ydboctoi0)
    KILL {% TMPL(tmpl_key, plan->outputKey); buff_ptr--; %},"order"){%
    }
    // If this is a INTERSECT set, we need to delete any keys remaining in the
    //  the index; these were in the first set, but not the second
    if(plan->set_operation == PP_INTERSECT_SET) {
        %}
    SET var="{{ config->global_names.cursor }}("_cursorId_",""index"")" FOR  SET var=$QUERY(@var),var=$QUERY(@var) QUIT:$QSUBSCRIPT(var,2)'="index"  DO
    . SET index=$QSUBSCRIPT(var,$QLENGTH(var))
    . KILL:index'="" {%
    TMPL(tmpl_key, plan->outputKey);
    // Go back on in the buffer
    buff_ptr -= 1;
    %},index){%
    }
    if(plan->outputKey && plan->outputKey->is_cross_reference_key) {
    %}
    SET ^{{ config->global_names.raw_octo }}("xref_status","{{ tableName }}","{{ columnName }}")="done"
    KILL %%ydboctoCancel
    LOCK -^{{ config->global_names.raw_xref }}("{{ tableName }}","{{ columnName }}"){%
    }
    %}
    QUIT{%

    // If this is a cross reference key, put the trigger definitions here
    if(plan->outputKey && plan->outputKey->is_cross_reference_key) {
    %}
handleSet
    NEW t
    IF $ZTRIGGEROP="K" DO
    . SET val=""
    . FOR  SET val=$ORDER(^{{ config->global_names.raw_xref }}("{{ tableName }}","{{ columnName }}",val)) QUIT:val=""  DO:$DATA(^{{ config->global_names.raw_xref }}("{{ tableName }}","{{ columnName }}",val{%
        lp_temp = plan->projection->v.operand[1];
        i = 0;
        while(lp_temp != NULL) {
            %},sub{{ i|%d }}{%
            lp_temp = lp_temp->v.operand[1];
            i++;
        }
        %}))'=0
    . . KILL ^{{ config->global_names.raw_xref }}("{{ tableName }}","{{ columnName }}",val{%
        lp_temp = plan->projection->v.operand[1];
        i = 0;
        while(lp_temp != NULL) {
            %},sub{{ i|%d }}{%
            lp_temp = lp_temp->v.operand[1];
            i++;
        }
        %})
    . . KILL:$INCREMENT(^{{ config->global_names.raw_xref }}("{{ tableName }}","{{ columnName }}",val),-1)=0 ^{{ config->global_names.raw_xref }}("{{ tableName }}","{{ columnName }}",val)
    . . KILL:$INCREMENT(^{{ config->global_names.raw_xref }}("{{ tableName }}","{{ columnName }}"),-1)=0 ^{{ config->global_names.raw_xref }}("{{ tableName }}","{{ columnName }}")
    ELSE  DO
    . SET newValue=$PIECE($ZTVALUE,$ZTDELIM,$ZTUPDATE)
    . SET oldValue=$PIECE($ZTOLDVAL,$ZTDELIM,$ZTUPDATE)
    . KILL:oldValue'="" ^{{ config->global_names.raw_xref }}("{{ tableName }}","{{ columnName }}",oldValue{%
        lp_temp = plan->projection->v.operand[1];
        i = 0;
        while(lp_temp != NULL) {
            %},sub{{ i|%d }}{%
            lp_temp = lp_temp->v.operand[1];
            i++;
        }
        %}){%
        // Now decrement the counts for the globals
    %}
    . IF oldValue'="" IF $SELECT($INCREMENT(^{{ config->global_names.raw_xref }}("{{ tableName }}","{{ columnName }}",oldValue),-1):$INCREMENT(^{{ config->global_names.raw_xref }}("{{ tableName }}","{{ columnName }}"),-1),1:$INCREMENT(^{{ config->global_names.raw_xref }}("{{ tableName }}","{{ columnName }}"),-1))
    . KILL:(oldValue'="")&(^{{ config->global_names.raw_xref }}("{{ tableName }}","{{ columnName }}",oldValue)=0) ^{{ config->global_names.raw_xref }}("{{ tableName }}","{{ columnName }}",oldValue)
    . SET:newValue'="" ^{{ config->global_names.raw_xref }}("{{ tableName }}","{{ columnName }}",newValue{%
        lp_temp = plan->projection->v.operand[1];
        i = 0;
        while(lp_temp != NULL) {
            %},sub{{ i|%d }}{%
            lp_temp = lp_temp->v.operand[1];
            i++;
        }
        %})=""{%
        // Now decrement the counts for the globals
    %}
    . IF newValue'="" IF $SELECT($INCREMENT(^{{ config->global_names.raw_xref }}("{{ tableName }}","{{ columnName }}",newValue)):$INCREMENT(^{{ config->global_names.raw_xref }}("{{ tableName }}","{{ columnName }}")),1:$INCREMENT(^{{ config->global_names.raw_xref }}("{{ tableName }}","{{ columnName }}")))
    QUIT{%
    }
    TEMPLATE_END();
}
%}

{}%
/****************************************************************
 *								*
 * Copyright (c) 2019-2020 YottaDB LLC and/or its subsidiaries.	*
 * All rights reserved.						*
 *								*
 *	This source code contains the intellectual property	*
 *	of its copyright holder(s), and is made available	*
 *	under a license.  If you do not know the terms of	*
 *	the license, please stop and do not read further.	*
 *								*
 ****************************************************************/

#include "physical_plan.h"
#include "template_helpers.h"

TEMPLATE(tmpl_tablejoin_body, PhysicalPlan *plan, int dot_count, char *tableName, char *columnName) {
	TEMPLATE_INIT();

	assert(NULL != plan->outputKey);
	if (plan->outputKey->is_cross_reference_key) {
		/* Simplest case. Finish it first */
		LogicalPlan	*lp_temp;

		assert(NULL == plan->where->v.lp_default.operand[0]);
		assert(!plan->distinct_values);
		assert(!plan->emit_duplication_check);
		assert(NULL == plan->order_by);
		assert(NULL == plan->aggregate_options);
		TMPL(tmpl_print_dots, dot_count);
		%{}SET{}%
		%{} ^{{ config->global_names.raw_xref }}("{{ tableName }}","{{ columnName }}"{}%
		%{},{}%
		TMPL(tmpl_column_list_combine, plan->projection, plan, ",", 0, 0, 0);
		%{})=""`n{{ PLAN_LINE_START }}{}%
		TMPL(tmpl_print_dots, dot_count);
		%{}IF $INCREMENT(^{{ config->global_names.raw_xref }}("{{ tableName }}","{{ columnName }}"{}%
		%{})),$INCREMENT(^{{ config->global_names.raw_xref }}("{{ tableName }}","{{ columnName }}",{}%
		// Temporarily sever the key from the projection
		lp_temp = plan->projection->v.lp_default.operand[1];
		plan->projection->v.lp_default.operand[1] = NULL;
		TMPL(tmpl_column_list_combine, plan->projection, plan, ",", 0, 0, 0);
		plan->projection->v.lp_default.operand[1] = lp_temp;
		%{})){}%
		TEMPLATE_END();
	}
	// Apply the conditions for this statement
	TMPL(tmpl_print_dots, dot_count);
	%{}NEW %%ydboctobool SET %%ydboctobool=1{}%
	if (plan->where && plan->where->v.lp_default.operand[0]) {
		%{}`n{{ PLAN_LINE_START }}{}%
		TMPL(tmpl_print_dots, dot_count);
		%{}SET %%ydboctobool={}%
		assert(dot_count);	/* Ensure "tmpl_print_expression" knows to split boolean expression
					 * across multiple lines so we do not exceed M maximum source line limit.
					 */
		TMPL(tmpl_print_expression, plan->where->v.lp_default.operand[0], plan, dot_count, 0);
	}
	// DISTINCT value processing (if needed)
	if (plan->distinct_values) {
		/* If this plan has a GROUP BY, then we will do DISTINCT processing in `tmpl_group_by` so skip that here */
		if (!IS_GROUP_BY_PLAN(plan)) {
			%{}`n{{ PLAN_LINE_START }}{}%
			TMPL(tmpl_print_dots, dot_count);
			%{}SET %%ydboctobool=%%ydboctobool&{}%
			%{}('$DATA({{ config->global_names.cursor }}(cursorId,{{ DISTINCT_SUBSCRIPT }},{}%
			TMPL(tmpl_column_list_combine, plan->projection, plan, ",", 0, 0, 0);
			%{}))){}%
		}
	} else if (plan->emit_duplication_check) {
		// Ensure we don't emit duplicates
		%{}`n{{ PLAN_LINE_START }}{}%
		TMPL(tmpl_print_dots, dot_count);
		%{}SET %%ydboctobool=%%ydboctobool&{}%
		%{}('$DATA({}%
		TMPL(tmpl_duplication_check, plan);
		%{})){}%
	}
	%{}`n{{ PLAN_LINE_START }}{}%
	TMPL(tmpl_print_dots, dot_count);
	%{}IF %%ydboctobool DO{}%
	/* If GROUP BY or HAVING have been specified and/or Aggregate functions have been used, invoke another function
	 * to do the M code generation as the flow is very different (more complicated).
	 */
	if (IS_GROUP_BY_PLAN(plan)) {
		TMPL(tmpl_tablejoin_body_group_by, plan, dot_count);
		TEMPLATE_END();
	}
	// Populate records in the output key (i.e. SELECT column list)
	TMPL(tmpl_populate_output_key, plan, dot_count);
	TEMPLATE_END();
}
%{}

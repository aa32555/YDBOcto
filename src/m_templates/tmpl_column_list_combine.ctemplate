{}%
/****************************************************************
 *								*
 * Copyright (c) 2019-2020 YottaDB LLC and/or its subsidiaries.	*
 * All rights reserved.						*
 *								*
 *	This source code contains the intellectual property	*
 *	of its copyright holder(s), and is made available	*
 *	under a license.  If you do not know the terms of	*
 *	the license, please stop and do not read further.	*
 *								*
 ****************************************************************/

#include "octo_types.h"

#include "physical_plan.h"
#include "template_helpers.h"


/* This roughly corresponds to half the length of the max M line, which gives us room
 * for the "last" item in on the line before we split it
 */
#define MAX_M_LINE_LENGTH 4096

TEMPLATE(tmpl_column_list_combine, LogicalPlan *plan, PhysicalPlan *pplan, char *delim,
			boolean_t str2mval, int start_output_key, int output_key_length, int dot_count) {
	TEMPLATE_INIT();

	char		c;
	boolean_t	is_order_by;

	assert((',' == *delim) || ('_' == *delim));
	assert(NULL != plan);
	is_order_by = (plan == pplan->order_by);
	while (NULL != plan) {
		assert(((LP_COLUMN_LIST == plan->type) && (LP_WHERE == plan->v.lp_default.operand[0]->type))
			|| (((LP_ORDER_BY == plan->type) || (LP_GROUP_BY == plan->type) || IS_TYPE_LP_AGGREGATE(plan->type))
						&& (LP_COLUMN_LIST == plan->v.lp_default.operand[0]->type)));
		assert(is_order_by == (LP_ORDER_BY == plan->type));
		if (is_order_by) {
			/* This is a call for an ORDER BY. If the ORDER BY was done on an expression which
			 * has a STRING_LITERAL type, then we need to ensure that it gets treated as a STRING
			 * in M even if the string holds a numeric value or else ORDER BY would work incorrectly
			 * (see YDBOcto#397 for details). We address this by prefixing the ORDER BY expression
			 * with a small string "Z".
			 */
			SqlValueType	order_by_expr_type;
			LogicalPlan	*tmpPlan;

			tmpPlan = plan->v.lp_default.operand[0];
			assert(LP_COLUMN_LIST == tmpPlan->type);
			tmpPlan = tmpPlan->v.lp_default.operand[0];
			assert(LP_WHERE == tmpPlan->type);
			tmpPlan = tmpPlan->v.lp_default.operand[1];
			assert(LP_COLUMN_LIST_ALIAS == tmpPlan->type);
			order_by_expr_type = tmpPlan->v.lp_column_list_alias.column_list_alias->type;
			assert((BOOLEAN_VALUE == order_by_expr_type)
				|| (INTEGER_LITERAL == order_by_expr_type)
				|| (NUMERIC_LITERAL == order_by_expr_type)
				|| (STRING_LITERAL == order_by_expr_type)
				|| (NUL_VALUE == order_by_expr_type));
			if (STRING_LITERAL == order_by_expr_type) {
				%{}"Z"_{}%
			}
			/* Note: In case of ORDER BY, we do NOT want to convert str to mval as the ordering will then not happen.
			 *       Caller should have set `str2mval` appropriately. Assert that.
			 */
			assert(!str2mval);
		}
		if (str2mval) {
			%{}$$str2mval^%%ydboctoplanhelpers({}%
		}
		TMPL(tmpl_print_expression, plan->v.lp_default.operand[0]->v.lp_default.operand[0], pplan, 0, 0);
		if (str2mval) {
			%{}){}%
		}
		if (plan->v.lp_default.operand[1]) {
			if ((0 != start_output_key) && (MAX_M_LINE_LENGTH < (*buffer_index - start_output_key))) {
				/* The generated M line became close to exceeding the max M line length so split it.
				 * Reuse the passed in output key to regenerate the first part of the new M line.
				 */
				c = (*global_buffer)[start_output_key + output_key_length];
				(*global_buffer)[start_output_key + output_key_length] = '\0';
				%{}`n{{ PLAN_LINE_START }}{}%
				TMPL(tmpl_print_dots, dot_count);
				%{}SET {}%
				%{}{{*global_buffer + start_output_key}}{}%
				%{}={{*global_buffer + start_output_key}}_{}%
				(*buffer_index)--;
				(*global_buffer)[start_output_key + output_key_length] = c;
				start_output_key = *buffer_index - output_key_length;
			}
			%{}{{ delim }}{}%
		}
		plan = plan->v.lp_default.operand[1];
	}
	TEMPLATE_END();
}
%{}

#################################################################
#								#
# Copyright (c) 2019 YottaDB LLC and/or its subsidiaries.	#
# All rights reserved.						#
#								#
#	This source code contains the intellectual property	#
#	of its copyright holder(s), and is made available	#
#	under a license.  If you do not know the terms of	#
#	the license, please stop and do not read further.	#
#								#
#################################################################

load test_helpers

setup() {
  init_test
  createdb
  load_fixture names.sql
  load_fixture names.zwr
}

@test "outer join with no condition specified" {
  octo <<OCTO 2>&1 | tee output.txt
SELECT *
FROM names n1
LEFT JOIN (
  SELECT *
  FROM names
  WHERE firstName < "Zero"
) n2;
OCTO
  [[ "$(grep -c "Error parsing statement" output.txt)" == "1" ]]
}

@test "outer join with matching rows is the same as inner join" {
  octo <<OCTO &> output1.txt
SELECT *
FROM names n1
LEFT JOIN names n2
ON n1.id = n2.id;
OCTO
  octo <<OCTO &> output2.txt
SELECT *
FROM names n1
INNER JOIN names n2
ON n1.id = n2.id;
OCTO
  grep "|" output1.txt > output1_filtered.txt
  grep "|" output2.txt > output2_filtered.txt
  [[ "$(diff output1_filtered.txt output2_filtered.txt)" == "" ]]
}

@test "outer join followed by a SET operation" {
  octo <<OCTO &> output1.txt
SELECT *
FROM names n1
LEFT JOIN names n2
ON n1.id = n2.id
UNION ALL
SELECT *
FROM names n1;
OCTO
  octo <<OCTO &> output2.txt
SELECT *
FROM names n1
INNER JOIN names n2
ON n1.id = n2.id
UNION ALL
SELECT *
FROM names n1;
OCTO
  grep "|" output1.txt > output1_filtered.txt
  grep "|" output2.txt > output2_filtered.txt
  [[ "$(diff output1_filtered.txt output2_filtered.txt)" == "" ]]
}

@test "left outer join with missing columns" {
  octo <<OCTO 2>&1 | tee output.txt
SELECT *
FROM names n1
LEFT JOIN (
  SELECT *
  FROM names
  WHERE firstName < 'Zero'
) n2
ON n1.id = n2.id;
OCTO
  [[ "$(grep -c "|" output.txt)" == "6" ]]
}

@test "right outer join with matching rows is the same as inner join" {
  octo <<OCTO &> output1.txt
SELECT *
FROM names n1
RIGHT JOIN names n2
ON n1.id = n2.id;
OCTO
  octo <<OCTO &> output2.txt
SELECT *
FROM names n1
INNER JOIN names n2
ON n1.id = n2.id;
OCTO
  grep "|" output1.txt > output1_filtered.txt
  grep "|" output2.txt > output2_filtered.txt
  [[ "$(diff output1_filtered.txt output2_filtered.txt)" == "" ]]
}

@test "right outer join followed by a SET operation" {
  octo <<OCTO &> output1.txt
SELECT *
FROM names n1
RIGHT JOIN names n2
ON n1.id = n2.id
UNION ALL
SELECT *
FROM names n1;
OCTO
  octo <<OCTO &> output2.txt
SELECT *
FROM names n1
INNER JOIN names n2
ON n1.id = n2.id
UNION ALL
SELECT *
FROM names n1;
OCTO
  grep "|" output1.txt > output1_filtered.txt
  grep "|" output2.txt > output2_filtered.txt
  [[ "$(diff output1_filtered.txt output2_filtered.txt)" == "" ]]
}

@test "right outer join with missing columns" {
  octo <<OCTO 2>&1 | tee output.txt
SELECT *
FROM  (
  SELECT *
  FROM names
  WHERE firstName < 'Zero'
) n1
RIGHT JOIN names n2
ON n1.id = n2.id;
OCTO
  [[ "$(grep -c "|" output.txt)" == "6" ]]
}

@test "full outer join with missing columns" {
  octo <<OCTO 2>&1 | tee output.txt
SELECT *
FROM  (
  SELECT *
  FROM names
  WHERE firstName = 'Zero'
) n1
FULL OUTER JOIN (
  SELECT *
  FROM names
  WHERE firstName = 'Acid'
) n2
ON n1.id = n2.id;
OCTO
  [[ "$(grep -c "|" output.txt)" == "3" ]]
}

@test "nested select with outer join" {
  octo <<OCTO 2>&1 | tee output.txt
SELECT * FROM (
  SELECT *
  FROM names n1
  LEFT JOIN names n2
  ON n1.id = n2.id
) WHERE firstName :: text = 'Zero';
OCTO
  # Not crashing is valid for this test
}

@test "LEFT/RIGHT/FULL JOIN on various queries from pastas database" {
  load_fixture pastas.sql
  load_fixture pastas.zwr
  # Below are all queries that were found in the following files.
  #	test_inner_join_order_by.bats.in
  #	test_inner_join_where.bats.in
  #	test_inner_join_where_order_by.bats.in
  # Each of those queries are run with a LEFT or RIGHT or FULL JOIN and the output is compared against Postgres.
  # This simplifies the task of maintaining reference files for these.
  yottadb -run genouterjoinonpastas^genrandomqueries	# this generates queries of the form jointest01.sql, jointest02.sql ...
  # Run using psql and Octo against each of the generated queries
  for file in jointest*.sql
  do
    run_query_in_octo_and_postgres_and_crosscheck pastas $file
  done
}

@test "random outer join queries" {
  load_fixture customers.sql
  load_fixture customers.zwr
  yottadb -run ^genrandomqueries	# this generates a max of 20 queries jointest01.sql, jointest02.sql ... jointest20.sql
  # Run using psql and Octo against each of the generated queries
  for file in jointest*.sql
  do
    run_query_in_octo_and_postgres_and_crosscheck customers $file
  done
}

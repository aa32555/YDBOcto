#################################################################
#								#
# Copyright (c) 2019 YottaDB LLC and/or its subsidiaries.	#
# All rights reserved.						#
#								#
#	This source code contains the intellectual property	#
#	of its copyright holder(s), and is made available	#
#	under a license.  If you do not know the terms of	#
#	the license, please stop and do not read further.	#
#								#
#################################################################

load test_helpers

setup() {
  init_test
  createdb
  load_fixture names.sql
  load_fixture names.zwr
}

@test "order by firstName ascending" {
  octo >& output.txt <<OCTO
select * from names order by firstName;
OCTO
  run cat output.txt
  [[ "$output" =~ /1|Acid|Burn.*0|Zero|Cool/ ]]
}

@test "order by firstName ascending explicit" {
  octo >& output.txt <<OCTO
select * from names order by firstName asc;
OCTO
  run cat output.txt
  [[ "$output" =~ /1|Acid|Burn.*0|Zero|Cool/ ]]
}

@test "order by firstName descending" {
  octo >& output.txt <<OCTO
select * from names order by firstName desc;
OCTO
  run cat output.txt
  [[ "$output" =~ /0|Zero|Cool.*1|Acid|Burn/ ]]
}

@test "order by lastName ascending" {
  octo >& output.txt <<OCTO
select * from names order by lastName;
OCTO
  run cat output.txt
  [[ "$output" =~ /1|Acid|Burn.*3|Lord|Nikon/ ]]
}

@test "order by lastName ascending explicit" {
  octo >& output.txt <<OCTO
select * from names order by lastName asc;
OCTO
  run cat output.txt
  [[ "$output" =~ /1|Acid|Burn.*3|Lord|Nikon/ ]]
}

@test "order by lastName descending" {
  octo >& output.txt <<OCTO
select * from names order by lastName desc;
OCTO
  run cat output.txt
  [[ "$output" =~ /3|Lord|Nikon.*1|Acid|Burn/ ]]
}

@test "order by id ascending" {
  octo >& output.txt <<OCTO
select * from names order by id;
OCTO
  run cat output.txt
  [[ "$output" =~ /0|Zero|Cool.*5|Zero|Cool/ ]]
}

@test "order by id ascending explicit" {
  octo >& output.txt <<OCTO
select * from names order by id asc;
OCTO
  run cat output.txt
  [[ "$output" =~ /0|Zero|Cool.*5|Zero|Cool/ ]]
}

@test "order by id descending" {
  octo >& output.txt <<OCTO
select * from names order by id desc;
OCTO
  run cat output.txt
  [[ "$output" =~ /5|Zero|Cool.*0|Zero|Cool/ ]]
}

@test "TOB01 : order by with OR in boolean expression" {
  octo <<OCTO 2>&1 | tee output.txt
SELECT id,firstname FROM names WHERE (id = 0 or id = 1) ORDER BY firstname;
OCTO
  verify_output TOB01 output.txt noinfo nodebug
}

@test "TOB02 : order by with OR and AND in boolean expression" {
  octo <<OCTO 2>&1 | tee output.txt
SELECT id,firstname FROM names WHERE (firstname = "Zero" AND lastname = "Cool") OR (id = 2) ORDER BY firstname;
OCTO
  verify_output TOB02 output.txt noinfo nodebug
}

@test "TOB03 : OCTO332 : order by on column that is an expression using ADDITION on columns from a sub-query" {
  octo <<OCTO 2>&1 | tee output.txt
select 1+id*2 as a from (select id from names) order by a;
OCTO
  verify_output TOB03 output.txt noinfo nodebug
}

@test "TOB04 : OCTO322 : ORDER BY derived column where sub-query does UNION ALL" {
  cat <<CAT > input.sql
  SELECT * from (select * from names) ORDER BY id;
  SELECT * from (select * from names UNION ALL select * from names) ORDER BY id;
  SELECT * from (select firstname from names UNION ALL select lastname from names) ORDER BY firstname;
  SELECT firstname from (select firstname from names UNION ALL select lastname from names) ORDER BY firstname;
  SELECT * from ((select * from names) UNION ALL (select * from names)) namesunion ORDER BY firstname;
  SELECT * from ((select * from names) UNION ALL (select * from names)) namesunion ORDER BY namesunion.firstname;
  SELECT namesunion.firstname from ((select * from names) UNION ALL (select * from names)) namesunion ORDER BY firstname;
  SELECT NULL as computed_id from (select * from names UNION ALL select * from names) ORDER BY computed_id;
  SELECT 1 as computed_id from (select * from names UNION ALL select * from names) ORDER BY computed_id;
  SELECT 1+id*2 as computed_id from (select * from names UNION ALL select * from names) ORDER BY computed_id;
CAT
  cat input.sql > output.txt
  octo -f input.sql >> output.txt 2>&1
  verify_output TOB04 output.txt
}

@test "TOB05 : OCTO334 : ORDER BY on a column with empty string values does not work correctly" {
  cat <<CAT > input.sql
  SELECT lastname,firstname FROM names ORDER BY lastname;
  SELECT lastname,firstname FROM names ORDER BY lastname DESC;
CAT
  cat input.sql > output.txt
  octo -f input.sql >> output.txt 2>&1
  verify_output TOB05 output.txt
}

@test "TOB06 : OCTO228 : Support ORDER BY with more than one column" {
  $ydb_dist/mumps -run ^%XCMD 'set ^%ydboctoocto("functions","MODULO")="$$^MODULO"'
  cat <<CAT > input.sql
select id as c1, id as c2 from names order by c1,c2;
select id as c1, id as c2 from names order by c2,c1;
select id as c1, MODULO(id,2) as c2, MODULO(id,3) as c3 from names order by c2,c3;
select id as c1, MODULO(id,2) as c2, MODULO(id,3) as c3 from names order by c2 asc,c3;
select id as c1, MODULO(id,2) as c2, MODULO(id,3) as c3 from names order by c2,c3 asc;
select id as c1, MODULO(id,2) as c2, MODULO(id,3) as c3 from names order by c2 desc,c3;
select id as c1, MODULO(id,2) as c2, MODULO(id,3) as c3 from names order by c2,c3 desc;
select id as c1, MODULO(id,2) as c2, MODULO(id,3) as c3 from names order by c2 asc,c3 asc;
select id as c1, MODULO(id,2) as c2, MODULO(id,3) as c3 from names order by c2 asc,c3 desc;
select id as c1, MODULO(id,2) as c2, MODULO(id,3) as c3 from names order by c2 desc,c3 asc;
select id as c1, MODULO(id,2) as c2, MODULO(id,3) as c3 from names order by c2 desc,c3 desc;
select id as c1, MODULO(id,2) as c2, MODULO(id,3) as c3 from names order by c3,c2;
select id as c1, MODULO(id,2) as c2, MODULO(id,3) as c3 from names order by c3 asc,c2;
select id as c1, MODULO(id,2) as c2, MODULO(id,3) as c3 from names order by c3,c2 asc;
select id as c1, MODULO(id,2) as c2, MODULO(id,3) as c3 from names order by c3 desc,c2;
select id as c1, MODULO(id,2) as c2, MODULO(id,3) as c3 from names order by c3,c2 desc;
select id as c1, MODULO(id,2) as c2, MODULO(id,3) as c3 from names order by c3 asc,c2 asc;
select id as c1, MODULO(id,2) as c2, MODULO(id,3) as c3 from names order by c3 asc,c2 desc;
select id as c1, MODULO(id,2) as c2, MODULO(id,3) as c3 from names order by c3 desc,c2 asc;
select id as c1, MODULO(id,2) as c2, MODULO(id,3) as c3 from names order by c3 desc,c2 desc;
select id as c1, MODULO(id,2) as c2, MODULO(id,3) as c3, MODULO(id,2) as c4 from names order by c2,c3,c4;
select id as c1, MODULO(id,2) as c2, MODULO(id,3) as c3, MODULO(id,2) as c4 from names order by c3,c4,c2;
select id as c1, MODULO(id,2) as c2, MODULO(id,3) as c3, MODULO(id,2) as c4 from names order by c4,c2,c3;
select id as c1, MODULO(id,2) as c2, MODULO(id,3) as c3, MODULO(id,2) as c4 from names order by c4 desc,c2 asc,c3 desc;
select id as c1, MODULO(id,2) as c2, MODULO(id,3) as c3, MODULO(id,2) as c4 from names order by c4 asc,c2 desc,c3 desc;
select id as c1, MODULO(id,2) as c2, MODULO(id,3) as c3, MODULO(id,2) as c4 from names order by c4 asc,c2 desc,c3 asc;
select id as c1, MODULO(id,2) as c2, MODULO(id,3) as c3, MODULO(id,2) as c4, MODULO(id,3) as c5 from names order by c2 desc,c3 asc,c4 desc,c5 desc;
select id as c1, MODULO(id,2) as c2, MODULO(id,4) as c3, MODULO(id,2) as c4, MODULO(id,3) as c5 from names order by c2 desc,c3 asc,c4 desc,c5 desc;
select id as c1, MODULO(id,3) as c2, MODULO(id,4) as c3, MODULO(id,2) as c4, MODULO(id,3) as c5 from names order by c2 desc,c3 asc,c4 desc,c5 desc;
select id as c1, MODULO(id,3) as c2, MODULO(id,4) as c3, MODULO(id,3) as c4, MODULO(id,3) as c5 from names order by c2 desc,c3 asc,c4 desc,c5 desc;
select id as c1, MODULO(id,3) as c2, MODULO(id,4) as c3, MODULO(id,3) as c4, MODULO(id,4) as c5 from names order by c2 desc,c3 asc,c4 desc,c5 desc;
CAT
  cat input.sql > output.txt
  octo -f input.sql >> output.txt 2>&1
  # Also verify that only a subset of of the above queries generates a unique plan and the rest of the queries map to one another
  # The easiest way to do this is to find out the query (in a commented section) from the _ydboctoP*.m file and add it to the
  # output so it can be compared against the reference file.
  echo "; Queries that have generated plans" >> output.txt 2>&1
  echo "; ---------------------------------" >> output.txt 2>&1
  export LC_ALL=C # needed to avoid sort order changing (and reference file issues) based on LC_CTYPE being "C" or "en_US.UTF-8"
  grep select _ydboctoP*.m | cut -d";" -f 2 | sort >> output.txt 2>&1
  verify_output TOB06 output.txt
}


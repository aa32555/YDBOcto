#################################################################
#								#
# Copyright (c) 2019 YottaDB LLC and/or its subsidiaries.	#
# All rights reserved.						#
#								#
#	This source code contains the intellectual property	#
#	of its copyright holder(s), and is made available	#
#	under a license.  If you do not know the terms of	#
#	the license, please stop and do not read further.	#
#								#
#################################################################

load test_helpers

setup() {
  init_test
  createdb
  load_fixture names.sql
  load_fixture names.zwr
  load_fixture default_user.zwr
}

@test "invalid Octo GLD" {
  export ydb_gbldir="does_not_exist.gld"
  run octo <<OCTO
SELECT * FROM names WHERE lastName = "Cool";
OCTO
  [[ "$output" =~ "ZGBLDIRACC" ]]
}

@test "TERR002 : Octo can recover from error (e.g. DIVBYZERO)" {
  octo <<OCTO 2>&1 | tee output.txt
select 1/0 from names;
select * from names;
OCTO
  verify_output TERR002 output.txt noinfo nodebug
}

@test "TERR003 : Octo issues FATAL error for missing input file" {
  octo -f missing.sql 2>&1 | tee output.txt
  verify_output TERR003 output.txt noinfo nodebug
}

@test "Octo doesn't generate core file for fatal errors" {
  octo -f missing.sql 2>&1 | tee output.txt
  verify_output TERR003 output.txt noinfo nodebug
  run find "core*"
  [[ $status -eq 1 ]]
}

@test "TERR004 : Rocto can recover from error (e.g. DIVBYZERO)" {
  test_port=$(start_rocto 1443)
  run_psql $test_port <<OCTO 2>&1 | tee output.txt
select 1/0 from names;
select * from names;
OCTO
  stop_rocto
  verify_output TERR004 output.txt noinfo nodebug
}

@test "TERR005 : Feature not implemented: ORDER BY column_number" {
  octo <<OCTO 2>&1 | tee output.txt
select * from names order by 1;
OCTO
  verify_output TERR005 output.txt
}

@test "TERR006 : Feature not implemented: ORDER BY expression" {
  cat >>input.sql<<CAT
select * from names order by 1+1;
select * from names order by 1*1;
select * from names order by 1+id;
select * from names order by id+1;
select * from names order by id+id;
CAT
  octo -f input.sql 2>&1 | tee output.txt
  verify_output TERR006 output.txt
}

@test "TERR007 : Feature not implemented: ORDER BY typecast" {
  cat >>input.sql<<CAT
select * from names order by id::text;
select * from names order by id::integer;
CAT
  octo -f input.sql 2>&1 | tee output.txt
  verify_output TERR007 output.txt
}

@test "TERR008 : Test inputs with tabs are underlined correctly" {
  # this input contains  mix of spaces a tabs
  octo -vv <<OCTO 2>&1 | tee output.txt
	   select
	notathing  	  from
			names
	;
OCTO
  verify_output TERR008 output.txt
}

@test "TERR009 : Test syntax error" {
  cat >>input.sql<<CAT
  !;
CAT
  octo -f input.sql 2>&1 | tee output.txt
  verify_output TERR009 output.txt
}

@test "TERR010 : Rocto prefixes query errors in its log" {
  test_port=$(start_rocto 1337)
  cat <<CAT >> input.sql
select -((select 1 from names limit 1)+(select 2 from names limit 1))+3;
select ABS(-id)+(select firstname from names limit 1) as absid from names;
SELECT  A.firstName, (SELECT B.firstName FROM NAMES LIMIT 1) FROM NAMES A INNER JOIN NAMES B on (A.firstName = B.firstName);
SELECT  A.firstName, (SELECT C.firstName FROM NAMES AS C WHERE C.firstName = B.firstName LIMIT 1) FROM NAMES A INNER JOIN NAMES B on (A.firstName = B.firstName);
SELECT  A.id,A.firstName,B.id,B.firstName,(SELECT C.firstName FROM NAMES AS C WHERE C.firstName = B.firstName LIMIT 1) FROM NAMES A INNER JOIN NAMES B on (A.firstName = B.firstName);
SELECT  A.id,A.firstName,B.id,B.firstName,(SELECT C.firstName FROM NAMES AS C WHERE C.firstName = B.firstName) FROM NAMES A INNER JOIN NAMES B on (A.firstName = B.firstName);
select * from names as n1 where 1::boolean;
select * from names as n1 where (select n2.id % 2 != 1 from names n2 where n1.id = n2.id);
select * from names as n1 where (n1.id != 0) AND (select n2.id != 1 from names n2 where n1.id = n2.id);
select * from names as n1 where NOT (select n2.id != 1 from names n2 where n1.id = n2.id);
SELECT t.typname,
       t.oid
FROM   pg_catalog.pg_type t
JOIN   pg_catalog.pg_namespace n
ON     (
              t.typnamespace = n.oid)
WHERE  n.nspname != 'pg_toast'
AND    (
              t.typrelid = 0
       OR
              (
                     SELECT c.relkind = 'c'
                     FROM   pg_catalog.pg_class c
                     WHERE  c.oid = t.typrelid));
CAT
  run_psql $test_port < input.sql 2>&1 | tee output.txt
  stop_rocto
  # needed because the normal nodebug parameter deletes too many lines
  sed -i '/\[DEBUG\]/d' rocto.log
  verify_output TERR010 rocto.log noinfo nowarn psql noforcedhalt
}

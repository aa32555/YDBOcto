------------------------------
Using command line verbosity level: default (no -v)
------------------------------

------------------------------
Using config verbosity level: ERROR
------------------------------


select * from nonexistanttable;

INDEX fake_index "^notaglobal(""fake_index"",fields(""name""),fields(""age""),keys(""id""))";

select * from names;
[ERROR] PATH:LINENUM DATE TIME : Unknown table: NONEXISTANTTABLE

select * from nonexistanttable;
              ^^^^^^^^^^^^^^^^
[ERROR] PATH:LINENUM DATE TIME : Error parsing statement: select * from nonexistanttable;
0|Zero|Cool
1|Acid|Burn
2|Cereal|Killer
3|Lord|Nikon
4|Joey|
5|Zero|Cool


------------------------------
Using config verbosity level: INFO
------------------------------


select * from nonexistanttable;

INDEX fake_index "^notaglobal(""fake_index"",fields(""name""),fields(""age""),keys(""id""))";

select * from names;
[ INFO] PATH:LINENUM DATE TIME : Loaded config from ./octo.conf
[ERROR] PATH:LINENUM DATE TIME : Unknown table: NONEXISTANTTABLE

select * from nonexistanttable;
              ^^^^^^^^^^^^^^^^
[ERROR] PATH:LINENUM DATE TIME : Error parsing statement: select * from nonexistanttable;
[ INFO] PATH:LINENUM DATE TIME : Parsing done for SQL command [select * from nonexistanttable;]
[ INFO] PATH:LINENUM DATE TIME : Returning failure from run_query
[ WARN] PATH:LINENUM DATE TIME : Feature not implemented: INDEX statements
[ INFO] PATH:LINENUM DATE TIME : Parsing done for SQL command [INDEX fake_index "^notaglobal(""fake_index"",fields(""name""),fields(""age""),keys(""id""))";]
[ INFO] PATH:LINENUM DATE TIME : Generating SQL for CURSOR_NUM
[ INFO] PATH:LINENUM DATE TIME : Parsing done for SQL command [select * from names;]
[ INFO] PATH:LINENUM DATE TIME : Generating SQL for CURSOR_NUM
[ INFO] PATH:LINENUM DATE TIME : Generating M file [./_ydboctoP*.m] (to execute SQL query)
[ INFO] PATH:LINENUM DATE TIME : print_temporary_table()
0|Zero|Cool
1|Acid|Burn
2|Cereal|Killer
3|Lord|Nikon
4|Joey|
5|Zero|Cool
[ INFO] PATH:LINENUM DATE TIME : Parsing done for SQL command []


------------------------------
Using config verbosity level: DEBUG
------------------------------


select * from nonexistanttable;

INDEX fake_index "^notaglobal(""fake_index"",fields(""name""),fields(""age""),keys(""id""))";

select * from names;
[ INFO] PATH:LINENUM DATE TIME : Loaded config from ./octo.conf
[ERROR] PATH:LINENUM DATE TIME : Unknown table: NONEXISTANTTABLE

select * from nonexistanttable;
              ^^^^^^^^^^^^^^^^
[ERROR] PATH:LINENUM DATE TIME : Error parsing statement: select * from nonexistanttable;
[ INFO] PATH:LINENUM DATE TIME : Parsing done for SQL command [select * from nonexistanttable;]
[ INFO] PATH:LINENUM DATE TIME : Returning failure from run_query
[ WARN] PATH:LINENUM DATE TIME : Feature not implemented: INDEX statements
[ INFO] PATH:LINENUM DATE TIME : Parsing done for SQL command [INDEX fake_index "^notaglobal(""fake_index"",fields(""name""),fields(""age""),keys(""id""))";]
[ INFO] PATH:LINENUM DATE TIME : Generating SQL for CURSOR_NUM
[ INFO] PATH:LINENUM DATE TIME : Parsing done for SQL command [select * from names;]
[ INFO] PATH:LINENUM DATE TIME : Generating SQL for CURSOR_NUM
[ INFO] PATH:LINENUM DATE TIME : Generating M file [./_ydboctoP*.m] (to execute SQL query)
[DEBUG] PATH:LINENUM DATE TIME : LOGICAL_PLAN BEFORE optimize_logical_plan() follows
LP_INSERT: 
  LP_PROJECT: 
    LP_COLUMN_LIST: 
      LP_WHERE: 
        LP_COLUMN_ALIAS: NAMES(1).ID
        LP_COLUMN_LIST_ALIAS: 
        - type: INTEGER_LITERAL
        - alias: ID
      LP_COLUMN_LIST: 
        LP_WHERE: 
          LP_COLUMN_ALIAS: NAMES(1).FIRSTNAME
          LP_COLUMN_LIST_ALIAS: 
          - type: STRING_LITERAL
          - alias: FIRSTNAME
        LP_COLUMN_LIST: 
          LP_WHERE: 
            LP_COLUMN_ALIAS: NAMES(1).LASTNAME
            LP_COLUMN_LIST_ALIAS: 
            - type: STRING_LITERAL
            - alias: LASTNAME
    LP_SELECT: 
      LP_TABLE_JOIN: 
        LP_TABLE: NAMES
      LP_CRITERIA: 
        LP_KEYS: 
        LP_SELECT_OPTIONS: 
          LP_WHERE: 
          LP_SELECT_MORE_OPTIONS: 
            LP_KEYWORDS: 
  LP_OUTPUT: 
    LP_KEY: 
    - table_name:  
    - column_name:  
    - unique_id: 3
    - method: LP_KEY_ADVANCE
    - xref_key: false
    - uses_xref_key: false

[DEBUG] PATH:LINENUM DATE TIME : LOGICAL_PLAN AFTER optimize_logical_plan() follows
LP_INSERT: 
  LP_PROJECT: 
    LP_COLUMN_LIST: 
      LP_WHERE: 
        LP_COLUMN_ALIAS: NAMES(1).ID
        LP_COLUMN_LIST_ALIAS: 
        - type: INTEGER_LITERAL
        - alias: ID
      LP_COLUMN_LIST: 
        LP_WHERE: 
          LP_COLUMN_ALIAS: NAMES(1).FIRSTNAME
          LP_COLUMN_LIST_ALIAS: 
          - type: STRING_LITERAL
          - alias: FIRSTNAME
        LP_COLUMN_LIST: 
          LP_WHERE: 
            LP_COLUMN_ALIAS: NAMES(1).LASTNAME
            LP_COLUMN_LIST_ALIAS: 
            - type: STRING_LITERAL
            - alias: LASTNAME
    LP_SELECT: 
      LP_TABLE_JOIN: 
        LP_TABLE: NAMES
      LP_CRITERIA: 
        LP_KEYS: 
          LP_KEY: 
          - table_name: NAMES
          - column_name: ID
          - unique_id: 1
          - method: LP_KEY_ADVANCE
          - xref_key: false
          - uses_xref_key: false
        LP_SELECT_OPTIONS: 
          LP_WHERE: 
          LP_SELECT_MORE_OPTIONS: 
            LP_KEYWORDS: 
  LP_OUTPUT: 
    LP_KEY: 
    - table_name:  
    - column_name:  
    - unique_id: 3
    - method: LP_KEY_ADVANCE
    - xref_key: false
    - uses_xref_key: false

[ INFO] PATH:LINENUM DATE TIME : print_temporary_table()
0|Zero|Cool
1|Acid|Burn
2|Cereal|Killer
3|Lord|Nikon
4|Joey|
5|Zero|Cool
[ INFO] PATH:LINENUM DATE TIME : Parsing done for SQL command []


------------------------------
Using config verbosity level: TRACE
------------------------------


select * from nonexistanttable;

INDEX fake_index "^notaglobal(""fake_index"",fields(""name""),fields(""age""),keys(""id""))";

select * from names;
[ INFO] PATH:LINENUM DATE TIME : Loaded config from ./octo.conf
[TRACE] PATH:LINENUM DATE TIME : Octo started
Starting parse
Entering state 0
Reading a token: Next token is token SELECT (: )
Shifting token SELECT (: )
Entering state 11
Reading a token: Next token is token ASTERISK (: )
Reducing stack by rule 37 (line xxx):
-> $$ = nterm set_quantifier (: )
Stack now 0 11
Entering state 71
Next token is token ASTERISK (: )
Shifting token ASTERISK (: )
Entering state 154
Reducing stack by rule 31 (line xxx):
   $1 = token ASTERISK (: )
-> $$ = nterm select_list (: )
Stack now 0 11 71
Entering state 155
Reading a token: Next token is token FROM (: )
Shifting token FROM (: )
Entering state 249
Reading a token: Next token is token IDENTIFIER_START (: )
Shifting token IDENTIFIER_START (: )
Entering state 8
Reducing stack by rule 329 (line xxx):
   $1 = token IDENTIFIER_START (: )
-> $$ = nterm identifier_body (: )
Stack now 0 11 71 155 249
Entering state 59
Reducing stack by rule 328 (line xxx):
   $1 = nterm identifier_body (: )
-> $$ = nterm regular_identifier (: )
Stack now 0 11 71 155 249
Entering state 58
Reducing stack by rule 327 (line xxx):
   $1 = nterm regular_identifier (: )
-> $$ = nterm actual_identifier (: )
Stack now 0 11 71 155 249
Entering state 57
Reducing stack by rule 326 (line xxx):
   $1 = nterm actual_identifier (: )
-> $$ = nterm identifier (: )
Stack now 0 11 71 155 249
Entering state 56
Reducing stack by rule 303 (line xxx):
   $1 = nterm identifier (: )
-> $$ = nterm column_name (: )
Stack now 0 11 71 155 249
Entering state 54
Reading a token: Next token is token SEMICOLON (: )
Reducing stack by rule 49 (line xxx):
-> $$ = nterm table_reference_tail (: )
Stack now 0 11 71 155 249 54
Entering state 140
Reducing stack by rule 44 (line xxx):
   $1 = nterm column_name (: )
   $2 = nterm table_reference_tail (: )
[TRACE] PATH:LINENUM DATE TIME : Searching for table NONEXISTANTTABLE
[ERROR] PATH:LINENUM DATE TIME : Unknown table: NONEXISTANTTABLE

select * from nonexistanttable;
              ^^^^^^^^^^^^^^^^
Stack now 0 11 71 155 249
Error: popping token FROM (: )
Stack now 0 11 71 155
Error: popping nterm select_list (: )
Stack now 0 11 71
Error: popping nterm set_quantifier (: )
Stack now 0 11
Error: popping token SELECT (: )
Stack now 0
Shifting token error (: )
Entering state 1
Next token is token SEMICOLON (: )
Shifting token SEMICOLON (: )
Entering state 18
Reducing stack by rule 10 (line xxx):
   $1 = token SEMICOLON (: )
-> $$ = nterm semicolon_or_eof (: )
Stack now 0 1
Entering state 60
Reducing stack by rule 6 (line xxx):
   $1 = token error (: )
   $2 = nterm semicolon_or_eof (: )
Stack now 0
[ERROR] PATH:LINENUM DATE TIME : Error parsing statement: select * from nonexistanttable;
[ INFO] PATH:LINENUM DATE TIME : Parsing done for SQL command [select * from nonexistanttable;]
[ INFO] PATH:LINENUM DATE TIME : Returning failure from run_query
Starting parse
Entering state 0
Reading a token: Next token is token INDEX (: )
Shifting token INDEX (: )
Entering state 9
Reading a token: Next token is token IDENTIFIER_START (: )
Shifting token IDENTIFIER_START (: )
Entering state 8
Reducing stack by rule 329 (line xxx):
   $1 = token IDENTIFIER_START (: )
-> $$ = nterm identifier_body (: )
Stack now 0 9
Entering state 59
Reducing stack by rule 328 (line xxx):
   $1 = nterm identifier_body (: )
-> $$ = nterm regular_identifier (: )
Stack now 0 9
Entering state 58
Reducing stack by rule 327 (line xxx):
   $1 = nterm regular_identifier (: )
-> $$ = nterm actual_identifier (: )
Stack now 0 9
Entering state 57
Reducing stack by rule 326 (line xxx):
   $1 = nterm actual_identifier (: )
-> $$ = nterm identifier (: )
Stack now 0 9
Entering state 56
Reducing stack by rule 303 (line xxx):
   $1 = nterm identifier (: )
-> $$ = nterm column_name (: )
Stack now 0 9
Entering state 66
Reducing stack by rule 323 (line xxx):
   $1 = nterm column_name (: )
-> $$ = nterm index_name (: )
Stack now 0 9
Entering state 67
Reading a token: Next token is token LITERAL (: )
Shifting token LITERAL (: )
Entering state 145
Reducing stack by rule 364 (line xxx):
   $1 = token LITERAL (: )
-> $$ = nterm literal_value (: )
Stack now 0 9 67
Entering state 146
Reducing stack by rule 322 (line xxx):
   $1 = token INDEX (: )
   $2 = nterm index_name (: )
   $3 = nterm literal_value (: )
[ WARN] PATH:LINENUM DATE TIME : Feature not implemented: INDEX statements
-> $$ = nterm index_definition (: )
Stack now 0
Entering state 55
Reducing stack by rule 289 (line xxx):
   $1 = nterm index_definition (: )
-> $$ = nterm sql_schema_definition_statement (: )
Stack now 0
Entering state 52
Reducing stack by rule 285 (line xxx):
   $1 = nterm sql_schema_definition_statement (: )
-> $$ = nterm sql_schema_statement (: )
Stack now 0
Entering state 50
Reading a token: Next token is token SEMICOLON (: )
Shifting token SEMICOLON (: )
Entering state 18
Reducing stack by rule 10 (line xxx):
   $1 = token SEMICOLON (: )
-> $$ = nterm semicolon_or_eof (: )
Stack now 0 50
Entering state 138
Reducing stack by rule 1 (line xxx):
   $1 = nterm sql_schema_statement (: )
   $2 = nterm semicolon_or_eof (: )
Stack now 0
[ INFO] PATH:LINENUM DATE TIME : Parsing done for SQL command [INDEX fake_index "^notaglobal(""fake_index"",fields(""name""),fields(""age""),keys(""id""))";]
[ INFO] PATH:LINENUM DATE TIME : Generating SQL for CURSOR_NUM
Starting parse
Entering state 0
Reading a token: Next token is token SELECT (: )
Shifting token SELECT (: )
Entering state 11
Reading a token: Next token is token ASTERISK (: )
Reducing stack by rule 37 (line xxx):
-> $$ = nterm set_quantifier (: )
Stack now 0 11
Entering state 71
Next token is token ASTERISK (: )
Shifting token ASTERISK (: )
Entering state 154
Reducing stack by rule 31 (line xxx):
   $1 = token ASTERISK (: )
-> $$ = nterm select_list (: )
Stack now 0 11 71
Entering state 155
Reading a token: Next token is token FROM (: )
Shifting token FROM (: )
Entering state 249
Reading a token: Next token is token IDENTIFIER_START (: )
Shifting token IDENTIFIER_START (: )
Entering state 8
Reducing stack by rule 329 (line xxx):
   $1 = token IDENTIFIER_START (: )
-> $$ = nterm identifier_body (: )
Stack now 0 11 71 155 249
Entering state 59
Reducing stack by rule 328 (line xxx):
   $1 = nterm identifier_body (: )
-> $$ = nterm regular_identifier (: )
Stack now 0 11 71 155 249
Entering state 58
Reducing stack by rule 327 (line xxx):
   $1 = nterm regular_identifier (: )
-> $$ = nterm actual_identifier (: )
Stack now 0 11 71 155 249
Entering state 57
Reducing stack by rule 326 (line xxx):
   $1 = nterm actual_identifier (: )
-> $$ = nterm identifier (: )
Stack now 0 11 71 155 249
Entering state 56
Reducing stack by rule 303 (line xxx):
   $1 = nterm identifier (: )
-> $$ = nterm column_name (: )
Stack now 0 11 71 155 249
Entering state 54
Reading a token: Next token is token SEMICOLON (: )
Reducing stack by rule 49 (line xxx):
-> $$ = nterm table_reference_tail (: )
Stack now 0 11 71 155 249 54
Entering state 140
Reducing stack by rule 44 (line xxx):
   $1 = nterm column_name (: )
   $2 = nterm table_reference_tail (: )
[TRACE] PATH:LINENUM DATE TIME : Searching for table NAMES
-> $$ = nterm table_reference (: )
Stack now 0 11 71 155 249
Entering state 352
Next token is token SEMICOLON (: )
Reducing stack by rule 43 (line xxx):
   $1 = token FROM (: )
   $2 = nterm table_reference (: )
-> $$ = nterm from_clause (: )
Stack now 0 11 71 155
Entering state 251
Next token is token SEMICOLON (: )
Reducing stack by rule 75 (line xxx):
-> $$ = nterm where_clause (: )
Stack now 0 11 71 155 251
Entering state 355
Next token is token SEMICOLON (: )
Reducing stack by rule 77 (line xxx):
-> $$ = nterm group_by_clause (: )
Stack now 0 11 71 155 251 355
Entering state 450
Next token is token SEMICOLON (: )
Reducing stack by rule 84 (line xxx):
-> $$ = nterm having_clause (: )
Stack now 0 11 71 155 251 355 450
Entering state 534
Reducing stack by rule 36 (line xxx):
   $1 = nterm from_clause (: )
   $2 = nterm where_clause (: )
   $3 = nterm group_by_clause (: )
   $4 = nterm having_clause (: )
-> $$ = nterm table_expression (: )
Stack now 0 11 71 155
Entering state 250
Next token is token SEMICOLON (: )
Reducing stack by rule 28 (line xxx):
   $1 = token SELECT (: )
   $2 = nterm set_quantifier (: )
   $3 = nterm select_list (: )
   $4 = nterm table_expression (: )
-> $$ = nterm query_specification (: )
Stack now 0
Entering state 27
Next token is token SEMICOLON (: )
Reducing stack by rule 16 (line xxx):
-> $$ = nterm optional_query_words (: )
Stack now 0 27
Entering state 118
Reducing stack by rule 14 (line xxx):
   $1 = nterm query_specification (: )
   $2 = nterm optional_query_words (: )
-> $$ = nterm sql_select_statement (: )
Stack now 0
Entering state 26
Reducing stack by rule 277 (line xxx):
   $1 = nterm sql_select_statement (: )
-> $$ = nterm simple_table (: )
Stack now 0
Entering state 47
Reducing stack by rule 273 (line xxx):
   $1 = nterm simple_table (: )
-> $$ = nterm non_join_query_primary (: )
Stack now 0
Entering state 46
Reducing stack by rule 267 (line xxx):
   $1 = nterm non_join_query_primary (: )
-> $$ = nterm non_join_query_term (: )
Stack now 0
Entering state 45
Next token is token SEMICOLON (: )
Reducing stack by rule 252 (line xxx):
   $1 = nterm non_join_query_term (: )
-> $$ = nterm non_join_query_expression (: )
Stack now 0
Entering state 43
Reducing stack by rule 250 (line xxx):
   $1 = nterm non_join_query_expression (: )
-> $$ = nterm query_expression (: )
Stack now 0
Entering state 42
Next token is token SEMICOLON (: )
Shifting token SEMICOLON (: )
Entering state 18
Reducing stack by rule 10 (line xxx):
   $1 = token SEMICOLON (: )
-> $$ = nterm semicolon_or_eof (: )
Stack now 0 42
Entering state 136
Reducing stack by rule 3 (line xxx):
   $1 = nterm query_expression (: )
   $2 = nterm semicolon_or_eof (: )
Stack now 0
[ INFO] PATH:LINENUM DATE TIME : Parsing done for SQL command [select * from names;]
[ INFO] PATH:LINENUM DATE TIME : Generating SQL for CURSOR_NUM
[TRACE] PATH:LINENUM DATE TIME : Entering hash_canonical_query
[ INFO] PATH:LINENUM DATE TIME : Generating M file [./_ydboctoP*.m] (to execute SQL query)
[TRACE] PATH:LINENUM DATE TIME : Entering emit_select_statement
[DEBUG] PATH:LINENUM DATE TIME : LOGICAL_PLAN BEFORE optimize_logical_plan() follows
LP_INSERT: 
  LP_PROJECT: 
    LP_COLUMN_LIST: 
      LP_WHERE: 
        LP_COLUMN_ALIAS: NAMES(1).ID
        LP_COLUMN_LIST_ALIAS: 
        - type: INTEGER_LITERAL
        - alias: ID
      LP_COLUMN_LIST: 
        LP_WHERE: 
          LP_COLUMN_ALIAS: NAMES(1).FIRSTNAME
          LP_COLUMN_LIST_ALIAS: 
          - type: STRING_LITERAL
          - alias: FIRSTNAME
        LP_COLUMN_LIST: 
          LP_WHERE: 
            LP_COLUMN_ALIAS: NAMES(1).LASTNAME
            LP_COLUMN_LIST_ALIAS: 
            - type: STRING_LITERAL
            - alias: LASTNAME
    LP_SELECT: 
      LP_TABLE_JOIN: 
        LP_TABLE: NAMES
      LP_CRITERIA: 
        LP_KEYS: 
        LP_SELECT_OPTIONS: 
          LP_WHERE: 
          LP_SELECT_MORE_OPTIONS: 
            LP_KEYWORDS: 
  LP_OUTPUT: 
    LP_KEY: 
    - table_name:  
    - column_name:  
    - unique_id: 3
    - method: LP_KEY_ADVANCE
    - xref_key: false
    - uses_xref_key: false

[DEBUG] PATH:LINENUM DATE TIME : LOGICAL_PLAN AFTER optimize_logical_plan() follows
LP_INSERT: 
  LP_PROJECT: 
    LP_COLUMN_LIST: 
      LP_WHERE: 
        LP_COLUMN_ALIAS: NAMES(1).ID
        LP_COLUMN_LIST_ALIAS: 
        - type: INTEGER_LITERAL
        - alias: ID
      LP_COLUMN_LIST: 
        LP_WHERE: 
          LP_COLUMN_ALIAS: NAMES(1).FIRSTNAME
          LP_COLUMN_LIST_ALIAS: 
          - type: STRING_LITERAL
          - alias: FIRSTNAME
        LP_COLUMN_LIST: 
          LP_WHERE: 
            LP_COLUMN_ALIAS: NAMES(1).LASTNAME
            LP_COLUMN_LIST_ALIAS: 
            - type: STRING_LITERAL
            - alias: LASTNAME
    LP_SELECT: 
      LP_TABLE_JOIN: 
        LP_TABLE: NAMES
      LP_CRITERIA: 
        LP_KEYS: 
          LP_KEY: 
          - table_name: NAMES
          - column_name: ID
          - unique_id: 1
          - method: LP_KEY_ADVANCE
          - xref_key: false
          - uses_xref_key: false
        LP_SELECT_OPTIONS: 
          LP_WHERE: 
          LP_SELECT_MORE_OPTIONS: 
            LP_KEYWORDS: 
  LP_OUTPUT: 
    LP_KEY: 
    - table_name:  
    - column_name:  
    - unique_id: 3
    - method: LP_KEY_ADVANCE
    - xref_key: false
    - uses_xref_key: false

[TRACE] PATH:LINENUM DATE TIME : Searching for column ID in table NAMES
[TRACE] PATH:LINENUM DATE TIME : Searching for column FIRSTNAME in table NAMES
[TRACE] PATH:LINENUM DATE TIME : Searching for column LASTNAME in table NAMES
[ INFO] PATH:LINENUM DATE TIME : print_temporary_table()
0|Zero|Cool
1|Acid|Burn
2|Cereal|Killer
3|Lord|Nikon
4|Joey|
5|Zero|Cool
Starting parse
Entering state 0
Reading a token: Next token is token ENDOFFILE (: )
Shifting token ENDOFFILE (: )
Entering state 20
Reducing stack by rule 11 (line xxx):
   $1 = token ENDOFFILE (: )
-> $$ = nterm semicolon_or_eof (: )
Stack now 0
Entering state 24
Reducing stack by rule 8 (line xxx):
   $1 = nterm semicolon_or_eof (: )
Stack now 0
[ INFO] PATH:LINENUM DATE TIME : Parsing done for SQL command []


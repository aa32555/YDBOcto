#################################################################
#								#
# Copyright (c) 2019 YottaDB LLC and/or its subsidiaries.	#
# All rights reserved.						#
#								#
#	This source code contains the intellectual property	#
#	of its copyright holder(s), and is made available	#
#	under a license.  If you do not know the terms of	#
#	the license, please stop and do not read further.	#
#								#
#################################################################

load test_helpers

setup() {
  init_test
  createdb
  load_fixture names.sql
  load_fixture names.zwr
}

@test "select wildcard columns" {
  run octo <<OCTO
select * from names;
OCTO
  [[ "$output" =~ "Zero|Cool" ]]
}

@test "select columns via short name" {
  run octo <<OCTO
select firstName, lastName from names;
OCTO
  [[ "$output" =~ "Zero|Cool" ]]
  ! [[ "$output" =~ "0|Zero|Cool" ]]
}

@test "select columns via long name" {
  run octo <<OCTO
select names.firstName, names.lastName from names;
OCTO
  [[ "$output" =~ "Zero|Cool" ]]
  ! [[ "$output" =~ "0|Zero|Cool" ]]
}

@test "select column which doesn't exist" {
  octo <<OCTO 2>&1 | tee output.txt
select names.hackName from names;
OCTO
  run cat output.txt
  [[ "$output" =~ "ERROR" ]]
  [[ "$output" =~ "Unknown column" ]]
}

@test "select column with invalid typing" {
  octo <<OCTO 2>&1 | tee output.txt
select names.firstName + 5 from names;
OCTO
  run cat output.txt
  [[ "$output" =~ "ERROR" ]]
  [[ "$output" =~ "Type mismatch" ]]
}

@test "select with a semicolon in string" {
  octo <<OCTO 2>&1 | tee output.txt
select * from names where firstName = "; hello world";
OCTO
  run cat output.txt
  ! [[ "$output" =~ "ERROR" ]]
  [[ $(grep -c "|" output.txt) == "0" ]]
}

# @test "select from table with multiple keys" {
#   octo <<OCTO 2>&1 | tee output.txt
# create table names2 (
#   id INTEGER PRIMARY KEY,
#   firstName VARCHAR(30) KEY NUM 1,
#   lastName VARCHAR(30) KEY NUM 2
# );
# insert into names2 (select * from names where firstName <> "" AND lastName <> "");
# select * from names2;
# OCTO
#   run cat output.txt
#   [[ "$output" =~ "Zero|Cool" ]]
# }
#

@test "select without a from statement" {
  octo <<OCTO 2>&1 | tee output.txt
select 17+5*5;
OCTO
  [[ $( grep -c "^42$" output.txt) == "1" ]]
}

@test "select without a from with a syntax error" {
  octo <<OCTO 2>&1 | tee output.txt
select * asdfasdfsdf;
OCTO
  [[ $( grep -c "ERROR" output.txt) == "1" ]]
}

@test "select so many columns it would exceed the M line length" {
  octo -vv <<OCTO 2>&1 | tee output.txt
SELECT firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName
FROM names;
OCTO
}

@test "select using a CASE statement" {
  octo <<OCTO 2>&1 | tee output.txt
SELECT
  firstName
  , CASE firstName
    WHEN "Zero" THEN "Zero Cool"
    WHEN "Acid" THEN "Acid Burn"
    WHEN "Cereal" THEN "Cereal Killer"
    ELSE firstName
    END
FROM names;
OCTO
  [[ "$(grep -c "Zero" output.txt)" == "3" ]]
}

@test "select a negative number" {
  octo <<OCTO 2>&1 | tee output.txt
SELECT -5
FROM names;
OCTO
  [[ "$(grep -c -- "-5" output.txt)" != "0" ]]
}

@test "select some columns with C-style comments interwoven" {
  octo <<OCTO 2>&1 | tee output.txt
SELECT firstName /* We need first names */
  , lastName /* We also need last names */
  /* It might also be helpful to get id
   * but mostly because it lets me test multiline
   * comments */
  , id
# We're going to try a different kind of comment here, just because
FROM names;
OCTO
  [[ "$(grep -c "|" output.txt)" == "6" ]]
}

@test "order by a calculated column" {
  octo <<OCTO 2>&1 | tee output.txt
SELECT nspname AS TABLE_SCHEM,
  NULL AS TABLE_CATALOG
FROM pg_catalog.pg_namespace
WHERE nspname <> 'pg_toast'
  AND (nspname !~ '^pg_temp_'  OR nspname = (pg_catalog.current_schemas(true))[1])
  AND (nspname !~ '^pg_toast_temp_'  OR nspname =
    replace((pg_catalog.current_schemas(true))[1], 'pg_temp_', 'pg_toast_temp_'))
ORDER BY TABLE_SCHEM;
OCTO
  [[ $(grep -c "|" output.txt) -eq 3 ]]
}

@test "cast int column to text" {
  octo <<OCTO 2>&1 | tee output.txt
SELECT *
FROM names
WHERE (id :: text) = "0";
OCTO
  [[ "$(grep -c "|" output.txt)" == "1" ]]
}

@test "verify that columns are cleaned after data is sent" {
  octo <<OCTO 2>&1 | tee output.txt
SELECT * FROM names;
OCTO
  $ydb_dist/mumps -di <<OCTO &> output2.txt
ZWRITE ^%ydboctocursor
OCTO
  [[ $(grep -c "%ydboctocursor(1" output2.txt) -eq 0 ]]
}

@test "TSC01 cast a string to an integer" {
  octo <<OCTO 2>&1 | tee output.txt
SELECT firstName :: integer + 5 FROM names;
OCTO
  verify_output TSC01 output.txt noinfo nodebug
}

@test "TSC02 select an alias with a shorter name" {
  octo <<OCTO 2>&1 | tee output.txt
SELECT t.lastName
FROM (
  SELECT n1.id FROM names n1
) tt
INNER JOIN names t
ON (t.id = tt.id);
OCTO
  verify_output TSC02 output.txt noinfo nodebug
}

@test "TSC03 SELECT of column name with alias with ORDER BY using alias name" {
  octo <<OCTO &> output.txt
SELECT firstname as alias from names order by alias
OCTO
  verify_output TSC03 output.txt noinfo nodebug
}

@test "TSC04 SELECT of invalid column name in user-defined table" {
  octo <<OCTO &> output.txt
SELECT invalid FROM names;
OCTO
  verify_output TSC04 output.txt noinfo nodebug
}

@test "TSC05 SELECT of invalid column name in derived table from a level-1 sub-query" {
  octo <<OCTO &> output.txt
SELECT invalid from (SELECT invalid from names);
OCTO
  verify_output TSC05 output.txt noinfo nodebug
}

@test "TSC06 SELECT of invalid column name in derived table from a level-2 sub-query" {
  octo <<OCTO &> output.txt
SELECT invalid from (SELECT invalid from (SELECT invalid from names));
OCTO
  verify_output TSC06 output.txt noinfo nodebug
}

@test "TSC07 Miscellaneous SELECT using valid and/or invalid column names and a level-1 sub-query" {
  cat > queries_input.txt << CAT
select * from (select * from names as n2) as n1;
select * from (select * from names as n2);
select * from (select * from names) as n1;
select * from (select * from names);
select * from (select firstname from names) as n1;
select * from (select firstname from names);
select * from (select invalid from names) as n1;
select * from (select invalid from names);
select * from (select n1.firstname from names) as n1;
select * from (select n1.invalid from names) as n1;
select * from (select n2.firstname from names as n2) as n1;
select * from (select n2.firstname from names as n2);
select * from (select n2.invalid from names as n2) as n1;
select * from (select n2.invalid from names as n2);
select firstname from (select * from names as n2) as n1;
select firstname from (select * from names as n2);
select firstname from (select * from names) as n1;
select firstname from (select * from names);
select firstname from (select firstname from names) as n1;
select firstname from (select firstname from names);
select firstname from (select invalid from names) as n1;
select firstname from (select invalid from names);
select firstname from (select lastname from names as n2) as n1;
select firstname from (select lastname from names);
select firstname from (select n1.firstname from names) as n1;
select firstname from (select n1.invalid from names) as n1;
select firstname from (select n2.firstname from names as n2);
select firstname from (select n2.invalid from names as n2);
select invalid from (select * from names as n2) as n1;
select invalid from (select * from names as n2);
select invalid from (select * from names) as n1;
select invalid from (select * from names);
select invalid from (select firstname from names) as n1;
select invalid from (select firstname from names);
select invalid from (select invalid from names as n2) as n1;
select invalid from (select invalid from names) as n1;
select invalid from (select invalid from names);
select invalid from (select n1.firstname from names) as n1;
select invalid from (select n1.invalid from names) as n1;
select invalid from (select n2.firstname from names as n2);
select invalid from (select n2.invalid from names as n2);
select invalid as invalid1 from (select invalid from names);
select invalid as invalid from names;
select invalid1 as invalid from names;
select invalid as invalid1 from names;
select invalid1 from (select invalid2 from names) as n1;
select invalid1 from (select invalid2 from names);
select invalid1 from (select n1.invalid2 from names) as n1;
select invalid1 from (select n2.invalid2 from names as n2);
select invalid1 from (select invalid as invalid1 from names);
select n1.firstname from (select * from names as n2) as n1;
select n1.firstname from (select * from names) as n1;
select n1.firstname from (select n1.firstname from names) as n1;
select n1.firstname from (select n1.invalid from names) as n1;
select n1.firstname from (select n2.firstname from names as n2) as n1;
select n1.firstname from (select n2.invalid from names as n2) as n1;
select n1.invalid from (select * from names as n2) as n1;
select n1.invalid from (select * from names) as n1;
select n1.invalid from (select n1.firstname from names) as n1;
select n1.invalid from (select n1.invalid from names) as n1;
select n1.invalid from (select n2.firstname from names as n2) as n1;
select n1.invalid from (select n2.invalid from names as n2) as n1;
select n1.invalid1 from (select n1.invalid2 from names) as n1;
select n1.invalid1 from (select n2.invalid2 from names as n2) as n1;
select n2.firstname from (select * from names as n2);
select n2.firstname from (select n2.firstname from names as n2);
select n2.firstname from (select n2.invalid from names as n2);
select n2.invalid from (select * from names as n2);
select n2.invalid from (select n2.firstname from names as n2);
select n2.invalid from (select n2.invalid from names as n2);
select n2.invalid1 from (select n2.invalid2 from names as n2);
select NULL as a from names order by a;
CAT
  inputfile="queries_input.txt"
  linenum=1
  set -f	# we use * in the query file so avoid expanding it in the loop below
  while read -r line
  do
  echo $line > query${linenum}.sql
  echo "Running query file query${linenum}.sql : [$line]" >> output.txt
  echo "-------------------------------------------------" >> output.txt
  octo -f query${linenum}.sql >> output.txt 2>&1
  ((linenum++))
  echo "" >> output.txt
  done < $inputfile
  verify_output TSC07 output.txt
}

@test "TSC08 Select unknown column with 2 inner joins" {
  octo <<OCTO 2>&1 | tee output.txt
CREATE TABLE ORDER1(
 order1_id INTEGER PRIMARY KEY,
 status INTEGER,
 current_action INTEGER
);

CREATE TABLE ORDERORDERACTIONS(
 order1_id INTEGER PRIMARY KEY,
 order_order_actions_id INTEGER KEY NUM 1,
 action CHARACTER(12)
);

CREATE TABLE ORDERSTATUS(
 order_status_id INTEGER PRIMARY KEY
);

SELECT order1
FROM   order1 A
       inner join orderorderactions B
               ON A.current_action = B.order_order_actions_id
       inner join orderstatus C
               ON A.status = C.order_status_id
WHERE  B.action = "NW";
OCTO
  verify_output TSC08 output.txt
}

@test "TSC09 : Set envvar ydb_lvnullsubs=2 and try to select from table" {
  export ydb_lvnullsubs=2
  octo <<OCTO 2>&1 | tee output.txt
select * from names limit 1;
OCTO
  verify_output TSC09 output.txt
}

@test "TSC10 : Run M function inside of select statement" {
  DDOLAR='$$'
  cp @PROJECT_SOURCE_DIR@/tests/fixtures/USERFUNC1.m .
  octo <<OCTO 2>&1 | tee output.txt
select $DDOLAR^userfunc1(42) from names;
OCTO
  verify_output TSC10 output.txt
}

@test "TSC11 : test that multiline strings are inserted in to generated code correctly" {
  octo <<OCTO 2>&1 | tee output.txt
select """
 set ^TSC11(1)=1
;"
from names;
OCTO
  yottadb -run %XCMD 'write:$get(^TSC11(1))="" "PASS: ^TSC11(1) is unset",! write:$get(^TSC11(1))=1 "FAIL: set ^TSC11(1)=1 was run when it should not have been",!' | tee -a output.txt
  grepCount=$(grep -o '_\$C(10)_' _ydboctoP* | wc -l)
  if [ $grepCount == "2" ]; then
    echo 'PASS: generated M code has the correct number of _$c(10)_' | tee -a output.txt
  else
    echo "FAIL: generated M code has the incorrect number of _\$c(10)_: Expected: 2; Actual: $grepCount" | tee -a output.txt
  fi
  verify_output TSC11 output.txt
}

@test "TSC12 : #302 : Run M function inside of SELECT statement with a LEFT JOIN (used to issue LVUNDEF error)" {
  $ydb_dist/mumps -run %XCMD 'set ^%ydboctoocto("functions","DOLLAR_ZWRITE")="$ZWRITE"'
  octo <<OCTO 2>&1 | tee output.txt
SELECT    n1.firstname, DOLLAR_ZWRITE(n2.firstname)
FROM      names n1
LEFT JOIN names n2
ON        n1.lastname = n2.firstname;
OCTO
  verify_output TSC12 output.txt
}

@test "TSC13 : #303 : Run M function inside of SELECT statement with a LEFT JOIN (used to issue <Problem resolving owner for deferred plan> error)" {
  $ydb_dist/mumps -run %XCMD 'set ^%ydboctoocto("functions","DOLLAR_ZWRITE")="$ZWRITE"'
  octo <<OCTO 2>&1 | tee output.txt
SELECT    DOLLAR_ZWRITE(n2.firstname)
FROM      names n1
LEFT JOIN names n2
ON        n1.lastname = n2.firstname;
OCTO
  verify_output TSC13 output.txt
}

@test "TSC14 : #338 : SELECT from sub-query returns incorrect results if sub-query has constants in its select column list" {
  cat <<CAT_EOF > input.sql
select * from (select 1,2,3,4);
select * from (select 2,3,4,5);
CAT_EOF
  cat input.sql > output.txt
  octo -f input.sql >> output.txt 2>&1
  verify_output TSC14 output.txt
}

@test "TSC15 : #340 : Incorrect <Unknown column> error for column names inherited from sub-query" {
  cat <<CAT_EOF > input.sql
select a,b from (select 1 as a, 2 as b);
select a,c from (select 1 as a, 2 as b);
select c,b from (select 1 as a, 2 as b);
CAT_EOF
  cat input.sql > output.txt
  octo -f input.sql >> output.txt 2>&1
  verify_output TSC15 output.txt
}

@test "TSC16 : #282 : Test of ABS() function as well as lp_verify_structure() for LP_COLUMN_LIST" {
  cat <<CAT_EOF > input.sql
select abs(-2*id) from names;
select abs(-1.45);
select abs(1.45);
select abs(1.45-2.50);
select abs(1.23456789-9.87654321);
-- The below tests verify that lp_verify_structure() does handle various possible operand[0] types for LP_COLUMN_LIST
select abs(id+1) from names limit 1;            	-- LP_ADDITION
select abs(id-1) from names limit 1;                    -- LP_SUBTRACTION
select abs(id*1) from names limit 1;                    -- LP_MULTIPLICATION
select abs(id/1) from names limit 1;                    -- LP_DIVISION
select abs("abcd" || "efgh");                   	-- LP_CONCAT
select abs(-id) from names limit 1;                     -- LP_NEGATIVE
select abs(id) from (select * from names) limit 1;      -- LP_DERIVED_COLUMN
select abs(id+1) from (select * from names) limit 1;    -- LP_ADDITION
select abs(id-1) from (select * from names) limit 1;    -- LP_SUBTRACTION
select abs(id*1) from (select * from names) limit 1;    -- LP_MULTIPLICATION
select abs(id/1) from (select * from names) limit 1;    -- LP_DIVISION
select abs("abcd" || "efgh");                   	-- LP_CONCAT
select abs(-id) from (select * from names) limit 1;     -- LP_NEGATIVE
CAT_EOF
  cat input.sql > output.txt
  octo -f input.sql >> output.txt 2>&1
  verify_output TSC16 output.txt
}

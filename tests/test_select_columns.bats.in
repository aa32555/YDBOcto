#################################################################
#								#
# Copyright (c) 2019 YottaDB LLC and/or its subsidiaries.	#
# All rights reserved.						#
#								#
#	This source code contains the intellectual property	#
#	of its copyright holder(s), and is made available	#
#	under a license.  If you do not know the terms of	#
#	the license, please stop and do not read further.	#
#								#
#################################################################

load test_helpers

setup() {
  init_test
  createdb
  load_fixture names.sql
  load_fixture names.zwr
}

@test "select wildcard columns" {
  run octo <<OCTO
select * from names;
OCTO
  [[ "$output" =~ "Zero|Cool" ]]
}

@test "select columns via short name" {
  run octo <<OCTO
select firstName, lastName from names;
OCTO
  [[ "$output" =~ "Zero|Cool" ]]
  ! [[ "$output" =~ "0|Zero|Cool" ]]
}

@test "select columns via long name" {
  run octo <<OCTO
select names.firstName, names.lastName from names;
OCTO
  [[ "$output" =~ "Zero|Cool" ]]
  ! [[ "$output" =~ "0|Zero|Cool" ]]
}

@test "select column which doesn't exist" {
  octo <<OCTO 2>&1 | tee output.txt
select names.hackName from names;
OCTO
  run cat output.txt
  [[ "$output" =~ "ERROR" ]]
  [[ "$output" =~ "Unknown column" ]]
}

@test "select column with invalid typing" {
  octo <<OCTO 2>&1 | tee output.txt
select names.firstName + 5 from names;
OCTO
  run cat output.txt
  [[ "$output" =~ "ERROR" ]]
  [[ "$output" =~ "Type mismatch" ]]
}

@test "select with a semicolon in string" {
  octo <<OCTO 2>&1 | tee output.txt
select * from names where firstName = "; hello world";
OCTO
  run cat output.txt
  ! [[ "$output" =~ "ERROR" ]]
  [[ $(grep -c "|" output.txt) == "0" ]]
}

# @test "select from table with multiple keys" {
#   octo <<OCTO 2>&1 | tee output.txt
# create table names2 (
#   id INTEGER PRIMARY KEY,
#   firstName VARCHAR(30) KEY NUM 1,
#   lastName VARCHAR(30) KEY NUM 2
# );
# insert into names2 (select * from names where firstName <> "" AND lastName <> "");
# select * from names2;
# OCTO
#   run cat output.txt
#   [[ "$output" =~ "Zero|Cool" ]]
# }
#

@test "select without a from statement" {
  octo <<OCTO 2>&1 | tee output.txt
select 17+5*5;
OCTO
  [[ $( grep -c "^42$" output.txt) == "1" ]]
}

@test "select without a from with a syntax error" {
  octo <<OCTO 2>&1 | tee output.txt
select * asdfasdfsdf;
OCTO
  [[ $( grep -c "ERROR" output.txt) == "1" ]]
}

@test "select so many columns it would exceed the M line length" {
  octo -vv <<OCTO 2>&1 | tee output.txt
SELECT firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName,
 firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName, firstName
FROM names;
OCTO
}

@test "select using a CASE statement" {
  octo <<OCTO 2>&1 | tee output.txt
SELECT
  firstName
  , CASE firstName
    WHEN "Zero" THEN "Zero Cool"
    WHEN "Acid" THEN "Acid Burn"
    WHEN "Cereal" THEN "Cereal Killer"
    ELSE firstName
    END
FROM names;
OCTO
  [[ "$(grep -c "Zero" output.txt)" == "3" ]]
}

@test "select a negative number" {
  octo <<OCTO 2>&1 | tee output.txt
SELECT -5
FROM names;
OCTO
  [[ "$(grep -c -- "-5" output.txt)" != "0" ]]
}

@test "select some columns with C-style comments interwoven" {
  octo <<OCTO 2>&1 | tee output.txt
SELECT firstName /* We need first names */
  , lastName /* We also need last names */
  /* It might also be helpful to get id
   * but mostly because it lets me test multiline
   * comments */
  , id
# We're going to try a different kind of comment here, just because
FROM names;
OCTO
  [[ "$(grep -c "|" output.txt)" == "6" ]]
}

@test "order by a calculated column" {
  octo <<OCTO 2>&1 | tee output.txt
SELECT nspname AS TABLE_SCHEM,
  NULL AS TABLE_CATALOG
FROM pg_catalog.pg_namespace
WHERE nspname <> 'pg_toast'
  AND (nspname !~ '^pg_temp_'  OR nspname = (pg_catalog.current_schemas(true))[1])
  AND (nspname !~ '^pg_toast_temp_'  OR nspname =
    replace((pg_catalog.current_schemas(true))[1], 'pg_temp_', 'pg_toast_temp_'))
ORDER BY TABLE_SCHEM;
OCTO
  [[ $(grep -c "|" output.txt) -eq 3 ]]
}

@test "cast int column to text" {
  octo <<OCTO 2>&1 | tee output.txt
SELECT *
FROM names
WHERE (id :: text) = "0";
OCTO
  [[ "$(grep -c "|" output.txt)" == "1" ]]
}

@test "verify that columns are cleaned after data is sent" {
  octo <<OCTO 2>&1 | tee output.txt
SELECT * FROM names;
OCTO
  $ydb_dist/mumps -di <<OCTO &> output2.txt
ZWRITE ^%ydboctocursor
OCTO
  [[ $(grep -c "%ydboctocursor(1" output2.txt) -eq 0 ]]
}

@test "T0003 cast a string to an integer" {
  octo <<OCTO 2>&1 | tee output.txt
SELECT firstName :: integer + 5 FROM names;
OCTO
  verify_output T0003 output.txt
}

@test "T0010 select an alias with a shorter name" {
  octo <<OCTO 2>&1 | tee output.txt
SELECT t.lastName
FROM (
  SELECT n1.id FROM names n1
) tt
INNER JOIN names t
ON (t.id = tt.id);
OCTO
  verify_output T0010 output.txt
}

@test "T0016 SELECT of column name with alias with ORDER BY using alias name" {
  octo <<OCTO &> output.txt
SELECT firstname as alias from names order by alias
OCTO
  verify_output T0016 output.txt
}

@test "T0017 SELECT of invalid column name in user-defined table" {
  octo <<OCTO &> output.txt
SELECT invalid FROM names;
OCTO
  verify_output T0017 output.txt
}

@test "T0018 SELECT of invalid column name in derived table from a level-1 sub-query" {
  octo <<OCTO &> output.txt
SELECT invalid from (SELECT invalid from names);
OCTO
  verify_output T0018 output.txt
}

@test "T0019 SELECT of invalid column name in derived table from a level-2 sub-query" {
  octo <<OCTO &> output.txt
SELECT invalid from (SELECT invalid from (SELECT invalid from names));
OCTO
  verify_output T0019 output.txt
}

@test "T0020 Miscellaneous SELECT using valid and/or invalid column names and a level-1 sub-query" {
  cat > queries_input.txt << CAT
select * from (select * from names as n2) as n1;
select * from (select * from names as n2);
select * from (select * from names) as n1;
select * from (select * from names);
select * from (select firstname from names) as n1;
select * from (select firstname from names);
select * from (select invalid from names) as n1;
select * from (select invalid from names);
select * from (select n1.firstname from names) as n1;
select * from (select n1.invalid from names) as n1;
select * from (select n2.firstname from names as n2) as n1;
select * from (select n2.firstname from names as n2);
select * from (select n2.invalid from names as n2) as n1;
select * from (select n2.invalid from names as n2);
select firstname from (select * from names as n2) as n1;
select firstname from (select * from names as n2);
select firstname from (select * from names) as n1;
select firstname from (select * from names);
select firstname from (select firstname from names) as n1;
select firstname from (select firstname from names);
select firstname from (select invalid from names) as n1;
select firstname from (select invalid from names);
select firstname from (select lastname from names as n2) as n1;
select firstname from (select lastname from names);
select firstname from (select n1.firstname from names) as n1;
select firstname from (select n1.invalid from names) as n1;
select firstname from (select n2.firstname from names as n2);
select firstname from (select n2.invalid from names as n2);
select invalid from (select * from names as n2) as n1;
select invalid from (select * from names as n2);
select invalid from (select * from names) as n1;
select invalid from (select * from names);
select invalid from (select firstname from names) as n1;
select invalid from (select firstname from names);
select invalid from (select invalid from names as n2) as n1;
select invalid from (select invalid from names) as n1;
select invalid from (select invalid from names);
select invalid from (select n1.firstname from names) as n1;
select invalid from (select n1.invalid from names) as n1;
select invalid from (select n2.firstname from names as n2);
select invalid from (select n2.invalid from names as n2);
select invalid as invalid1 from (select invalid from names);
select invalid as invalid from names;
select invalid1 as invalid from names;
select invalid as invalid1 from names;
select invalid1 from (select invalid2 from names) as n1;
select invalid1 from (select invalid2 from names);
select invalid1 from (select n1.invalid2 from names) as n1;
select invalid1 from (select n2.invalid2 from names as n2);
select invalid1 from (select invalid as invalid1 from names);
select n1.firstname from (select * from names as n2) as n1;
select n1.firstname from (select * from names) as n1;
select n1.firstname from (select n1.firstname from names) as n1;
select n1.firstname from (select n1.invalid from names) as n1;
select n1.firstname from (select n2.firstname from names as n2) as n1;
select n1.firstname from (select n2.invalid from names as n2) as n1;
select n1.invalid from (select * from names as n2) as n1;
select n1.invalid from (select * from names) as n1;
select n1.invalid from (select n1.firstname from names) as n1;
select n1.invalid from (select n1.invalid from names) as n1;
select n1.invalid from (select n2.firstname from names as n2) as n1;
select n1.invalid from (select n2.invalid from names as n2) as n1;
select n1.invalid1 from (select n1.invalid2 from names) as n1;
select n1.invalid1 from (select n2.invalid2 from names as n2) as n1;
select n2.firstname from (select * from names as n2);
select n2.firstname from (select n2.firstname from names as n2);
select n2.firstname from (select n2.invalid from names as n2);
select n2.invalid from (select * from names as n2);
select n2.invalid from (select n2.firstname from names as n2);
select n2.invalid from (select n2.invalid from names as n2);
select n2.invalid1 from (select n2.invalid2 from names as n2);
select NULL as a from names order by a;
CAT
  inputfile="queries_input.txt"
  linenum=1
  set -f	# we use * in the query file so avoid expanding it in the loop below
  while read -r line
  do
  echo $line > query${linenum}.sql
  echo "Running query file query${linenum}.sql : [$line]" >> output.txt
  echo "-------------------------------------------------" >> output.txt
  octo -f query${linenum}.sql >> output.txt 2>&1
  ((linenum++))
  echo "" >> output.txt
  done < $inputfile
  verify_output T0020 output.txt
}

@test "T0021 Select unknown column with 2 inner joins" {
  octo <<OCTO 2>&1 | tee output.txt
CREATE TABLE ORDER1(
 order1_id INTEGER PRIMARY KEY,
 status INTEGER,
 current_action INTEGER
);

CREATE TABLE ORDERORDERACTIONS(
 order1_id INTEGER PRIMARY KEY,
 order_order_actions_id INTEGER KEY NUM 1,
 action CHARACTER(12)
);

CREATE TABLE ORDERSTATUS(
 order_status_id INTEGER PRIMARY KEY
);

SELECT order1
FROM   order1 A
       inner join orderorderactions B
               ON A.current_action = B.order_order_actions_id
       inner join orderstatus C
               ON A.status = C.order_status_id
WHERE  B.action = "NW";
OCTO
  verify_output T0021 output.txt
}

@test "Set envvar ydb_lvnullsubs=2 and try to select from table" {
  export ydb_lvnullsubs=2
  octo <<OCTO 2>&1 | tee output.txt
select * from names limit 1;
OCTO
  verify_output T0022 output.txt
}

@test "Run M function inside of select statement" {
  DDOLAR='$$'
  cp @PROJECT_SOURCE_DIR@/tests/fixtures/USERFUNC1.m .
  octo <<OCTO 2>&1 | tee output.txt
select $DDOLAR^userfunc1(42) from names;
OCTO
  verify_output T0024 output.txt
}

@test "test that multiline strings are inserted in to generated code correctly" {
  octo <<OCTO 2>&1 | tee output.txt
select """
 set ^T0025(1)=1
;"
from names;
OCTO
  yottadb -run %XCMD 'write:$get(^T0025(1))="" "PASS: ^T0025(1) is unset",! write:$get(^T0025(1))=1 "FAIL: set ^T0025(1)=1 was run when it should not have been",!' | tee -a output.txt
  grepCount=$(grep -o '_\$C(10)_' _ydboctoP* | wc -l)
  if [ $grepCount == "2" ]; then
    echo 'PASS: generated M code has the correct number of _$c(10)_' | tee -a output.txt
  else
    echo "FAIL: generated M code has the incorrect number of _\$c(10)_: Expected: 2; Actual: $grepCount" | tee -a output.txt
  fi
  verify_output T0025 output.txt
}

@test "T0026 : #302 : Run M function inside of SELECT statement with a LEFT JOIN" {
  $ydb_dist/mumps -run %XCMD 'set ^%ydboctoocto("functions","DOLLAR_ZWRITE")="$ZWRITE"'
  octo <<OCTO 2>&1 | tee output.txt
SELECT    n1.firstname, DOLLAR_ZWRITE(n2.firstname)
FROM      names n1
LEFT JOIN names n2
ON        n1.lastname = n2.firstname;
OCTO
  verify_output T0026 output.txt
}

